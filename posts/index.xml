<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts -</title><link>http://houugen.fun/posts.html</link><description>All Posts |</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 13 Jul 2020 17:44:54 +0800</lastBuildDate><atom:link href="http://houugen.fun/posts.html" rel="self" type="application/rss+xml"/><item><title>Blog From Hexo To Hugo</title><link>http://houugen.fun/posts/blog%E8%BF%81%E7%A7%BB.html</link><pubDate>Mon, 13 Jul 2020 17:44:54 +0800</pubDate><author>Author</author><guid>http://houugen.fun/posts/blog%E8%BF%81%E7%A7%BB.html</guid><description><![CDATA[最近逛Gayhub看到Hugo，不管框架怎么样，先进官网看主题，颜狗瞬间被皮肤所吸引，回头默默看了下自己的博客，不就是荣耀水晶皮肤和没皮肤的区别么！再浏览文档和上手体验后，竟然还体会到了+10点攻击力的感受，安装、配置、部署、主题、MD即显、Actions配套等处处体现Hugo的简洁、灵活和高效！
随即开始了迁徙之路&hellip;
安装 参照官档：
https://gohugo.io/documentation/
同时Hugo Demo站也提供了详尽文档：
https://hugoloveit.com
主题 个人喜欢黑白极简：
https://themes.gohugo.io/loveit/
配置 着重说下三个小坑：
  搜索功能
未使用开箱即用的lunr（听说对中文不友好），直接用algolia，除了根据Hugo文档配置config.toml对应部分外，为了后续实现Github Actions自动化部署，而使用atomic-algolia，额外需要通过npm init生成package.json后，在其中添加：
... &#34;scripts&#34;: { &#34;test&#34;: &#34;echo \&#34;Error: no test specified\&#34; &amp;&amp; exit 1&#34;, &#34;algolia&#34;: &#34;atomic-algolia&#34; }, ... ``
Actions中workflow配置：
- name:SetupNodeuses:actions/setup-node@v2.1.0with:node-version:&#39;12.x&#39;# ... #- name:SetupAlgoliaenv:ALGOLIA_APP_ID:63ROI1DYLOALGOLIA_ADMIN_KEY:${{secrets.ALGOLIA_ADMIN_KEY}}ALGOLIA_INDEX_NAME:houugen_blogALGOLIA_INDEX_FILE:public/index.jsonrun:npminstallatomic-algolia&amp;&amp;npmrunalgolia  Note  ALGOLIA_ADMIN_KEY为Algolia API Keys中的Admin API Key，将其值添加到Github的Secrets中    文档图片
之前使用Hexo时文章和图片文件夹并行在posts中
➜ houugen.github.io git:(hugo) ✗ tree posts posts/ ├── Blockchain-Security-Articles.md ├── Blockchain-WordCloud │ ├── 1.png │ ├── 2.]]></description></item><item><title>深度学习识别汉字点选验证码</title><link>http://houugen.fun/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html</link><pubDate>Fri, 04 Jan 2019 17:26:00 +0000</pubDate><author>Author</author><guid>http://houugen.fun/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E6%B1%89%E5%AD%97%E7%82%B9%E9%80%89%E9%AA%8C%E8%AF%81%E7%A0%81.html</guid><description>背景 国家企业信用信息公示系统查询时使用极验验证码，大概率为第三代汉字语序点选识别。
查询资料发现可使用深度学习进行汉字定位及分类。
参考资料：
https://runninggump.github.io/2018/11/19/破解含语序问题的点击验证码 https://cos120.github.io/crack/ https://www.cnblogs.com/codefish/p/10104320.html http://www.aneasystone.com/archives/2018/03/python-selenium-geetest-crack.html 实践后效果：
使用的框架、算法及工具：
定位&amp;amp;分类 样本标注：labelImg、若快 训练框架：darknet yolov3 语序识别 百度ocr 结巴分词 百度搜索词频统计 模拟 selenium 滑动轨迹：利用jquery.easing模拟人工轨迹 踩坑 汉字定位和分类学习详尽的实践步骤参考资料中都有说明，这里不再叙述。这里记录下实践过程中踩的坑及一些特殊处理。
darknet环境 坑1：不要使用cpu训练 windows/linux推荐使用 AlexeyAB/darknet，专门定制。 VS2017 + VC++2015 v140工具集 CUDA9.0 （坑2： 10.0 在win10 nvidia gtx 1080 ti上报 cuda error:no error，==！答案搜都搜不到，耽搁许久尝试降级才成功） OpenCV 3.4.0 cuDNN7.1 分类样本 坑3：使用手工标注汉字分类样本500张1h后发现刚不住，可使用打码平台，多进程8w张3h搞定。
坑4：分离1.3k汉字训练后验证100张发现准确率同样为85%！无需更多样本分离更多汉字。
坑5：人工打码准确率不能奢望，又花费1h对词频小于10的茫茫多汉字进行修正（脚本在仓库）。</description></item><item><title>Blockchain Security Articles</title><link>http://houugen.fun/posts/blockchain-security-articles.html</link><pubDate>Thu, 03 Jan 2019 23:30:38 +0000</pubDate><author>Author</author><guid>http://houugen.fun/posts/blockchain-security-articles.html</guid><description>环境:
spider(docker) : scrapy + postgresql
auto(vps) : script(python2markdown &amp;amp; bash2workflow) + travis2hexo
New Articles 2019-01-03 区块链安全—整数溢出原理分析 EOS竞猜游戏ggeos昨晚遭交易回滚攻击 Old Articles 2018-12-29 PeckShield: EOS竞猜游戏LuckBet今晨遭交易回滚攻击 2018-12-28 EOS 回滚攻击手法分析之重放篇 攻击BetDice的黑客团伙再现，竞猜游戏LuckyMe正遭攻击 PeckShield：EOS竞猜游戏GameBet遭受交易回滚攻击 针对Electrum钱包的钓鱼攻击，损失已高达100万美元 以太坊Fountain代币遭溢出攻击 2018-12-26 区块链安全—随机数安全分析（上） EOS 回滚攻击手法分析之黑名单篇 PeckShield：EOS竞猜游戏Lucky Nuts因随机数安全问题暂停 区块链安全—随机数安全分析（下） 2018-12-25 Bitcoin Private（BTCP） 的案例研究 2018-12-24 PeckShield安全播报: EOS竞猜游戏EosDice遭受交易回滚攻击 PeckShield安全播报：EOS竞猜游戏Pickown遭“假转账通知”攻击 PeckShield 安全播报: EOS竞猜游戏LuckBet遭随机数攻击 2018-12-20 EOS DApp 攻击重现之利用黑名单账号进行欺骗攻击 区块链安全—简单函数的危险漏洞分析（一） 2018-12-19 BetDice遭黑客攻击，损失近20万EOS ToBet遭到黑客恶意攻击 Big.</description></item><item><title>iOS Hook FridaDev</title><link>http://houugen.fun/posts/ios-hook-fridadev.html</link><pubDate>Fri, 30 Nov 2018 09:52:00 +0000</pubDate><author>Author</author><guid>http://houugen.fun/posts/ios-hook-fridadev.html</guid><description>FridaDev 作为大自然的搬运工和组装师傅，收集并增强一些非常有用的frida脚本封装为FridaDev工具，可以实现一键式逆向需求，提高生产力。
脚本来源：
https://github.com/0xdea/frida-scripts https://github.com/AloneMonkey/iOSREBook/tree/master/chapter-7/7.3%20Frida%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/Frida 修改：
动态hook ui增加打印controller和action 根据稳定性trace选择spwan，其他功能选择attach 仓库直通车：https://github.com/houugen/FridaDev
功能 usage: fridaDev.py [-h] [-l] [-i] [-u appName] [-d appName] [-t identifier] [-e identifier] frida tools optional arguments: -h, --help show this help message and exit -l, --list list running processes -i, --info list installed app infomation -u appName, --ui appName show UI (only for ios) -d appName, --dynhook appName dynamic hook -t identifier, --trace identifier ObjC/java and Module tracer -e identifier, --enumerate identifier Collection of functions to enumerate classes and list 功能：列出运行进程名及pid</description></item><item><title>iOS逆向笔记</title><link>http://houugen.fun/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html</link><pubDate>Fri, 12 Oct 2018 14:52:00 +0000</pubDate><author>Author</author><guid>http://houugen.fun/posts/ios%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0.html</guid><description><![CDATA[iOS系统安全架构  安全启动链  信任链：系统启动 -&gt; boot rom -&gt; LLB -&gt; iBoot -&gt; kernal   系统软件授权  固件 -&gt; cpu -&gt; itunes ==&gt; 服务器验证  低版本服务器返回验证许可，可通过保存shsh绕过验证 高版本返回验证许可+随机串     应用代码签名  所有可执行代码（动态库，动态资源）运行时验证签名   运行时进程安全  沙盒：/var/mobile/Containers/Data/Application/[GUID] DEP ASLR   数据加密保护  硬件秘钥 + 密码秘钥 -&gt; 类秘钥 硬件秘钥 -&gt; 文件系统秘钥 类秘钥 + 文件系统秘钥 -&gt; 文件秘钥 =&gt; 文件内容    越狱  Cydia Substrate  MobileHooker MobileLoader safe mode   ssh连接ios设备   openssh]]></description></item><item><title>Blockchain WordCloud</title><link>http://houugen.fun/posts/blockchain-wordcloud.html</link><pubDate>Thu, 23 Aug 2018 15:05:02 +0000</pubDate><author>Author</author><guid>http://houugen.fun/posts/blockchain-wordcloud.html</guid><description>区块链安全云词
爬虫：scrapy
数据库：postgresql
分词：jieba
词频：py脚本（注意数据清洗)
云词：wordart
字体：Aa荷包鼓鼓</description></item><item><title>#DASP# Short Addresses (9)</title><link>http://houugen.fun/posts/dasp-short-addresses-9.html</link><pubDate>Mon, 20 Aug 2018 15:40:14 +0000</pubDate><author>Author</author><guid>http://houugen.fun/posts/dasp-short-addresses-9.html</guid><description>0x00 Info 短地址攻击是DASP TOP10中详细描述的最后一类漏洞。这个漏洞其实可以归结于过去EVM的缺陷。
0x01 基础知识 Quote The Contract Application Binary Interface (ABI) is the standard way to interact with contracts in the Ethereum ecosystem, both from outside the blockchain and for contract-to-contract interaction. 在EVM虚拟机中合约是通过ABI接口进行交互，数据和方法都根据特定标准进行编解码。具体参见Contract ABI Specification。
如何通过ABI调用合约方法？方法和数据如何编码？我们举例（经典Token合约）来说明：
contract MyToken { mapping (address =&amp;gt; uint) balances; event Transfer(address indexed _from, address indexed _to, uint256 _value); function MyToken() { balances[tx.origin] = 10000; } function sendCoin(address to, uint amount) returns(bool sufficient) { if (balances[msg.</description></item><item><title>#DASP# Time Manipulation (8)</title><link>http://houugen.fun/posts/dasp-time-manipulation-8.html</link><pubDate>Sun, 19 Aug 2018 16:13:53 +0000</pubDate><author>Author</author><guid>http://houugen.fun/posts/dasp-time-manipulation-8.html</guid><description>0x00 Info 如果攻击者拥有矿工角色，在交易打包成块时，矿工在一定范围是可以操作块的时间戳的，而恰恰合约利用时间戳生成逻辑（特别是涉及到资金交易）就会存在Time manipulation风险。
0x01 Rules 一个合约需要用到“当前时间”，通常是通过block.timestamp或者now来实现，而这个值来源于矿工！矿工是可以在几秒内调整这个时间戳的，从而为自己的利益改变合同的输出。
例如一个合约使用时间戳来生成随机数（在example中有实例），矿工可以在区块被验证后30s内发布时间戳，从而利用这30s的时间增加自己获利概率。
30-second Rule
矿工可以改变区块的时间戳
仅限于被验证后的30s 当前块的时间戳不能小于前一块的时间戳 但是一个合约具备以下特性，是可以安全使用时间戳的： Quote If the smart contract function can tolerate a 30-second time period, it’s safe to use timestamp; If the scale of a time-dependent event can vary by 30 seconds and maintain integrity, it’s also safe to use a block timestamp.
0x02 Examples 前两个实例合约主要利用block.timestamp来生成随机数，而在#DASP# Bad Randomness一文中我们详细介绍了这种随机数生成的缺陷。
theRun Source Code</description></item><item><title>#DASP# Front Running (7)</title><link>http://houugen.fun/posts/dasp-front-running-7.html</link><pubDate>Thu, 16 Aug 2018 14:58:48 +0000</pubDate><author>Author</author><guid>http://houugen.fun/posts/dasp-front-running-7.html</guid><description><![CDATA[0x00 Info 本篇介绍DASP第七种漏洞类型&ndash;前置执行。 可以理解为因为区块链是公开，其他用户或者合约的交易信息均透明可查，恶意用户可以利用这些已知信息制造有利于自己的交易，并通过提高手续费的方式抢先执行获利。
当然，在front-running-griefing-and-the-perils-of-virtual-settlement中描述，如果这个恶意用户本身又是矿工，可以任意安排交易并审查其他人交易，使自己利益最大化。
0x01 实例 LastIsMe Contract Source Code
LastIsMe是一个lottery游戏合约，在一个游戏回合（一定的区块数内）参与者购买一张票认领最后一个座位，回合结束时最后一个就坐的玩家会获得头奖。
攻击者可以在回合快结束时观察其他玩家的交易池，通过提高gas来挤掉其他玩家的交易从而获得奖金。
ICO Contract Source Code
ICO本身是一道CTF题，它包含一个DAPP网站和与其交互的两个合约（HaCoin &amp; ICO），部署在rinkeby测试链上。
HaCoin是一个Token合约，比赛的目标也是从该合约中获取超过31337枚HackCoin，而这个合约本身并没有问题，需要配合Web网站存在的XSS漏洞来提权，才能进行转币操作。很有意思，具体writeup参见ZeroNights ICO Hacking Contest Writeup。
而另一个合约ICO是一个lottery合约，游戏规则也很简单，5个块为一回合，回合内参与者猜一个数字，回合结束时机器人会随机抛出一个数字，如果谁猜中谁就获胜。而该合约存在前置执行漏洞。
function spinLottery(uint number) public { if (msg.sender != robotAddress) { playerNumber[msg.sender] = number; players.push(msg.sender); NewLotteryBet(msg.sender); } else { require(block.number - lotteryBlock &gt; 5); lotteryBlock = block.number; for (uint i = 0; i &lt; players.length; i++) { if (playerNumber[players[i]] == number) { desires[players[i]].active = true; desires[players[i]].]]></description></item><item><title>#DASP# Bad Randomness (6)</title><link>http://houugen.fun/posts/dasp-bad-randomness-6.html</link><pubDate>Thu, 09 Aug 2018 15:17:12 +0000</pubDate><author>Author</author><guid>http://houugen.fun/posts/dasp-bad-randomness-6.html</guid><description>0x00 Info 绝对的随机在Ethereum中很难实现，因为所有参数都可以在透明的链上查询，因此想要利用随机特性生成逻辑很容易出现bug，本篇就介绍DASP中第六类漏洞&amp;ndash;不安全的随机性。
0x01 错误实践 Solidity本身提供一些获取“随机值”的方法和变量，你可以在官方文档中查看。但是这些“随机值”（在链上公开）如果不当的作为生成随机数的因子或种子，那随机数就可以被预测。
根据DASP提供的实例我们看看有哪些坑。
第一种
uint256 private seed; function play() public payable { require(msg.value &amp;gt;= 1 ether); iteration++; uint randomNumber = uint(keccak256(seed + iteration)); if (randomNumber % 2 == 0) { msg.sender.transfer(this.balance); } } 利用私有变量seed和iteration通过keccak256 hash计算得到随机数，虽然seed属性为private，但是它也要在某个时间点设置，可以通过链上相关tx来获取其值，因此随机性可预测。
第二种
function play() public payable { require(msg.value &amp;gt;= 1 ether); if (block.blockhash(blockNumber) % 2 == 0) { msg.sender.transfer(this.balance); } } 这里使用block.blockhash(blockNumber)来计算随机数，这里必须强调的是，在solidity中，block.blockhash(uint blockNumber) returns (bytes32)只计算就近的256个块hash，如果blockNumber为当前块（block.number）或者超过256更久远的块，计算结果都是0.
Quote block.blockhash(uint blockNumber) returns (bytes32): hash of the given block - only works for 256 most recent blocks excluding current</description></item></channel></rss>