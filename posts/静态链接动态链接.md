# é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥


>  iOS AOPæ–‡ç« ç³»åˆ—
>
>  å‰å¯¼çŸ¥è¯†ï¼š
>  * [Mach-Oæ–‡ä»¶ç»“æ„åˆ†æ](https://houugen.fun/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html)
>  * [é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥](https://houugen.fun/posts/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html)
>  * OCæ–¹æ³•&OCç±»&OCå¯¹è±¡
>  * æ–¹æ³•æŸ¥æ‰¾å’Œæ¶ˆæ¯è½¬å‘
>
>  AOPæ¡†æ¶ï¼š
>  * Method Swizzling
>  * Fishhook
>  * Apsects
>  * NSProxy AOP

## é™æ€é“¾æ¥

è¿˜æ˜¯é€šè¿‡ ğŸŒ° æ¥åˆ†æï¼š

```shell
âœ  ios cat bar.c
int global = 1;
void fizz(int a) {
    global = a;
}
âœ  ios cat main.c
extern int global;
void fizz(int a);
int main() {
    fizz(100 + global);
    return 0;
}
```

ç¼–è¯‘é“¾æ¥ `bar.c` å’Œ `main.c` ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ `main`

```shell
âœ  ios xcrun -sdk iphoneos clang -c bar.c main.c -target arm64-apple-ios13.4
âœ  ios xcrun -sdk iphoneos clang bar.o main.o -o main -target arm64-apple-ios13.4
```

æˆ‘ä»¬çœ‹ä¸‹é“¾æ¥å‰åç¬¦å·è¡¨çš„å˜åŒ–ï¼š

```shell
âœ  ios jtool -S bar.o
0000000000000000 T _fizz
0000000000000020 D _global
âœ  ios jtool -S main.o
0000000000000000 T _main
                 U _fizz
                 U _global
âœ  ios jtool -S main
0000000100000000 T __mh_execute_header
0000000100007f54 T _fizz
0000000100008000 D _global
0000000100007f74 T _main
                 U dyld_stub_binder
```

åœ¨é“¾æ¥å‰ `bar.o` ä¸­ `fizz` å’Œ `global` ç¬¦å·åœ°å€ä¸ºä¸´æ—¶åœ°å€ï¼Œ`main.o` ä¸­ `main` ç¬¦å·ä¸ºä¸´æ—¶åœ°å€ï¼Œ`fizz` å’Œ `global` ç¬¦å·æœªå®šä¹‰ï¼Œé™æ€é“¾æ¥ä¸ºå¯æ‰§è¡Œæ–‡ä»¶ `main` åï¼Œå‘ç°å„ç¬¦å·éƒ½æœ‰äº†å¯¹åº”åœ°å€ï¼Œè¿™ä¸­é—´å‘ç”Ÿäº†ä»€ä¹ˆå‘¢ï¼Ÿ

å…¶ä¸­å…³é”®å°±æ˜¯**ç¬¦å·çš„è§£æ**å’Œ**é‡å®šä½**ã€‚

ç”¨ MachOView æŸ¥çœ‹ `main.o` æ–‡ä»¶ï¼š

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616051573607-0e9cbfb7-806e-41c7-bdbe-0560d945de0c.png)

ä»£ç ä¸­ç¬¦å·çš„ä½ç½®ç”¨ `global` å’Œ `fizz` æš‚æ—¶ç”¨`0x0`å’Œ`0x2c`æ›¿ä»£ï¼Œé“¾æ¥å™¨åœ¨å®Œæˆåœ°å€ç©ºé—´åˆ†é…åï¼Œå°±å¯ä»¥ç¡®å®šç¬¦å·çš„è™šæ‹Ÿåœ°å€äº†ï¼Œé“¾æ¥å™¨æ ¹æ®ç¬¦å·åœ°å€å¯¹æ¯ä¸ªéœ€è¦é‡å®šä½çš„æŒ‡ä»¤è¿›è¡Œåœ°å€ä¿®æ­£ï¼Œé€šè¿‡ `_text` å¤´ä¸­å¯ä»¥çœ‹åˆ°éœ€è¦é‡å®šä½çš„æœ‰ä¸‰å¤„ä»¥åŠé‡å®šä½è¡¨åç§»ï¼ˆ488 = 0x1E8ï¼‰ã€‚

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616052019933-d437e4f8-afe1-47a7-8b94-b4bd704a8a93.png)

è€Œå…·ä½“é‡å®šä½ä¿¡æ¯åœ¨é‡å®šä½è¡¨ `Relocations` ä¸­ï¼š

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616052905516-370e52eb-c467-4df9-927a-61c3e43efb6a.png)

é‡å®šä½è¡¨ç»“æ„ä¸ºï¼š

```
struct relocation_info {
   int32_t  r_address;  /* offset in the section to what is being
                   relocated */
   uint32_t     r_symbolnum:24, /* symbol index if r_extern == 1 or section
                   ordinal if r_extern == 0 */
        r_pcrel:1,  /* was relocated pc relative already */
        r_length:2, /* 0=byte, 1=word, 2=long, 3=quad */
        r_extern:1, /* does not include value of sym referenced */
        r_type:4;   /* if not 0, machine specific relocation type */
};
```

å…¶ `r_symbolnum` å…·ä½“ä¸º `Symbol` ç¬¦å·è¡¨ä¸­ `index`

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616052930555-0fa0b1ed-5579-4417-ac17-4db11b9b9163.png)

ç¬¦å·è¡¨æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå…ƒç´ ç»“æ„ä¸º `nlist_64`ï¼š

```
struct nlist_64 {
    union {
        uint32_t n_strx;   /* index into the string table */
    } n_un;
    uint8_t  n_type;       /* type flag, see below */
    uint8_t  n_sect;       /* section number or NO_SECT */
    uint16_t n_desc;       /* see <mach-o/stab.h> */
    uint64_t n_value;      /* value of this symbol (or stab offset) */
};
```

é“¾æ¥åï¼ˆ`main`ï¼‰çš„ç¬¦å·è¡¨ï¼Œå…¶ `n_value` å·²ç»æ›¿æ¢ä¸ºçœŸå®åœ°å€ï¼š

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616079174800-30bbebe4-11b5-4b1f-8a5c-da47e9462bdc.png)

## åŠ¨æ€é“¾æ¥

é™æ€é“¾æ¥æ˜¯**è¿è¡Œå‰**å°±ç”¨ `ld` é“¾æ¥å™¨é“¾æ¥æˆä¸€ä¸ªå®Œæ•´çš„ç¨‹åºï¼Œè€ŒåŠ¨æ€é“¾æ¥æ˜¯ç¨‹åºä¸»æ¨¡å—è¢«åŠ è½½æ—¶å€™ï¼Œé€šè¿‡ `dyld` åŠ è½½å‘½ä»¤ï¼ŒæŠŠ `dylib` åŠ è½½åˆ°å†…å­˜ï¼Œç„¶åå°†ç¨‹åºä¸­æ‰€æœ‰æœªå†³è®®çš„ç¬¦å·ç»‘å®šåˆ°ç›¸åº”çš„ `dylib` ä¸­ï¼Œå¹¶è¿›è¡Œé‡å®šä½å·¥ä½œã€‚

åŠ¨æ€é“¾æ¥å™¨åŠ è½½å‘½ä»¤ `LC_LOAD_DYLINKER`ï¼š

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616080052259-10e499da-d350-40be-a591-4ab8960dc84c.png)

åŠ¨æ€é“¾æ¥åº“åŠ è½½å‘½ä»¤ `LC_LOAD_DYLIB`ï¼š

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616080117478-dfaa7aef-8cf5-4f5c-9cdd-daaec7d10df4.png)

è¿˜æ˜¯ç”¨ä¹‹å‰çš„ ğŸŒ° ï¼Œä½†æ˜¯æˆ‘ä»¬é€šè¿‡åŠ¨æ€é“¾æ¥åº“ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ `main_dyld`

```sh
âœ  ios xcrun -sdk iphoneos clang -c main.c -o main_dyld.o -target arm64-apple-ios13.4
âœ  ios xcrun -sdk iphoneos clang -fPIC -shared bar.c -o libbar.dylib -target arm64-apple-ios13.4
âœ  ios xcrun -sdk iphoneos clang main_dyld.o -o main_dyld -L . -l bar -target arm64-apple-ios13.4
```

æˆ‘ä»¬æŸ¥çœ‹ `main_dyld` çš„ç¬¦å·è¡¨ï¼Œå‘ç°å¹¶æ²¡æœ‰çœŸå®åœ°å€ï¼Œä½†æ˜¯æ ‡è®°äº†è¯¥ç¬¦å·æ¥è‡ªåŠ¨æ€åº“ `libbar.dylib`ï¼š

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616080726776-71e3446c-e580-4aa0-9aa5-e3ce46031ef7.png)

æˆ‘ä»¬è·Ÿè¸ª `_TEXT,__text` çœ‹ä¸‹ `global` å˜é‡ å’Œ `fizz` å‡½æ•°æ˜¯å¦‚ä½•é‡å®šä½çš„

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616082634070-cc9b2245-754b-4a5a-bdea-57c353c82c3f.png)

`global` æ˜¯é€šè¿‡ `adrp` å’Œ `ldr` æŒ‡ä»¤é—´æ¥å¯»å€ï¼Œå–`0x100008000`é‡Œé¢çš„å€¼ï¼Œè€Œè¿™ä¸ªåœ°å€æŒ‡å‘çš„ `got`(ä¹Ÿç§° `Non-Lazy Symbol Pointers` ) è¡¨ä¸­ï¼š

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616083101771-f7f8a583-f570-4db4-b845-4a75daa9c463.png)

åœ¨ç¨‹åºè£…è½½è¿‡ç¨‹ä¸­ï¼Œä¼šé‡å®šä½ `got` è¡¨ä¸­åœ°å€ï¼Œä½†æ˜¯å¦‚ä½•çŸ¥é“è¿™æ˜¯ä»€ä¹ˆç¬¦å·ï¼Ÿä»¥åŠè¿™ä¸ªç¬¦å·æ¥è‡ªå“ªé‡Œï¼Ÿ

è¿™å°±éœ€è¦ç”¨åˆ° **Section64 Header(__got)** ä¸­çš„ `reserved1` å­—æ®µï¼Œå®ƒä»£è¡¨åœ¨é—´æ¥ç¬¦å·è¡¨ï¼ˆ`Indirect Symbols`ï¼‰ä¸­çš„ `index`

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616083318418-eb2b455c-adcd-49b3-8284-3799e8d77c51.png)

è€Œé—´æ¥ç¬¦å·è¡¨æœ¬èº«å­˜çš„æ˜¯ç¬¦å·è¡¨ä¸­çš„ `index`ï¼Œå¯ä»¥çœ‹åˆ° index=1 çš„é¡¹å€¼ä¸º4ï¼Œä»£è¡¨ç¬¦å·è¡¨ä¸­ index=4 çš„é¡¹

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616083546713-b82bb228-384c-4890-bbc1-a733fa7a3c0c.png)

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616083716102-84a1698d-224e-4411-9c68-98e12b6a7657.png)

22ä»£è¡¨åœ¨ `String Table` ä¸­åç§»22çš„å­—ç¬¦ä¸²ï¼Œå³ä¸º `_global`ï¼Œå¹¶ä¸”æè¿° `_global` æ¥è‡ª `libbar.dylib` åŠ¨æ€åº“ï¼Œè§£å†³äº†ä¸Šè¿°ä¸¤ä¸ªé—®é¢˜ï¼Œç°åœ¨å¯ä»¥é‡å®šä½ `got` è¡¨ä¸­ç¬¬ä¸€ä¸ªç¬¦å·åœ°å€ã€‚



åœ¨çœ‹ä¸‹ `fizz` å‡½æ•°çš„é‡å®šä½è¿‡ç¨‹

`bl #0x100007f88`

æŒ‡å‘ `_stubs` ç¬¦å·æ¡©ä¸­

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616084090534-23415a04-a235-498d-b535-fc057efb2a51.png)

```shell
âœ  ios otool -v main_dyld -s __TEXT __stubs
main_dyld:
Contents of (__TEXT,__stubs) section
0000000100007f88    nop
0000000100007f8c    ldr x16, #0x4074            ; Latency: 4
0000000100007f90    br  x16
```

0x7f8c + 0x4074 = 0xc000

æŒ‡å‘ `__la_symbol_str` æ•°æ®æ®µ

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616084517026-e59964a7-5bc6-4150-8bd5-faaa7f49e199.png)

åŒæ ·æˆ‘ä»¬æ ¹æ® **Section64 Header(la_symbol_str)** ä¸­çš„ `reserverd1` èƒ½å¤ŸçŸ¥é“å…¶ç¬¦å·åä¸º `_fizz`ï¼Œè€Œè¯¥å‡½æ•°çš„å…·ä½“å®ç°æŒ‡å‘äº† `0x7fac` ï¼ˆ`stub_helper` æ¡©ä»£ç æ®µ)

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1616084754983-40f42096-9d26-4c3f-9984-b26af85cfd65.png)

é€šè¿‡ `b #0x100007f94` è·³åˆ°èŠ‚å¤´åœ°å€ï¼Œç„¶åèµ°åˆ° `br x16` ï¼Œ`x16` ä¸ºå­˜å‚¨ `0x1000080008` åœ¨çš„ `dyld_stub_binder` å‡½æ•°

![image.png](./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1617260104224-49b92146-2ca7-49ed-94a1-d8c3afd28757.png)

è¿™ä¸ªæˆ‘ä»¬åœ¨[Mach-Oæ–‡ä»¶ç»“æ„åˆ†](https://houugen.fun/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html)æä¸­å·²ç»è®²è¿‡ï¼Œæ˜¯ä¸€ä¸ªå»¶è¿Ÿç»‘å®šçš„è¿‡ç¨‹ï¼Œç¬¬ä¸€æ¬¡è°ƒç”¨å¤–éƒ¨å‡½æ•°ï¼Œä¼šè°ƒç”¨ `dyld_stub_binder` å‡½æ•°å»å¯»å€å‡½æ•°åœ°å€ï¼Œç„¶åå†™å…¥ `__la_symbol_str` æ®µï¼Œä¹‹åå†è°ƒåŒæ ·çš„å‡½æ•°å°±ä¼šç›´æ¥è®¿é—®å‡½æ•°å®ç°åœ°å€ã€‚æˆ‘ä»¬çœ‹ä¸‹ `dyld_stub_binder` å…·ä½“[æºç ](https://opensource.apple.com/source/dyld/dyld-195.5/src/dyld_stub_binder.s)å®ç°ï¼š

```
#if __arm__
 /*    
 * sp+4 lazy binding info offset
 * sp+0 address of ImageLoader cache
 */
  
    .text
    .align 2
    .globl  dyld_stub_binder
dyld_stub_binder:
    stmfd   sp!, {r0,r1,r2,r3,r7,lr}    // save registers
    add r7, sp, #16         // point FP to previous FP

    ldr r0, [sp, #24]           // move address ImageLoader cache to 1st parameter
    ldr r1, [sp, #28]           // move lazy info offset 2nd parameter

    // call dyld::fastBindLazySymbol(loadercache, lazyinfo)
    bl  __Z21_dyld_fast_stub_entryPvl
    mov ip, r0              // move the symbol`s address into ip

    ldmfd   sp!, {r0,r1,r2,r3,r7,lr}    // restore registers
    add sp, sp, #8          // remove meta-parameters

    bx  ip              // jump to the symbol`s address that was bound

#endif /* __arm__ */
```

è°ƒç”¨ `fastBindLazySymbol` å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¹Ÿå¯ä»¥åœ¨ [git](https://github.com/opensource-apple/dyld/blob/master/src/dyld.cpp) ä¸Šæ‰¾åˆ°ï¼š

```c++
uintptr_t fastBindLazySymbol(ImageLoader** imageLoaderCache, uintptr_t lazyBindingInfoOffset)
{
    uintptr_t result = 0;
    // get image 
    if ( *imageLoaderCache == NULL ) {
        // save in cache
        *imageLoaderCache = dyld::findMappedRange((uintptr_t)imageLoaderCache);
        if ( *imageLoaderCache == NULL ) {
            const char* message = "fast lazy binding from unknown image";
            dyld::log("dyld: %s\n", message);
            halt(message);
        }
    }
    
    // bind lazy pointer and return it
    try {
        result = (*imageLoaderCache)->doBindFastLazySymbol((uint32_t)lazyBindingInfoOffset, gLinkContext, 
                                (dyld::gLibSystemHelpers != NULL) ? dyld::gLibSystemHelpers->acquireGlobalDyldLock : NULL,
                                (dyld::gLibSystemHelpers != NULL) ? dyld::gLibSystemHelpers->releaseGlobalDyldLock : NULL);
    }
    catch (const char* message) {
        dyld::log("dyld: lazy symbol binding failed: %s\n", message);
        halt(message);
    }

    // return target address to glue which jumps to it with real parameters restored
    return result;
}
```

çœŸæ­£è¿›è¡Œç¬¦å·ç»‘å®šçš„æ“ä½œåœ¨ `doBindFastLazySymbol` ä¸­ï¼š

```c++
uintptr_t ImageLoaderMachOCompressed::doBindFastLazySymbol(uint32_t lazyBindingInfoOffset, const LinkContext& context,
                                                            void (*lock)(), void (*unlock)())
{
    // <rdar://problem/8663923> race condition with flat-namespace lazy binding
    if ( this->usesTwoLevelNameSpace() ) {
        // two-level namespace lookup does not require lock because dependents can't be unloaded before this image
    }
    else {
        // acquire dyld global lock
        if ( lock != NULL )
            lock();
    }
    
    const uint8_t* const start = fLinkEditBase + fDyldInfo->lazy_bind_off;
    const uint8_t* const end = &start[fDyldInfo->lazy_bind_size];
    if ( lazyBindingInfoOffset > fDyldInfo->lazy_bind_size ) {
        dyld::throwf("fast lazy bind offset out of range (%u, max=%u) in image %s", 
            lazyBindingInfoOffset, fDyldInfo->lazy_bind_size, this->getPath());
    }

    uint8_t type = BIND_TYPE_POINTER;
    uintptr_t address = 0;
    const char* symbolName = NULL;
    uint8_t symboFlags = 0;
    long libraryOrdinal = 0;
    bool done = false;
    uintptr_t result = 0;
    const uint8_t* p = &start[lazyBindingInfoOffset];
    while ( !done && (p < end) ) {
        uint8_t immediate = *p & BIND_IMMEDIATE_MASK;
        uint8_t opcode = *p & BIND_OPCODE_MASK;
        ++p;
        switch (opcode) {
            case BIND_OPCODE_DONE:
                done = true;
                break;
            case BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:
                libraryOrdinal = immediate;
                break;
            case BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:
                libraryOrdinal = read_uleb128(p, end);
                break;
            case BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:
                // the special ordinals are negative numbers
                if ( immediate == 0 )
                    libraryOrdinal = 0;
                else {
                    int8_t signExtended = BIND_OPCODE_MASK | immediate;
                    libraryOrdinal = signExtended;
                }
                break;
            case BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:
                symbolName = (char*)p;
                symboFlags = immediate;
                while (*p != '\0')
                    ++p;
                ++p;
                break;
            case BIND_OPCODE_SET_TYPE_IMM:
                type = immediate;
                break;
            case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
                if ( immediate >= fSegmentsCount )
                    dyld::throwf("BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is too large (0..%d)", 
                            immediate, fSegmentsCount-1);
                address = segActualLoadAddress(immediate) + read_uleb128(p, end);
                break;
            case BIND_OPCODE_DO_BIND:
                
            
                result = this->bindAt(context, address, type, symbolName, 0, 0, libraryOrdinal, "lazy ", NULL, true);
                break;
            case BIND_OPCODE_SET_ADDEND_SLEB:
            case BIND_OPCODE_ADD_ADDR_ULEB:
            case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:
            case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:
            case BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:
            default:
                dyld::throwf("bad lazy bind opcode %d", *p);
        }
    }   
    
    if ( !this->usesTwoLevelNameSpace() ) {
        // release dyld global lock
        if ( unlock != NULL )
            unlock();
    }
    return result;
}
```

è¿™é‡Œé€šè¿‡ `__LINKEDIT` æ®µçš„åŸºåœ°å€ + `Lazy Binding Info` åç§»ï¼ˆ`LC_DYLD_INFO_ONLY` åŠ è½½å‘½ä»¤ä¸­ï¼‰è®¡ç®— `Lazy Binding Info` åœ°å€

{{< figure src="./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1617260747319-f008c915-4609-420e-9e8e-0d7dbf4fcaa6.png" width="100%" >}}

å¹¶é€šè¿‡å‡½æ•°åœ¨è¡¨åç§»å®šä½å…·ä½“å‡½æ•°ä¿¡æ¯ï¼Œçœ‹åˆ° _fizz æ˜¯åœ¨ `libbar.dylib` åŠ¨æ€åº“ä¸­ï¼Œå¾…æ”¹å†™çš„åŒºåŸŸä¸º `__DATA.__la_symbol_str`

{{< figure src="./é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥.assets/1617260801883-5195b8e1-ede9-4ee7-95aa-0e865b3b409f.png" width="100%" >}}

æœ€åè°ƒç”¨ `bindAt` æ–¹æ³•é€šè¿‡ç¬¦å·ååœ¨ç›®æ ‡åº“ä¸­è·å–å‡½æ•°çœŸå®åœ°å€ï¼Œå¹¶è°ƒç”¨ `bindLocation` æ–¹æ³•æ”¹å†™ `__la_symbol_str` ä¸­æŒ‡å‘ã€‚

```c++
uintptr_t ImageLoaderMachOCompressed::bindAt(const LinkContext& context, uintptr_t addr, uint8_t type, const char* symbolName, 
                                uint8_t symboFlags, intptr_t addend, long libraryOrdinal, const char* msg, 
                                LastLookup* last, bool runResolver)
{
    const ImageLoader*  targetImage;
    uintptr_t           symbolAddress;
    
    // resolve symbol
    symbolAddress = this->resolve(context, symbolName, symboFlags, libraryOrdinal, &targetImage, last, runResolver);

    // do actual update
    return this->bindLocation(context, addr, symbolAddress, targetImage, type, symbolName, addend, msg);
}
```



åŠ¨æ€é“¾æ¥çš„è¿‡ç¨‹å°±ç»“æŸäº†ï¼Œè¿™å…¶ä¸­æ¶‰åŠåˆ°å‡ ä¸ªå…³é”®åŸç†å’Œæ¦‚å¿µï¼š

- ç›¸å¯¹å¯»å€å’Œé—´æ¥å¯»å€
- `PIC`åŸç†
- å»¶è¿Ÿç»‘å®š
- `got` å’Œ `la_symbol_ptr`
- `dyld` åŠ¨æ€é“¾æ¥

### PICåŸç†

ä¸Šè¿° `global` å’Œ `fizz` ä¸¤ä¸ªç¬¦å·æ˜¯åœ¨åŠ¨æ€åº“ä¸­ï¼Œè€ŒåŠ¨æ€åº“æ˜¯å¯ä»¥è¢«å¤šä¸ªè¿›ç¨‹å…±äº«çš„ï¼Œè€ŒåŠ¨æ€åº“ç¼–è¯‘æ—¶ä¸çŸ¥é“è‡ªå·±åœ¨è¿›ç¨‹ä¸­çš„è™šæ‹Ÿå†…å­˜åœ°å€ï¼Œå› æ­¤åŠ¨æ€åº“ä¸­ä¸èƒ½åŒ…å«ç»å¯¹åœ°å€ï¼Œé‚£åŠ¨æ€åº“å¦‚ä½•å°†ä»£ç æ®µåšåˆ°ä¸ä½ç½®æ— å…³å…±äº«å‡ºå»ï¼Œå°±éœ€è¦å°†å¯¹åœ°å€çš„å¼•ç”¨åˆ†ç¦»ï¼Œæ”¾åˆ°ä¸»ç¨‹åºæ•°æ®éƒ¨åˆ†ï¼ˆå¯ä¿®æ”¹ï¼‰ï¼Œåœ¨åŠ è½½å’Œè¿è¡Œè¿‡ç¨‹åšå¯»å€ç»‘å®šæ“ä½œã€‚

### got å’Œ la_symbol_ptr

é€šè¿‡ä¸Šè¿°åˆ†æï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åŠ¨æ€åº“æ•°æ® (`global`) åœ°å€æ”¾åˆ° **got (Non-Lazy Symbol Pointers)** æ•°æ®æ®µï¼Œéæƒ°æ€§ä»£è¡¨åŠ¨æ€é“¾æ¥é˜¶æ®µå°±å¯»æ‰¾å¥½æ‰€æœ‰æ•°æ®ç¬¦å·çš„åœ°å€ï¼›è€Œå‡½æ•° (`fizz`) ç”¨äº†å»¶è¿Ÿç»‘å®šæŠ€æœ¯ï¼Œå°†å¤–éƒ¨å‡½æ•°åœ°å€æ”¾åœ¨ **la_symbol_ptr (Lasy Symbol Pointers)** æ•°æ®æ®µï¼Œæƒ°æ€§çš„ï¼Œç¨‹åºç¬¬ä¸€æ¬¡è°ƒç”¨åˆ°è¿™ä¸ªå‡½æ•°æ‰å¯»å€çœŸå®åœ°å€å¹¶å†™å…¥è¿™ä¸ªæ•°æ®æ®µã€‚
