# æ–¹æ³•æŸ¥æ‰¾å’Œæ¶ˆæ¯è½¬å‘


>  iOS AOPæ–‡ç« ç³»åˆ—
>
>  å‰å¯¼çŸ¥è¯†ï¼š
>  * [Mach-Oæ–‡ä»¶ç»“æ„åˆ†æ](https://houugen.fun/posts/mach-o%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html)
>  * [é™æ€é“¾æ¥&åŠ¨æ€é“¾æ¥](https://houugen.fun/posts/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.html)
>  * [OCæ–¹æ³•&OCç±»&OCå¯¹è±¡](https://houugen.fun/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html)
>  * [æ–¹æ³•æŸ¥æ‰¾å’Œæ¶ˆæ¯è½¬å‘](https://houugen.fun/posts/%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.html)
>
>  AOPæ¡†æ¶ï¼š
>  * Method Swizzling
>  * Fishhook
>  * Apsects
>  * NSProxy AOP

{{< admonition tip >}}
**æºç åˆ†æç¯å¢ƒï¼šobjc4-818.2**
{{< /admonition >}}

æ ¹æ®ä¹‹å‰çš„æ–‡ç« æˆ‘ä»¬çŸ¥é“OCæ–¹æ³•çš„æœ¬è´¨å°±æ˜¯è°ƒç”¨ `obj_msgSend`ï¼Œé‚£ä¹ˆæˆ‘ä»¬å…·ä½“åˆ†æä¸‹ ObjC ä¸‹æ–¹æ³•çš„æŸ¥æ‰¾å’Œè½¬å‘æœºåˆ¶ã€‚

`obj_msgSend` çš„å®ç°åœ¨ `obj-msg-rm64.s` ä¸­çš„æ±‡ç¼–ä»£ç ä¸ºï¼š

```
ENTRY _objc_msgSend
    UNWIND _objc_msgSend, NoFrame

    cmp p0, #0          // nil check and tagged pointer check
#if SUPPORT_TAGGED_POINTERS
    b.le    LNilOrTagged        //  (MSB tagged pointer looks negative)
#else
    b.eq    LReturnZero
#endif
    ldr p13, [x0]       // p13 = isa
    GetClassFromIsa_p16 p13, 1, x0  // p16 = class
LGetIsaDone:
    // calls imp or objc_msgSend_uncached
    CacheLookup NORMAL, _objc_msgSend, __objc_msgSend_uncached

#if SUPPORT_TAGGED_POINTERS
LNilOrTagged:
    b.eq    LReturnZero     // nil check
    GetTaggedClass
    b   LGetIsaDone
// SUPPORT_TAGGED_POINTERS
#endif

LReturnZero:
    // x0 is already zero
    mov x1, #0
    movi    d0, #0
    movi    d1, #0
    movi    d2, #0
    movi    d3, #0
    ret

    END_ENTRY _objc_msgSend
```

æ ¹æ®æ±‡ç¼–å’Œæ³¨é‡Šï¼Œç†å‡ºå…¶æ ¸å¿ƒä¼ªä»£ç ä¸ºï¼š

```c
id objc_msgSend(id receiver, SEL selector, ...) {
    if (receiver == nil) return nil;
    Class cls = receiver->getIsa(); // 1
    imp = CacheLookup(receiver, selector); // 2 
    if (imp) return imp;
    // __objc_msgSend_uncached -> MethodTableLookup -> _lookUpImpOrForward
    imp = lookUpImpOrForward(receiver, selector, cls); // 3
    return imp;
}
```

## 1. è·å–isa

```
ldr p13, [x0]  // p13 = isa
GetClassFromIsa_p16 p13, 1, x0  // p16 = class

==> Class cls = receiver->getIsa();
```

`GetClassFromIsa_p16` æ±‡ç¼–ä»£ç ï¼š

```
.macro GetClassFromIsa_p16 src, needs_auth, auth_address /* note: auth_address is not required if !needs_auth */

#if SUPPORT_INDEXED_ISA
    // Indexed isa
    mov p16, \src           // optimistically set dst = src
    tbz p16, #ISA_INDEX_IS_NPI_BIT, 1f  // done if not non-pointer isa
    // isa in p16 is indexed
    adrp    x10, _objc_indexed_classes@PAGE
    add x10, x10, _objc_indexed_classes@PAGEOFF
    ubfx    p16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS  // extract index
    ldr p16, [x10, p16, UXTP #PTRSHIFT] // load class from array
1:

#elif __LP64__
.if \needs_auth == 0 // _cache_getImp takes an authed class already
    mov p16, \src
.else
    // 64-bit packed isa
    ExtractISA p16, \src, \auth_address
.endif
#else
    // 32-bit raw isa
    mov p16, \src

#endif

.endmacro
```

Cè¯­è¨€å®ç°ç‰ˆæœ¬ä¸º `getIsa`

```c
inline Class
objc_object::getIsa() 
{
    if (fastpath(!isTaggedPointer())) return ISA();

    extern objc_class OBJC_CLASS_$___NSUnrecognizedTaggedPointer;
    uintptr_t slot, ptr = (uintptr_t)this;
    Class cls;

    slot = (ptr >> _OBJC_TAG_SLOT_SHIFT) & _OBJC_TAG_SLOT_MASK;
    cls = objc_tag_classes[slot];
    if (slowpath(cls == (Class)&OBJC_CLASS_$___NSUnrecognizedTaggedPointer)) {
        slot = (ptr >> _OBJC_TAG_EXT_SLOT_SHIFT) & _OBJC_TAG_EXT_SLOT_MASK;
        cls = objc_tag_ext_classes[slot];
    }
    return cls;
}
```

## 2. ç¼“å­˜æŸ¥æ‰¾

```
CacheLookup NORMAL

==> imp = CacheLookup(receiver, selector);
```

`CacheLookup` åŒ…å«ä¸‰ç§æ¨¡å¼ `NORMAL` / `LOOKUP` / `GETIMP`

å…¶å…·ä½“æ±‡ç¼–é€»è¾‘å°±æ˜¯åœ¨ `objc_class` ç±»ç»“æ„ä½“ä¸­è·å– `cache_t` çš„ `buckets`ï¼Œå¾ªç¯æ¯”è¾ƒè¦æŸ¥æ‰¾çš„æ–¹æ³•åæ˜¯å¦åœ¨ç¼“å­˜åˆ—è¡¨ `buckets` ä¸­ï¼Œæ‰¾åˆ°è¿”å› `imp`ï¼Œæ²¡æœ‰æ‰¾åˆ°åˆ™è°ƒç”¨ `__objc_msgSend_uncached`ï¼ˆå…·ä½“æ•°æ®ç»“æ„åœ¨[OCæ–¹æ³•&OCç±»&OCå¯¹è±¡](https://houugen.fun/posts/oc%E6%96%B9%E6%B3%95oc%E7%B1%BBoc%E5%AF%B9%E8%B1%A1.html)ä¸­æŸ¥çœ‹ï¼‰

```
STATIC_ENTRY __objc_msgSend_uncached
UNWIND __objc_msgSend_uncached, FrameWithNoSaves

// THIS IS NOT A CALLABLE C FUNCTION
// Out-of-band p15 is the class to search

MethodTableLookup
TailCallFunctionPointer x17

END_ENTRY __objc_msgSend_uncached
```

`MethodTableLookup`ï¼š

```
.macro MethodTableLookup
    
    SAVE_REGS MSGSEND

    // lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)
    // receiver and selector already in x0 and x1
    mov x2, x16
    mov x3, #3
    bl  _lookUpImpOrForward

    // IMP in x0
    mov x17, x0

    RESTORE_REGS MSGSEND

.endmacro
```

## 3. æ–¹æ³•æŸ¥æ‰¾æµç¨‹

è€Œ `lookUpImpOrForward` ä½¿ç”¨Cå‡½æ•°å®ç°ï¼š

```c
NEVER_INLINE
IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)
{
    const IMP forward_imp = (IMP)_objc_msgForward_impcache;
    IMP imp = nil;
    Class curClass;

    runtimeLock.assertUnlocked();

    if (slowpath(!cls->isInitialized())) {
        // The first message sent to a class is often +new or +alloc, or +self
        // which goes through objc_opt_* or various optimized entry points.
        //
        // However, the class isn't realized/initialized yet at this point,
        // and the optimized entry points fall down through objc_msgSend,
        // which ends up here.
        //
        // We really want to avoid caching these, as it can cause IMP caches
        // to be made with a single entry forever.
        //
        // Note that this check is racy as several threads might try to
        // message a given class for the first time at the same time,
        // in which case we might cache anyway.
        behavior |= LOOKUP_NOCACHE;
    }

    // runtimeLock is held during isRealized and isInitialized checking
    // to prevent races against concurrent realization.

    // runtimeLock is held during method search to make
    // method-lookup + cache-fill atomic with respect to method addition.
    // Otherwise, a category could be added but ignored indefinitely because
    // the cache was re-filled with the old value after the cache flush on
    // behalf of the category.

    runtimeLock.lock();

    // We don't want people to be able to craft a binary blob that looks like
    // a class but really isn't one and do a CFI attack.
    //
    // To make these harder we want to make sure this is a class that was
    // either built into the binary or legitimately registered through
    // objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair.
    checkIsKnownClass(cls);

    cls = realizeAndInitializeIfNeeded_locked(inst, cls, behavior & LOOKUP_INITIALIZE);
    // runtimeLock may have been dropped but is now locked again
    runtimeLock.assertLocked();
    curClass = cls;

    // The code used to lookup the class's cache again right after
    // we take the lock but for the vast majority of the cases
    // evidence shows this is a miss most of the time, hence a time loss.
    //
    // The only codepath calling into this without having performed some
    // kind of cache lookup is class_getInstanceMethod().

    for (unsigned attempts = unreasonableClassCount();;) {
        if (curClass->cache.isConstantOptimizedCache(/* strict */true)) {
#if CONFIG_USE_PREOPT_CACHES
            imp = cache_getImp(curClass, sel);
            if (imp) goto done_unlock;
            curClass = curClass->cache.preoptFallbackClass();
#endif
        } else {
            // curClass method list.
            Method meth = getMethodNoSuper_nolock(curClass, sel);
            if (meth) {
                imp = meth->imp(false);
                goto done;
            }

            if (slowpath((curClass = curClass->getSuperclass()) == nil)) {
                // No implementation found, and method resolver didn't help.
                // Use forwarding.
                imp = forward_imp;
                break;
            }
        }

        // Halt if there is a cycle in the superclass chain.
        if (slowpath(--attempts == 0)) {
            _objc_fatal("Memory corruption in class list.");
        }

        // Superclass cache.
        imp = cache_getImp(curClass, sel);
        if (slowpath(imp == forward_imp)) {
            // Found a forward:: entry in a superclass.
            // Stop searching, but don't cache yet; call method
            // resolver for this class first.
            break;
        }
        if (fastpath(imp)) {
            // Found the method in a superclass. Cache it in this class.
            goto done;
        }
    }

    // No implementation found. Try method resolver once.

    if (slowpath(behavior & LOOKUP_RESOLVER)) {
        behavior ^= LOOKUP_RESOLVER;
        return resolveMethod_locked(inst, sel, cls, behavior);
    }

 done:
    if (fastpath((behavior & LOOKUP_NOCACHE) == 0)) {
#if CONFIG_USE_PREOPT_CACHES
        while (cls->cache.isConstantOptimizedCache(/* strict */true)) {
            cls = cls->cache.preoptFallbackClass();
        }
#endif
        log_and_fill_cache(cls, imp, sel, inst, curClass);
    }
 done_unlock:
    runtimeLock.unlock();
    if (slowpath((behavior & LOOKUP_NIL) && imp == forward_imp)) {
        return nil;
    }
    return imp;
}
```

è¿™æ˜¯ `objc-runtime-new.mm` ä¸­æºç ï¼Œå…¶å®å¯ä»¥ç»“åˆ `objc-runtime-old.mm` èƒ½æ›´æ¸…æ™°çš„ç†å‡ºå…¶é€»è¾‘ï¼š

- åˆå§‹åŒ–
- æœ¬ç±»ç¼“å­˜æŸ¥æ‰¾

- - æ‰¾åˆ°è¿”å› `IMP`

- æœ¬ç±»æ–¹æ³•åˆ—è¡¨æŸ¥æ‰¾

- - æ‰¾åˆ°è¿”å› IMP

- å¾ªç¯çˆ¶ç±»é“¾åœ¨çˆ¶ç±»ç¼“å­˜å’Œæ–¹æ³•åˆ—è¡¨æŸ¥æ‰¾

- - æ‰¾åˆ°è®°å½•è¿›ç¼“å­˜
  - è·å– `IMP`è¿”å›

- åŠ¨æ€æ–¹æ³•è§£æ

- - å®ä¾‹æ–¹æ³•è§£æ
  - ç±»æ–¹æ³•è§£æ

- é‡æ–°è¿›è¡Œä¸€è¾¹æ–¹æ³•æŸ¥æ‰¾æµç¨‹
- æ¶ˆæ¯è½¬å‘

### 3.1 æŸ¥æ‰¾æœ¬ç±»

```c
// æŸ¥æ‰¾æœ¬ç±»ç¼“å­˜
if (curClass->cache.isConstantOptimizedCache(/* strict */true)) {
    imp = cache_getImp(curClass, sel);
    if (imp) goto done_unlock;
    ...
    #endif
} else {
// æŸ¥æ‰¾æœ¬ç±»æ–¹æ³•åˆ—è¡¨
    // curClass method list.
    Method meth = getMethodNoSuper_nolock(curClass, sel);
    if (meth) {
        imp = meth->imp(false);
        goto done;
    }
```

### 3.2 æŸ¥æ‰¾çˆ¶ç±»

```c
// Superclass cache.
imp = cache_getImp(curClass, sel);
if (slowpath(imp == forward_imp)) {
    // Found a forward:: entry in a superclass.
    // Stop searching, but don't cache yet; call method
    // resolver for this class first.
    break;
}
if (fastpath(imp)) {
    // Found the method in a superclass. Cache it in this class.
    goto done;
}
```

å…¶ä¸­ `slowpath` å’Œ `fastpath` æ˜¯ä¸¤ä¸ªå®å®šä¹‰ï¼Œå…¶ä¸»è¦ä½œç”¨æ˜¯å‘Šè¯‰ç¼–è¯‘ `if` ä¸­æ˜¯å¤§æ¦‚ç‡è¿˜æ˜¯å°æ¦‚ç‡äº‹ä»¶ä»è€Œä¼˜åŒ–ä»£ç 

```c
// x å¤§æ¦‚ç‡æ˜¯1
#define fastpath(x) (__builtin_expect(bool(x), 1))
// x å¤§æ¦‚ç‡æ˜¯0
#define slowpath(x) (__builtin_expect(bool(x), 0))
```

æ‰€ä»¥ `slowpath(imp == forward_imp)` å°±æ˜¯å¤§æ¦‚ç‡ `imp` ä¸ç­‰äº `forward_imp`

`fastpath(imp)` æ˜¯ `imp` å¤§æ¦‚ç‡å­˜åœ¨

### 3.3 åŠ¨æ€æ–¹æ³•è§£æ

```objective-c
// No implementation found. Try method resolver once.
if (slowpath(behavior & LOOKUP_RESOLVER)) {
    behavior ^= LOOKUP_RESOLVER;
    return resolveMethod_locked(inst, sel, cls, behavior);
}
static NEVER_INLINE IMP
resolveMethod_locked(id inst, SEL sel, Class cls, int behavior)
{
    ...
    if (! cls->isMetaClass()) {
        // try [cls resolveInstanceMethod:sel]
        resolveInstanceMethod(inst, sel, cls);
    } 
    else {
        // try [nonMetaClass resolveClassMethod:sel]
        // and [cls resolveInstanceMethod:sel]
        resolveClassMethod(inst, sel, cls);
        if (!lookUpImpOrNilTryCache(inst, sel, cls)) {
            resolveInstanceMethod(inst, sel, cls);
        }
    }
    ...
}
```

`resolveMethod_locked` çš„é€»è¾‘æ˜¯å¦‚æœæœ¬ç±»æ˜¯å…ƒç±»ï¼Œè°ƒç”¨ `resolveInstanceMethod`ï¼›å¦‚æœä¸æ˜¯è¯´æ˜æ–¹æ³•æ˜¯å®ä¾‹æ–¹æ³•ï¼Œè°ƒç”¨ `resolveClassMethod`ã€‚

```c
static void resolveInstanceMethod(id inst, SEL sel, Class cls)
{
    ...
    SEL resolve_sel = @selector(resolveInstanceMethod:);
    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;
    bool resolved = msg(cls, resolve_sel, sel);

    // Cache the result (good or bad) so the resolver doesn't fire next time.
    // +resolveInstanceMethod adds to self a.k.a. cls
    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);
    ...
}
```

å‘é€è°ƒç”¨ `resolveInstanceMethod:` è§£æå™¨æ–¹æ³•ï¼ˆåœ¨ `NSObjcet` ä¸­å·²å®ç°ï¼‰ï¼Œè¯¥è§£æå™¨æ–¹æ³•åŠ¨æ€ä¸ºå®ä¾‹æ–¹æ³•çš„ `SEL` æä¾› `IMP`ï¼Œå¦‚æœæ‰¾åˆ°æ–¹æ³•å¹¶æ·»åŠ åˆ° `receiver` ä¸­è¿”å› `true`ã€‚**è§£ææˆåŠŸéœ€è¦é‡æ–°è¿›è¡Œæ–¹æ³•æŸ¥æ‰¾ä»¥ä¿éšœè¿”å› IMPã€‚**

### 3.4 é‡æ–°æ‰§è¡ŒæŸ¥æ‰¾æµç¨‹

```objective-c
static NEVER_INLINE IMP
resolveMethod_locked(id inst, SEL sel, Class cls, int behavior)
{
    ...
    // chances are that calling the resolver have populated the cache
    // so attempt using it
    return lookUpImpOrForwardTryCache(inst, sel, cls, behavior);
}

IMP lookUpImpOrForwardTryCache(id inst, SEL sel, Class cls, int behavior)
{
    return _lookUpImpTryCache(inst, sel, cls, behavior);
}

static IMP _lookUpImpTryCache(id inst, SEL sel, Class cls, int behavior)
{
    ...
    if (slowpath(imp == NULL)) {
        return lookUpImpOrForward(inst, sel, cls, behavior);
    }
    ...
}
```

æœ€ç»ˆä¼šå†æ‰§è¡Œ `lookUpImpOrForward` é‡èµ°æŸ¥æ‰¾æµç¨‹ã€‚

### 3.5 æ¶ˆæ¯è½¬å‘

å¦‚æœä»¥ä¸Šæµç¨‹éƒ½æ²¡æœ‰æ‰¾åˆ°æ–¹æ³• `IMP`ï¼Œåˆ™è¿›å…¥æ¶ˆæ¯è½¬å‘æµç¨‹ï¼Œè¿™ä¸ªæµç¨‹åˆè¿›å…¥åˆ°æ±‡ç¼–ä»£ç ä¸­

```objective-c
const IMP forward_imp = (IMP)_objc_msgForward_impcache;
// No implementation found, and method resolver didn't help.
// Use forwarding.
imp = forward_imp;
```

## 4. æ¶ˆæ¯è½¬å‘åˆ†æ

```
/********************************************************************
*
* id _objc_msgForward(id self, SEL _cmd,...);
*
* _objc_msgForward is the externally-callable
*   function returned by things like method_getImplementation().
* _objc_msgForward_impcache is the function pointer actually stored in
*   method caches.
*
********************************************************************/

    STATIC_ENTRY __objc_msgForward_impcache

    // No stret specialization.
    b   __objc_msgForward

    END_ENTRY __objc_msgForward_impcache

    
    ENTRY __objc_msgForward

    adrp    x17, __objc_forward_handler@PAGE
    ldr p17, [x17, __objc_forward_handler@PAGEOFF]
    TailCallFunctionPointer x17
    
    END_ENTRY __objc_msgForward
void *_objc_forward_handler = (void*)objc_defaultForwardHandler;
```

è¿™é‡Œå…¶å®è·Ÿä¸ä¸‹å»äº†ï¼ŒæŸ¥é˜…èµ„æ–™å‘ç°è¿™é‡Œæœ‰ä¸ªå°æŠ€å·§ï¼Œå¯ä»¥é€šè¿‡ `instrumentObjcMessageSends` æ‰“å¼€ `log`ï¼Œå¹¶ä¸”ä¼šä¿å­˜åœ¨ `/tmp/msgSends-%d` è·¯å¾„æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬åœ¨ `Demo` ä¸­æ·»åŠ ä»£ç ï¼š

{{< figure src="./æ–¹æ³•æŸ¥æ‰¾å’Œæ¶ˆæ¯è½¬å‘.assets/1616671729249-af8ecc77-e653-4584-ad7d-7bf0332156f7.png" width="80%" >}}

æŸ¥çœ‹æ—¥å¿—æ–‡ä»¶ï¼š

```
Student Student resolveInstanceMethod:
Student Student resolveInstanceMethod:
Student NSObject forwardingTargetForSelector:
Student NSObject forwardingTargetForSelector:
Student Student methodSignatureForSelector:
Student Student methodSignatureForSelector:
```

### 4.1 forwardingTargetForSelector

```objective-c
+ (id)forwardingTargetForSelector:(SEL)sel {
    return nil;
}

- (id)forwardingTargetForSelector:(SEL)sel {
    return nil;
}
```

æˆ‘ä»¬çœ‹ä¸‹[å®˜æ–¹æ¥å£æè¿°](https://developer.apple.com/documentation/objectivec/nsobject/1418855-forwardingtargetforselector?language=objc)ï¼š

{{< admonition quote >}}
If an object implements (or inherits) this method, and returns a non-`nil` (and non-`self`) result, that returned object is used as the new receiver object and the message dispatch resumes to that new object. (Obviously if you return `self` from this method, the code would just fall into an infinite loop.)

If you implement this method in a non-root class, if your class has nothing to return for the given selector then you should return the result of invoking superâ€™s implementation.

This method gives an object a chance to redirect an unknown message sent to it before the much more expensive [`forwardInvocation:`](https://developer.apple.com/documentation/objectivec/nsobject/1571955-forwardinvocation?language=objc) machinery takes over. This is useful when you simply want to redirect messages to another object and can be an order of magnitude faster than regular forwarding. It is not useful where the goal of the forwarding is to capture the NSInvocation, or manipulate the arguments or return value during the forwarding.

â€œå½“æ‚¨åªæƒ³å°†æ¶ˆæ¯é‡å®šå‘åˆ°å¦ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶ä¸”æ¯”å¸¸è§„è½¬å‘å¿«ä¸€ä¸ªæ•°é‡çº§æ—¶ï¼Œæ­¤åŠŸèƒ½å¾ˆæœ‰ç”¨â€
{{< /admonition >}}


æ¥ç ”ç©¶ä¸‹å¦‚ä½•ä½¿ç”¨ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ª `Teacher` ç±»ï¼Œä½†ä¸ç»§æ‰¿ `Person`ï¼Œé‚£æˆ‘ä»¬æƒ³è®© `Teacher` è°ƒç”¨ `Person` çš„ `sleep` æ–¹æ³•ï¼Œé€šè¿‡å¿«é€Ÿè½¬å‘åº”è¯¥å¦‚ä½•å®ç°ï¼š

```objective-c
// Teacher.m
@implementation Teacher

- (void)teach {
    NSLog(@"I am teaching");
}

- (id)forwardingTargetForSelector:(SEL)aSelector {
    NSLog(@"%s", __func__);
    Person *p = [[Person alloc] init];
    if ([p respondsToSelector: aSelector]) {
        return p;
    }
    return [super forwardingTargetForSelector: aSelector];
}

@end

// main.m ä¸­å³å¯å®ç° Teacher è°ƒç”¨ sleep
 Teacher *t = [[Teacher alloc] init];
 [t performSelector:@selector(sleep)];
```

{{< figure src="./æ–¹æ³•æŸ¥æ‰¾å’Œæ¶ˆæ¯è½¬å‘.assets/1617087298428-df71897e-0fcd-4170-8ca0-3e233bd24d9c.png" width="80%" >}}

### 4.2 methodSignatureForSelector

ä¹Ÿæ²¡æœ‰å…·ä½“å®ç°ï¼ŒåŒæ ·çœ‹ä¸‹æ–‡æ¡£

{{< admonition quote >}}
This method is used in the implementation of protocols. This method is also used in situations where an `NSInvocation` object must be created, such as during message forwarding. If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature.

â€œç”¨äº `NSInvocation` å¿…é¡»åˆ›å»ºå¯¹è±¡çš„æƒ…å†µä¸‹ï¼Œä¾‹å¦‚åœ¨æ¶ˆæ¯è½¬å‘æœŸé—´â€
{{< /admonition >}}


æ¥ç€ä¼šè°ƒç”¨ `forwardInvocation:` æ–¹æ³•è¿›è¡Œæ¶ˆæ¯è½¬å‘ã€‚

åŒæ ·ï¼Œæˆ‘ä»¬æƒ³å®ç° `forwardingTargetForSelector` ä¸­å±•ç¤ºçš„é‚£ç§èƒ½åŠ›ï¼Œçœ‹çœ‹åˆ©ç”¨ `methodSignatureForSelector` + `forwardInvocation` å¦‚ä½•code.

æˆ‘ä»¬ç»§ç»­åœ¨ `Teacher` ç±»ä¸­æ–½åŠ é­”æ³•ï¼š

```objective-c
// Teacher.m
@implementation Teacher

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    NSLog(@"%s", __func__);
    if (aSelector == @selector(walk)) {
        // è·å– SEL æ–¹æ³•ç­¾å
        NSMethodSignature *sig = [[Person new] methodSignatureForSelector:aSelector];
        return sig;
    }
    return [super methodSignatureForSelector:aSelector];
}

- (void)forwardInvocation:(NSInvocation *)anInvocation {
    NSLog(@"%@", anInvocation);
    // è·å– SEL æ¶ˆæ¯
    SEL s = [anInvocation selector];
    // å®ä¾‹åŒ– Person ç±»
    Person *p = [[Person alloc] init];
    // å‘æ¥æ”¶å¯¹è±¡ p å‘é€ SEL æ¶ˆæ¯
    if ([p respondsToSelector:s]) {
        [anInvocation invokeWithTarget:p];
    } else {
        [super forwardInvocation:anInvocation];
    }
}

@end

// main.m ä¸­å®ç° Teacher è°ƒç”¨ walk
// methodSignatureForSelector + forwardInvocation
[t performSelector:@selector(walk)];
```

{{< admonition warning >}}
è¯·æ³¨é‡Šæ‰4.1ä¸­çš„ `- (id)forwardingTargetForSelector:(SEL)aSelector` å®ç°ï¼Œå¦åˆ™ä¼šä¼˜å…ˆæ‰§è¡Œå¿«é€Ÿè½¬å‘æœºåˆ¶è€Œä¸ä¼šèµ°åˆ° `methodSignatureForSelector` ä¸­ã€‚
{{< /admonition >}}

![image.png](./æ–¹æ³•æŸ¥æ‰¾å’Œæ¶ˆæ¯è½¬å‘.assets/1617087769890-8bea3c09-5d83-459c-a07c-282021fd377b.png)

è¿™ä¸ªæ¶ˆæ¯è½¬å‘åŸç†æˆ‘ä»¬åç»­ä¼šåœ¨ä¸€äº›ç»å…¸çš„ `AOP` æ¡†æ¶åˆ†æä¸­çœ‹åˆ°å…¶åˆ©ç”¨ã€‚

## æ€»ç»“

æ•´ä¸ªæµç¨‹åŒ…æ‹¬ ç¼“å­˜æŸ¥æ‰¾ -> æœ¬ç±»çˆ¶ç±»æ–¹æ³•æŸ¥æ‰¾ -> åŠ¨æ€æ–¹æ³•è§£æ -> å¿«é€Ÿæ¶ˆæ¯è½¬å‘ -> æ…¢é€Ÿæ¶ˆæ¯è½¬å‘ã€‚è€Œå…¶ä¸­**åŠ¨æ€æ–¹æ³•è§£æ**ã€**å¿«é€Ÿæ¶ˆæ¯è½¬å‘**å’Œ**æ…¢é€Ÿæ¶ˆæ¯è½¬å‘**å°±æ˜¯ ğŸ ç»™çš„é¢å¤–ä¸‰æ¬¡å¯»æ‰¾ `IMP` çš„æœºä¼šã€‚

è‡³æ­¤ `obj_msgSend` çš„æ•´ä¸ªæµç¨‹æ¢³ç†å®Œæ¯•ï¼Œå…¶ä¸­å¾ˆå¤šç»†èŠ‚å»ºè®®è¯»è€…è‡ªå·±å»é˜…è¯»æ¢å¯»ã€‚
